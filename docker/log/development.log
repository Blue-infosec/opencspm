  [1m[35m (91.6ms)[0m  [1m[35mCREATE DATABASE "opencspm_development" ENCODING = 'unicode'[0m
  [1m[35mSQL (0.3ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (0.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "campaigns" CASCADE[0m
  [1m[35m (9.2ms)[0m  [1m[35mCREATE TABLE "campaigns" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "user_id" bigint NOT NULL, "filters" jsonb, "control_count" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_name" ON "campaigns"  ("name")[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_organization_id" ON "campaigns"  ("organization_id")[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_user_id" ON "campaigns"  ("user_id")[0m
  [1m[35m (0.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "controls" CASCADE[0m
  [1m[35m (6.0ms)[0m  [1m[35mCREATE TABLE "controls" ("id" bigserial primary key, "guid" character varying, "name" character varying, "title" character varying, "description" text, "platform" character varying, "impact" integer, "validation" character varying, "remediation" character varying, "refs" jsonb, "status" integer DEFAULT 0, "resources_failed" integer DEFAULT 0, "resources_total" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_guid" ON "controls"  ("guid")[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_name" ON "controls"  ("name")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_platform" ON "controls"  ("platform")[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_title" ON "controls"  ("title")[0m
  [1m[35m (0.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "identities" CASCADE[0m
  [1m[35m (4.5ms)[0m  [1m[35mCREATE TABLE "identities" ("id" bigserial primary key, "user_id" bigint NOT NULL, "provider" character varying, "uid" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE  INDEX  "index_identities_on_user_id" ON "identities"  ("user_id")[0m
  [1m[35m (0.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "issues" CASCADE[0m
  [1m[35m (3.2ms)[0m  [1m[35mCREATE TABLE "issues" ("id" bigserial primary key, "status" integer, "result_id" bigint NOT NULL, "resource_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_resource_id" ON "issues"  ("resource_id")[0m
  [1m[35m (10.5ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_result_id" ON "issues"  ("result_id")[0m
  [1m[35m (0.9ms)[0m  [1m[35mDROP TABLE IF EXISTS "jobs" CASCADE[0m
  [1m[35m (4.1ms)[0m  [1m[35mCREATE TABLE "jobs" ("id" bigserial primary key, "token" character varying, "status" integer, "issue_count" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_jobs_on_token" ON "jobs"  ("token")[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "organizations" CASCADE[0m
  [1m[35m (4.7ms)[0m  [1m[35mCREATE TABLE "organizations" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_organizations_on_name" ON "organizations"  ("name")[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "profiles" CASCADE[0m
  [1m[35m (3.7ms)[0m  [1m[35mCREATE TABLE "profiles" ("id" bigserial primary key, "name" character varying, "author" character varying, "platform" character varying, "tags" jsonb, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "resources" CASCADE[0m
  [1m[35m (3.5ms)[0m  [1m[35mCREATE TABLE "resources" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_resources_on_name" ON "resources"  ("name")[0m
  [1m[35m (0.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "results" CASCADE[0m
  [1m[35m (7.8ms)[0m  [1m[35mCREATE TABLE "results" ("id" bigserial primary key, "job_id" bigint NOT NULL, "data" jsonb, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL, "observed_at" timestamp(6))[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_control_id" ON "results"  ("control_id")[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_job_id" ON "results"  ("job_id")[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "roles" CASCADE[0m
  [1m[35m (4.6ms)[0m  [1m[35mCREATE TABLE "roles" ("id" bigserial primary key, "name" character varying, "resource_type" character varying, "resource_id" bigint, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (5.8ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_name_and_resource_type_and_resource_id" ON "roles"  ("name", "resource_type", "resource_id")[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_resource_type_and_resource_id" ON "roles"  ("resource_type", "resource_id")[0m
  [1m[35m (0.9ms)[0m  [1m[35mDROP TABLE IF EXISTS "sources" CASCADE[0m
  [1m[35m (4.6ms)[0m  [1m[35mCREATE TABLE "sources" ("id" bigserial primary key, "name" character varying, "location" character varying, "status" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (0.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "taggings" CASCADE[0m
  [1m[35m (4.4ms)[0m  [1m[35mCREATE TABLE "taggings" ("id" bigserial primary key, "tag_id" bigint NOT NULL, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_control_id" ON "taggings"  ("control_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_tag_id" ON "taggings"  ("tag_id")[0m
  [1m[35m (0.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "tags" CASCADE[0m
  [1m[35m (3.5ms)[0m  [1m[35mCREATE TABLE "tags" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "users" CASCADE[0m
  [1m[35m (3.7ms)[0m  [1m[35mCREATE TABLE "users" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "username" character varying DEFAULT '' NOT NULL, "password_digest" character varying DEFAULT '' NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_users_on_organization_id" ON "users"  ("organization_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE UNIQUE INDEX  "index_users_on_username" ON "users"  ("username")[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "users_roles" CASCADE[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE TABLE "users_roles" ("user_id" bigint, "role_id" bigint)[0m
  [1m[35m (3.2ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_role_id" ON "users_roles"  ("role_id")[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id_and_role_id" ON "users_roles"  ("user_id", "role_id")[0m
  [1m[35m (3.1ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id" ON "users_roles"  ("user_id")[0m
  [1m[35m (1.9ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_a74bb03c49"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (1.7ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_9eb8249bf2"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.8ms)[0m  [1m[35mALTER TABLE "identities" ADD CONSTRAINT "fk_rails_5373344100"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.6ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_41670766b9"
FOREIGN KEY ("resource_id")
  REFERENCES "resources" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_0da50c43eb"
FOREIGN KEY ("result_id")
  REFERENCES "results" ("id")
[0m
  [1m[35m (1.6ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_efb2ffdf17"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.7ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_66a308b2c3"
FOREIGN KEY ("job_id")
  REFERENCES "jobs" ("id")
[0m
  [1m[35m (2.1ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_b9f82f696d"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_9fcd2e236b"
FOREIGN KEY ("tag_id")
  REFERENCES "tags" ("id")
[0m
  [1m[35m (1.1ms)[0m  [1m[35mALTER TABLE "users" ADD CONSTRAINT "fk_rails_d7b9ff90af"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying NOT NULL PRIMARY KEY)[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (1.1ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES (20201002205546)[0m
  [1m[35m (4.4ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying NOT NULL PRIMARY KEY, "value" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.8ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mActiveRecord::InternalMetadata Create (1.0ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", "2020-10-07 21:39:02.928939"], ["updated_at", "2020-10-07 21:39:02.928939"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "schema_sha1"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mActiveRecord::InternalMetadata Create (0.3ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "schema_sha1"], ["value", "163903766f35f9962275f13f0d59169d8c264b10"], ["created_at", "2020-10-07 21:39:02.959698"], ["updated_at", "2020-10-07 21:39:02.959698"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35m (0.4ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35m (5.1ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35mSQL (0.3ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (4.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "campaigns" CASCADE[0m
  [1m[35m (4.6ms)[0m  [1m[35mCREATE TABLE "campaigns" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "user_id" bigint NOT NULL, "filters" jsonb, "control_count" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_name" ON "campaigns"  ("name")[0m
  [1m[35m (3.4ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_organization_id" ON "campaigns"  ("organization_id")[0m
  [1m[35m (5.9ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_user_id" ON "campaigns"  ("user_id")[0m
  [1m[35m (6.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "controls" CASCADE[0m
  [1m[35m (4.5ms)[0m  [1m[35mCREATE TABLE "controls" ("id" bigserial primary key, "guid" character varying, "name" character varying, "title" character varying, "description" text, "platform" character varying, "impact" integer, "validation" character varying, "remediation" character varying, "refs" jsonb, "status" integer DEFAULT 0, "resources_failed" integer DEFAULT 0, "resources_total" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_guid" ON "controls"  ("guid")[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_name" ON "controls"  ("name")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_platform" ON "controls"  ("platform")[0m
  [1m[35m (4.8ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_title" ON "controls"  ("title")[0m
  [1m[35m (4.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "identities" CASCADE[0m
  [1m[35m (4.8ms)[0m  [1m[35mCREATE TABLE "identities" ("id" bigserial primary key, "user_id" bigint NOT NULL, "provider" character varying, "uid" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_identities_on_user_id" ON "identities"  ("user_id")[0m
  [1m[35m (2.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "issues" CASCADE[0m
  [1m[35m (5.9ms)[0m  [1m[35mCREATE TABLE "issues" ("id" bigserial primary key, "status" integer, "result_id" bigint NOT NULL, "resource_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_resource_id" ON "issues"  ("resource_id")[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_result_id" ON "issues"  ("result_id")[0m
  [1m[35m (2.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "jobs" CASCADE[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE TABLE "jobs" ("id" bigserial primary key, "token" character varying, "status" integer, "issue_count" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_jobs_on_token" ON "jobs"  ("token")[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "organizations" CASCADE[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "organizations" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE  INDEX  "index_organizations_on_name" ON "organizations"  ("name")[0m
  [1m[35m (2.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "profiles" CASCADE[0m
  [1m[35m (4.1ms)[0m  [1m[35mCREATE TABLE "profiles" ("id" bigserial primary key, "name" character varying, "author" character varying, "platform" character varying, "tags" jsonb, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "resources" CASCADE[0m
  [1m[35m (6.9ms)[0m  [1m[35mCREATE TABLE "resources" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE  INDEX  "index_resources_on_name" ON "resources"  ("name")[0m
  [1m[35m (1.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "results" CASCADE[0m
  [1m[35m (5.1ms)[0m  [1m[35mCREATE TABLE "results" ("id" bigserial primary key, "job_id" bigint NOT NULL, "data" jsonb, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL, "observed_at" timestamp(6))[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_control_id" ON "results"  ("control_id")[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_job_id" ON "results"  ("job_id")[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "roles" CASCADE[0m
  [1m[35m (3.5ms)[0m  [1m[35mCREATE TABLE "roles" ("id" bigserial primary key, "name" character varying, "resource_type" character varying, "resource_id" bigint, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_name_and_resource_type_and_resource_id" ON "roles"  ("name", "resource_type", "resource_id")[0m
  [1m[35m (6.4ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_resource_type_and_resource_id" ON "roles"  ("resource_type", "resource_id")[0m
  [1m[35m (2.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "sources" CASCADE[0m
  [1m[35m (4.6ms)[0m  [1m[35mCREATE TABLE "sources" ("id" bigserial primary key, "name" character varying, "location" character varying, "status" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "taggings" CASCADE[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE TABLE "taggings" ("id" bigserial primary key, "tag_id" bigint NOT NULL, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_control_id" ON "taggings"  ("control_id")[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_tag_id" ON "taggings"  ("tag_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "tags" CASCADE[0m
  [1m[35m (4.1ms)[0m  [1m[35mCREATE TABLE "tags" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "users" CASCADE[0m
  [1m[35m (3.6ms)[0m  [1m[35mCREATE TABLE "users" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "username" character varying DEFAULT '' NOT NULL, "password_digest" character varying DEFAULT '' NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_users_on_organization_id" ON "users"  ("organization_id")[0m
  [1m[35m (3.5ms)[0m  [1m[35mCREATE UNIQUE INDEX  "index_users_on_username" ON "users"  ("username")[0m
  [1m[35m (2.0ms)[0m  [1m[35mDROP TABLE IF EXISTS "users_roles" CASCADE[0m
  [1m[35m (1.2ms)[0m  [1m[35mCREATE TABLE "users_roles" ("user_id" bigint, "role_id" bigint)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_role_id" ON "users_roles"  ("role_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id_and_role_id" ON "users_roles"  ("user_id", "role_id")[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id" ON "users_roles"  ("user_id")[0m
  [1m[35m (1.9ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_a74bb03c49"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (2.0ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_9eb8249bf2"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.1ms)[0m  [1m[35mALTER TABLE "identities" ADD CONSTRAINT "fk_rails_5373344100"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.7ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_41670766b9"
FOREIGN KEY ("resource_id")
  REFERENCES "resources" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_0da50c43eb"
FOREIGN KEY ("result_id")
  REFERENCES "results" ("id")
[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_efb2ffdf17"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_66a308b2c3"
FOREIGN KEY ("job_id")
  REFERENCES "jobs" ("id")
[0m
  [1m[35m (2.6ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_b9f82f696d"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_9fcd2e236b"
FOREIGN KEY ("tag_id")
  REFERENCES "tags" ("id")
[0m
  [1m[35m (3.4ms)[0m  [1m[35mALTER TABLE "users" ADD CONSTRAINT "fk_rails_d7b9ff90af"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (1.0ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "schema_sha1"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35m (0.7ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.6ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35m (0.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35mSQL (0.3ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (2.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "campaigns" CASCADE[0m
  [1m[35m (4.3ms)[0m  [1m[35mCREATE TABLE "campaigns" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "user_id" bigint NOT NULL, "filters" jsonb, "control_count" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_name" ON "campaigns"  ("name")[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_organization_id" ON "campaigns"  ("organization_id")[0m
  [1m[35m (1.4ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_user_id" ON "campaigns"  ("user_id")[0m
  [1m[35m (3.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "controls" CASCADE[0m
  [1m[35m (3.5ms)[0m  [1m[35mCREATE TABLE "controls" ("id" bigserial primary key, "guid" character varying, "name" character varying, "title" character varying, "description" text, "platform" character varying, "impact" integer, "validation" character varying, "remediation" character varying, "refs" jsonb, "status" integer DEFAULT 0, "resources_failed" integer DEFAULT 0, "resources_total" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.4ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_guid" ON "controls"  ("guid")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_name" ON "controls"  ("name")[0m
  [1m[35m (1.3ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_platform" ON "controls"  ("platform")[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_title" ON "controls"  ("title")[0m
  [1m[35m (2.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "identities" CASCADE[0m
  [1m[35m (5.8ms)[0m  [1m[35mCREATE TABLE "identities" ("id" bigserial primary key, "user_id" bigint NOT NULL, "provider" character varying, "uid" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_identities_on_user_id" ON "identities"  ("user_id")[0m
  [1m[35m (2.9ms)[0m  [1m[35mDROP TABLE IF EXISTS "issues" CASCADE[0m
  [1m[35m (4.2ms)[0m  [1m[35mCREATE TABLE "issues" ("id" bigserial primary key, "status" integer, "result_id" bigint NOT NULL, "resource_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_resource_id" ON "issues"  ("resource_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_result_id" ON "issues"  ("result_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mDROP TABLE IF EXISTS "jobs" CASCADE[0m
  [1m[35m (4.2ms)[0m  [1m[35mCREATE TABLE "jobs" ("id" bigserial primary key, "token" character varying, "status" integer, "issue_count" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_jobs_on_token" ON "jobs"  ("token")[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "organizations" CASCADE[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "organizations" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_organizations_on_name" ON "organizations"  ("name")[0m
  [1m[35m (1.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "profiles" CASCADE[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE TABLE "profiles" ("id" bigserial primary key, "name" character varying, "author" character varying, "platform" character varying, "tags" jsonb, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mDROP TABLE IF EXISTS "resources" CASCADE[0m
  [1m[35m (4.8ms)[0m  [1m[35mCREATE TABLE "resources" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_resources_on_name" ON "resources"  ("name")[0m
  [1m[35m (1.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "results" CASCADE[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "results" ("id" bigserial primary key, "job_id" bigint NOT NULL, "data" jsonb, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL, "observed_at" timestamp(6))[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_control_id" ON "results"  ("control_id")[0m
  [1m[35m (2.9ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_job_id" ON "results"  ("job_id")[0m
  [1m[35m (2.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "roles" CASCADE[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE TABLE "roles" ("id" bigserial primary key, "name" character varying, "resource_type" character varying, "resource_id" bigint, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_name_and_resource_type_and_resource_id" ON "roles"  ("name", "resource_type", "resource_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_resource_type_and_resource_id" ON "roles"  ("resource_type", "resource_id")[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "sources" CASCADE[0m
  [1m[35m (4.1ms)[0m  [1m[35mCREATE TABLE "sources" ("id" bigserial primary key, "name" character varying, "location" character varying, "status" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "taggings" CASCADE[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE TABLE "taggings" ("id" bigserial primary key, "tag_id" bigint NOT NULL, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_control_id" ON "taggings"  ("control_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_tag_id" ON "taggings"  ("tag_id")[0m
  [1m[35m (1.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "tags" CASCADE[0m
  [1m[35m (3.7ms)[0m  [1m[35mCREATE TABLE "tags" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "users" CASCADE[0m
  [1m[35m (4.3ms)[0m  [1m[35mCREATE TABLE "users" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "username" character varying DEFAULT '' NOT NULL, "password_digest" character varying DEFAULT '' NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_users_on_organization_id" ON "users"  ("organization_id")[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE UNIQUE INDEX  "index_users_on_username" ON "users"  ("username")[0m
  [1m[35m (1.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "users_roles" CASCADE[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE TABLE "users_roles" ("user_id" bigint, "role_id" bigint)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_role_id" ON "users_roles"  ("role_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id_and_role_id" ON "users_roles"  ("user_id", "role_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id" ON "users_roles"  ("user_id")[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_a74bb03c49"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (1.7ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_9eb8249bf2"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.6ms)[0m  [1m[35mALTER TABLE "identities" ADD CONSTRAINT "fk_rails_5373344100"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_41670766b9"
FOREIGN KEY ("resource_id")
  REFERENCES "resources" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_0da50c43eb"
FOREIGN KEY ("result_id")
  REFERENCES "results" ("id")
[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_efb2ffdf17"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.2ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_66a308b2c3"
FOREIGN KEY ("job_id")
  REFERENCES "jobs" ("id")
[0m
  [1m[35m (1.2ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_b9f82f696d"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (3.6ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_9fcd2e236b"
FOREIGN KEY ("tag_id")
  REFERENCES "tags" ("id")
[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "users" ADD CONSTRAINT "fk_rails_d7b9ff90af"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "schema_sha1"], ["LIMIT", 1]]
  [1m[35m (89.9ms)[0m  [1m[35mCREATE DATABASE "development" ENCODING = 'unicode'[0m
  [1m[35m (1.2ms)[0m  [1m[35mCREATE DATABASE "development" ENCODING = 'unicode'[0m
  [1m[35m (109.1ms)[0m  [1m[35mCREATE DATABASE "opencspm:5432" ENCODING = 'unicode'[0m
  [1m[35m (1.1ms)[0m  [1m[35mCREATE DATABASE "opencspm_development" ENCODING = 'unicode'[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE DATABASE "opencspm_development" ENCODING = 'unicode'[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE DATABASE "opencspm_development" ENCODING = 'unicode'[0m
  [1m[35m (77.1ms)[0m  [1m[35mCREATE DATABASE "opencspm_test" ENCODING = 'unicode'[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (1.0ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35mSQL (0.4ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (4.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "campaigns" CASCADE[0m
  [1m[35m (4.6ms)[0m  [1m[35mCREATE TABLE "campaigns" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "user_id" bigint NOT NULL, "filters" jsonb, "control_count" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (3.2ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_name" ON "campaigns"  ("name")[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_organization_id" ON "campaigns"  ("organization_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_user_id" ON "campaigns"  ("user_id")[0m
  [1m[35m (2.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "controls" CASCADE[0m
  [1m[35m (6.2ms)[0m  [1m[35mCREATE TABLE "controls" ("id" bigserial primary key, "guid" character varying, "name" character varying, "title" character varying, "description" text, "platform" character varying, "impact" integer, "validation" character varying, "remediation" character varying, "refs" jsonb, "status" integer DEFAULT 0, "resources_failed" integer DEFAULT 0, "resources_total" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_guid" ON "controls"  ("guid")[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_name" ON "controls"  ("name")[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_platform" ON "controls"  ("platform")[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_title" ON "controls"  ("title")[0m
  [1m[35m (3.1ms)[0m  [1m[35mDROP TABLE IF EXISTS "identities" CASCADE[0m
  [1m[35m (5.5ms)[0m  [1m[35mCREATE TABLE "identities" ("id" bigserial primary key, "user_id" bigint NOT NULL, "provider" character varying, "uid" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (3.2ms)[0m  [1m[35mCREATE  INDEX  "index_identities_on_user_id" ON "identities"  ("user_id")[0m
  [1m[35m (3.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "issues" CASCADE[0m
  [1m[35m (3.7ms)[0m  [1m[35mCREATE TABLE "issues" ("id" bigserial primary key, "status" integer, "result_id" bigint NOT NULL, "resource_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_resource_id" ON "issues"  ("resource_id")[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_result_id" ON "issues"  ("result_id")[0m
  [1m[35m (2.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "jobs" CASCADE[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE TABLE "jobs" ("id" bigserial primary key, "token" character varying, "status" integer, "issue_count" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_jobs_on_token" ON "jobs"  ("token")[0m
  [1m[35m (1.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "organizations" CASCADE[0m
  [1m[35m (4.3ms)[0m  [1m[35mCREATE TABLE "organizations" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_organizations_on_name" ON "organizations"  ("name")[0m
  [1m[35m (1.1ms)[0m  [1m[35mDROP TABLE IF EXISTS "profiles" CASCADE[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "profiles" ("id" bigserial primary key, "name" character varying, "author" character varying, "platform" character varying, "tags" jsonb, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "resources" CASCADE[0m
  [1m[35m (4.9ms)[0m  [1m[35mCREATE TABLE "resources" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_resources_on_name" ON "resources"  ("name")[0m
  [1m[35m (1.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "results" CASCADE[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "results" ("id" bigserial primary key, "job_id" bigint NOT NULL, "data" jsonb, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL, "observed_at" timestamp(6))[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_control_id" ON "results"  ("control_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_job_id" ON "results"  ("job_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "roles" CASCADE[0m
  [1m[35m (6.9ms)[0m  [1m[35mCREATE TABLE "roles" ("id" bigserial primary key, "name" character varying, "resource_type" character varying, "resource_id" bigint, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_name_and_resource_type_and_resource_id" ON "roles"  ("name", "resource_type", "resource_id")[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_resource_type_and_resource_id" ON "roles"  ("resource_type", "resource_id")[0m
  [1m[35m (1.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "sources" CASCADE[0m
  [1m[35m (4.2ms)[0m  [1m[35mCREATE TABLE "sources" ("id" bigserial primary key, "name" character varying, "location" character varying, "status" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "taggings" CASCADE[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "taggings" ("id" bigserial primary key, "tag_id" bigint NOT NULL, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_control_id" ON "taggings"  ("control_id")[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_tag_id" ON "taggings"  ("tag_id")[0m
  [1m[35m (1.1ms)[0m  [1m[35mDROP TABLE IF EXISTS "tags" CASCADE[0m
  [1m[35m (4.4ms)[0m  [1m[35mCREATE TABLE "tags" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.1ms)[0m  [1m[35mDROP TABLE IF EXISTS "users" CASCADE[0m
  [1m[35m (4.3ms)[0m  [1m[35mCREATE TABLE "users" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "username" character varying DEFAULT '' NOT NULL, "password_digest" character varying DEFAULT '' NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_users_on_organization_id" ON "users"  ("organization_id")[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE UNIQUE INDEX  "index_users_on_username" ON "users"  ("username")[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "users_roles" CASCADE[0m
  [1m[35m (2.8ms)[0m  [1m[35mCREATE TABLE "users_roles" ("user_id" bigint, "role_id" bigint)[0m
  [1m[35m (3.6ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_role_id" ON "users_roles"  ("role_id")[0m
  [1m[35m (4.4ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id_and_role_id" ON "users_roles"  ("user_id", "role_id")[0m
  [1m[35m (7.5ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id" ON "users_roles"  ("user_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_a74bb03c49"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (2.1ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_9eb8249bf2"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.0ms)[0m  [1m[35mALTER TABLE "identities" ADD CONSTRAINT "fk_rails_5373344100"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (3.0ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_41670766b9"
FOREIGN KEY ("resource_id")
  REFERENCES "resources" ("id")
[0m
  [1m[35m (1.8ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_0da50c43eb"
FOREIGN KEY ("result_id")
  REFERENCES "results" ("id")
[0m
  [1m[35m (3.3ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_efb2ffdf17"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (2.1ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_66a308b2c3"
FOREIGN KEY ("job_id")
  REFERENCES "jobs" ("id")
[0m
  [1m[35m (3.6ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_b9f82f696d"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (2.1ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_9fcd2e236b"
FOREIGN KEY ("tag_id")
  REFERENCES "tags" ("id")
[0m
  [1m[35m (2.2ms)[0m  [1m[35mALTER TABLE "users" ADD CONSTRAINT "fk_rails_d7b9ff90af"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (0.8ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "schema_sha1"], ["LIMIT", 1]]
  [1m[35mSQL (0.7ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (0.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "campaigns" CASCADE[0m
  [1m[35m (9.4ms)[0m  [1m[35mCREATE TABLE "campaigns" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "user_id" bigint NOT NULL, "filters" jsonb, "control_count" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (4.3ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_name" ON "campaigns"  ("name")[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_organization_id" ON "campaigns"  ("organization_id")[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_user_id" ON "campaigns"  ("user_id")[0m
  [1m[35m (0.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "controls" CASCADE[0m
  [1m[35m (4.5ms)[0m  [1m[35mCREATE TABLE "controls" ("id" bigserial primary key, "guid" character varying, "name" character varying, "title" character varying, "description" text, "platform" character varying, "impact" integer, "validation" character varying, "remediation" character varying, "refs" jsonb, "status" integer DEFAULT 0, "resources_failed" integer DEFAULT 0, "resources_total" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (5.4ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_guid" ON "controls"  ("guid")[0m
  [1m[35m (3.3ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_name" ON "controls"  ("name")[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_platform" ON "controls"  ("platform")[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_title" ON "controls"  ("title")[0m
  [1m[35m (0.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "identities" CASCADE[0m
  [1m[35m (5.3ms)[0m  [1m[35mCREATE TABLE "identities" ("id" bigserial primary key, "user_id" bigint NOT NULL, "provider" character varying, "uid" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_identities_on_user_id" ON "identities"  ("user_id")[0m
  [1m[35m (0.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "issues" CASCADE[0m
  [1m[35m (2.9ms)[0m  [1m[35mCREATE TABLE "issues" ("id" bigserial primary key, "status" integer, "result_id" bigint NOT NULL, "resource_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_resource_id" ON "issues"  ("resource_id")[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_result_id" ON "issues"  ("result_id")[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "jobs" CASCADE[0m
  [1m[35m (7.8ms)[0m  [1m[35mCREATE TABLE "jobs" ("id" bigserial primary key, "token" character varying, "status" integer, "issue_count" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE  INDEX  "index_jobs_on_token" ON "jobs"  ("token")[0m
  [1m[35m (0.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "organizations" CASCADE[0m
  [1m[35m (5.4ms)[0m  [1m[35mCREATE TABLE "organizations" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE  INDEX  "index_organizations_on_name" ON "organizations"  ("name")[0m
  [1m[35m (1.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "profiles" CASCADE[0m
  [1m[35m (5.1ms)[0m  [1m[35mCREATE TABLE "profiles" ("id" bigserial primary key, "name" character varying, "author" character varying, "platform" character varying, "tags" jsonb, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "resources" CASCADE[0m
  [1m[35m (5.3ms)[0m  [1m[35mCREATE TABLE "resources" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE  INDEX  "index_resources_on_name" ON "resources"  ("name")[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "results" CASCADE[0m
  [1m[35m (4.3ms)[0m  [1m[35mCREATE TABLE "results" ("id" bigserial primary key, "job_id" bigint NOT NULL, "data" jsonb, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL, "observed_at" timestamp(6))[0m
  [1m[35m (6.3ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_control_id" ON "results"  ("control_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_job_id" ON "results"  ("job_id")[0m
  [1m[35m (0.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "roles" CASCADE[0m
  [1m[35m (4.6ms)[0m  [1m[35mCREATE TABLE "roles" ("id" bigserial primary key, "name" character varying, "resource_type" character varying, "resource_id" bigint, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_name_and_resource_type_and_resource_id" ON "roles"  ("name", "resource_type", "resource_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_resource_type_and_resource_id" ON "roles"  ("resource_type", "resource_id")[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "sources" CASCADE[0m
  [1m[35m (5.6ms)[0m  [1m[35mCREATE TABLE "sources" ("id" bigserial primary key, "name" character varying, "location" character varying, "status" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (0.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "taggings" CASCADE[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "taggings" ("id" bigserial primary key, "tag_id" bigint NOT NULL, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_control_id" ON "taggings"  ("control_id")[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_tag_id" ON "taggings"  ("tag_id")[0m
  [1m[35m (0.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "tags" CASCADE[0m
  [1m[35m (4.0ms)[0m  [1m[35mCREATE TABLE "tags" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (0.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "users" CASCADE[0m
  [1m[35m (4.1ms)[0m  [1m[35mCREATE TABLE "users" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "username" character varying DEFAULT '' NOT NULL, "password_digest" character varying DEFAULT '' NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_users_on_organization_id" ON "users"  ("organization_id")[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE UNIQUE INDEX  "index_users_on_username" ON "users"  ("username")[0m
  [1m[35m (0.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "users_roles" CASCADE[0m
  [1m[35m (1.4ms)[0m  [1m[35mCREATE TABLE "users_roles" ("user_id" bigint, "role_id" bigint)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_role_id" ON "users_roles"  ("role_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id_and_role_id" ON "users_roles"  ("user_id", "role_id")[0m
  [1m[35m (3.4ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id" ON "users_roles"  ("user_id")[0m
  [1m[35m (2.7ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_a74bb03c49"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_9eb8249bf2"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.7ms)[0m  [1m[35mALTER TABLE "identities" ADD CONSTRAINT "fk_rails_5373344100"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.6ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_41670766b9"
FOREIGN KEY ("resource_id")
  REFERENCES "resources" ("id")
[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_0da50c43eb"
FOREIGN KEY ("result_id")
  REFERENCES "results" ("id")
[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_efb2ffdf17"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.8ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_66a308b2c3"
FOREIGN KEY ("job_id")
  REFERENCES "jobs" ("id")
[0m
  [1m[35m (1.7ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_b9f82f696d"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (2.2ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_9fcd2e236b"
FOREIGN KEY ("tag_id")
  REFERENCES "tags" ("id")
[0m
  [1m[35m (1.6ms)[0m  [1m[35mALTER TABLE "users" ADD CONSTRAINT "fk_rails_d7b9ff90af"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying NOT NULL PRIMARY KEY)[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (1.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES (20201002205546)[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying NOT NULL PRIMARY KEY, "value" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mActiveRecord::InternalMetadata Create (1.0ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", "2020-10-07 21:57:55.063739"], ["updated_at", "2020-10-07 21:57:55.063739"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[35m (0.9ms)[0m  [1m[35mBEGIN[0m
  [1m[36mActiveRecord::InternalMetadata Update (0.5ms)[0m  [1m[33mUPDATE "ar_internal_metadata" SET "value" = $1, "updated_at" = $2 WHERE "ar_internal_metadata"."key" = $3[0m  [["value", "test"], ["updated_at", "2020-10-07 21:57:55.080013"], ["key", "environment"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "schema_sha1"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mActiveRecord::InternalMetadata Create (0.3ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "schema_sha1"], ["value", "163903766f35f9962275f13f0d59169d8c264b10"], ["created_at", "2020-10-07 21:57:55.090915"], ["updated_at", "2020-10-07 21:57:55.090915"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mOrganization Load (0.4ms)[0m  [1m[34mSELECT "organizations".* FROM "organizations" WHERE "organizations"."name" = $1 LIMIT $2[0m  [["name", "Demo Organization"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mOrganization Create (0.5ms)[0m  [1m[32mINSERT INTO "organizations" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Demo Organization"], ["created_at", "2020-10-07 21:57:55.160338"], ["updated_at", "2020-10-07 21:57:55.160338"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mUser Load (0.3ms)[0m  [1m[34mSELECT "users".* FROM "users" WHERE "users"."username" = $1 LIMIT $2[0m  [["username", "demo"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mUser Create (1.7ms)[0m  [1m[32mINSERT INTO "users" ("name", "organization_id", "username", "password_digest", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["name", "Demo"], ["organization_id", 1], ["username", "demo"], ["password_digest", "$2a$12$G6of1Os7EbykD7zd2jwCBuKkKIpGHM/GdmUk7Th6rNB4gqWLYNvci"], ["created_at", "2020-10-07 21:57:55.389479"], ["updated_at", "2020-10-07 21:57:55.389479"]]
  [1m[36mRole Load (0.6ms)[0m  [1m[34mSELECT "roles".* FROM "roles" INNER JOIN "users_roles" ON "roles"."id" = "users_roles"."role_id" WHERE "users_roles"."user_id" = $1[0m  [["user_id", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mRole Load (0.6ms)[0m  [1m[34mSELECT "roles".* FROM "roles" WHERE "roles"."name" = $1 AND "roles"."resource_type" IS NULL AND "roles"."resource_id" IS NULL ORDER BY "roles"."id" ASC LIMIT $2[0m  [["name", "user"], ["LIMIT", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mRole Create (1.4ms)[0m  [1m[32mINSERT INTO "roles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "user"], ["created_at", "2020-10-07 21:57:55.432591"], ["updated_at", "2020-10-07 21:57:55.432591"]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mRole Exists? (1.0ms)[0m  [1m[34mSELECT 1 AS one FROM "roles" WHERE "roles"."name" = $1 LIMIT $2[0m  [["name", "user"], ["LIMIT", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mUser::HABTM_Roles Create (1.1ms)[0m  [1m[32mINSERT INTO "users_roles" ("user_id", "role_id") VALUES ($1, $2)[0m  [["user_id", 1], ["role_id", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mSource Load (0.5ms)[0m  [1m[34mSELECT "sources".* FROM "sources" WHERE "sources"."name" = $1 LIMIT $2[0m  [["name", "Cloud Asset Inventory"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Create (0.8ms)[0m  [1m[32mINSERT INTO "sources" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Cloud Asset Inventory"], ["created_at", "2020-10-07 21:57:55.469939"], ["updated_at", "2020-10-07 21:57:55.469939"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Update (0.5ms)[0m  [1m[33mUPDATE "sources" SET "location" = $1, "status" = $2, "updated_at" = $3 WHERE "sources"."id" = $4[0m  [["location", "gcs://bucket-acme-8765/cai"], ["status", 1], ["updated_at", "2020-10-07 21:57:55.477528"], ["id", 1]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mSource Load (0.5ms)[0m  [1m[34mSELECT "sources".* FROM "sources" WHERE "sources"."name" = $1 LIMIT $2[0m  [["name", "Kubernetes Sync Inventory"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Create (0.4ms)[0m  [1m[32mINSERT INTO "sources" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Kubernetes Sync Inventory"], ["created_at", "2020-10-07 21:57:55.485451"], ["updated_at", "2020-10-07 21:57:55.485451"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Update (0.4ms)[0m  [1m[33mUPDATE "sources" SET "location" = $1, "status" = $2, "updated_at" = $3 WHERE "sources"."id" = $4[0m  [["location", "gcs://bucket-acme-8765/k8s"], ["status", 0], ["updated_at", "2020-10-07 21:57:55.490927"], ["id", 2]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mSource Load (0.3ms)[0m  [1m[34mSELECT "sources".* FROM "sources" WHERE "sources"."name" = $1 LIMIT $2[0m  [["name", "Demo Kubernetes Inventory"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Create (0.5ms)[0m  [1m[32mINSERT INTO "sources" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Demo Kubernetes Inventory"], ["created_at", "2020-10-07 21:57:55.498147"], ["updated_at", "2020-10-07 21:57:55.498147"]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Update (0.6ms)[0m  [1m[33mUPDATE "sources" SET "location" = $1, "status" = $2, "updated_at" = $3 WHERE "sources"."id" = $4[0m  [["location", "file://200924_cai.json"], ["status", 0], ["updated_at", "2020-10-07 21:57:55.507385"], ["id", 3]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Darkbit Best Practices"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.6ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Darkbit Best Practices"], ["created_at", "2020-10-07 21:57:55.553122"], ["updated_at", "2020-10-07 21:57:55.553122"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.4ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"db-bp-1\",\"gcp\"]"], ["updated_at", "2020-10-07 21:57:55.559368"], ["id", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.3ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Google Cloud CIS 1.1"], ["LIMIT", 1]]
  [1m[35m (0.9ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (1.0ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Google Cloud CIS 1.1"], ["created_at", "2020-10-07 21:57:55.566893"], ["updated_at", "2020-10-07 21:57:55.566893"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.6ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"cis-1.1\",\"pci-3.4\",\"k8s-critical\"]"], ["updated_at", "2020-10-07 21:57:55.576273"], ["id", 2]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "GKE CIS 1.1"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.5ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "GKE CIS 1.1"], ["created_at", "2020-10-07 21:57:55.584857"], ["updated_at", "2020-10-07 21:57:55.584857"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.5ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Kubernetes"], ["tags", "[\"cis-1.1\",\"gke\",\"hipaa-6.2\",\"hipaa-7.5\"]"], ["updated_at", "2020-10-07 21:57:55.591634"], ["id", 3]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "PCI DSS"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.8ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "PCI DSS"], ["created_at", "2020-10-07 21:57:55.599364"], ["updated_at", "2020-10-07 21:57:55.599364"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.5ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"pci\",\"gcp\",\"gke\"]"], ["updated_at", "2020-10-07 21:57:55.607365"], ["id", 4]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.5ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "AWS Well Architected"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.5ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "AWS Well Architected"], ["created_at", "2020-10-07 21:57:55.615804"], ["updated_at", "2020-10-07 21:57:55.615804"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.4ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "AWS"], ["tags", "[\"well-architected\",\"aws-bp\"]"], ["updated_at", "2020-10-07 21:57:55.621992"], ["id", 5]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Public Resources - AWS"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.5ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Public Resources - AWS"], ["created_at", "2020-10-07 21:57:55.629933"], ["updated_at", "2020-10-07 21:57:55.629933"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.7ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "AWS"], ["tags", "[\"public-resources\",\"db-bp-2\"]"], ["updated_at", "2020-10-07 21:57:55.636787"], ["id", 6]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.3ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Public Resources - GCP"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.4ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Public Resources - GCP"], ["created_at", "2020-10-07 21:57:55.645859"], ["updated_at", "2020-10-07 21:57:55.645859"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.5ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"public-resources\",\"db-bg-3\",\"k8s-service-mesh\"]"], ["updated_at", "2020-10-07 21:57:55.651541"], ["id", 7]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.3ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "GKE Critical"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.5ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "GKE Critical"], ["created_at", "2020-10-07 21:57:55.659932"], ["updated_at", "2020-10-07 21:57:55.659932"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (1.4ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"gke-critical\"]"], ["updated_at", "2020-10-07 21:57:55.666630"], ["id", 8]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "K8s Visibility"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.4ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "K8s Visibility"], ["created_at", "2020-10-07 21:57:55.676646"], ["updated_at", "2020-10-07 21:57:55.676646"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.5ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Kubernetes"], ["tags", "[\"k8s-logging\"]"], ["updated_at", "2020-10-07 21:57:55.682118"], ["id", 9]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "77fe366c-b65a-5051-b211-a4ca2ec23662"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.9ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "77fe366c-b65a-5051-b211-a4ca2ec23662"], ["created_at", "2020-10-07 21:57:55.755976"], ["updated_at", "2020-10-07 21:57:55.755976"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 1]]
  [1m[36mTag Load (1.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTag Create (0.8ms)[0m  [1m[32mINSERT INTO "tags" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "dbc"], ["created_at", "2020-10-07 21:57:55.794300"], ["updated_at", "2020-10-07 21:57:55.794300"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.2ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 1], ["created_at", "2020-10-07 21:57:55.827236"], ["updated_at", "2020-10-07 21:57:55.827236"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.2ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-2"], ["title", "Centralized Secrets Management not in use"], ["description", "As infrastructure-as-code automation becomes widely used in an environment, it becomes possible to consistently separate out secret material from applications and code in a standard way. Once this happens, patterns in the code will emerge where the same secrets are stored and used in multiple places in the infrastructure.  Using a centralized, secure system for storing and accessing them that is able to operate in a cloud-native environment provides a means for centralized provisioning, auditing, rotation, and revocation of all secrets in the organization.  The damage due to credential theft and time available to an attacker with automatically rotated credentials is significantly decreased, and the likelihood for sensitive secret material to be exposed to additional persons or systems than are required is also diminished."], ["platform", "global"], ["impact", 5], ["validation", "\nReview all source control repositories, artifact creation processes, and deployment pipelines for the presence of static secrets in configuration files and ensure those values are not \"hardcoded\".  Ensure all new developers are trained on secure handling of secrets, and add secrets handling checks to all pull request/code reviews."], ["remediation", "\nConsider deploying a centralized system such as Hashicorp Vault or GCP Secrets Manager and working through all aspects of the infrastructure to remove statically defined secrets in favor of fetching them dynamically from a centrals secret store."], ["refs", "[{\"text\":\"Hashicorp Vault\",\"url\":\"https://www.hashicorp.com/products/vault/\",\"ref\":\"link\"},{\"text\":\"GCP Secrets Manager\",\"url\":\"https://cloud.google.com/secret-manager/docs\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:55.834334"], ["id", 1]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f0258634-29df-5872-9cec-4a329d66f4ca"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f0258634-29df-5872-9cec-4a329d66f4ca"], ["created_at", "2020-10-07 21:57:55.849388"], ["updated_at", "2020-10-07 21:57:55.849388"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 2]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 2], ["created_at", "2020-10-07 21:57:55.867404"], ["updated_at", "2020-10-07 21:57:55.867404"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-3"], ["title", "Centralized Logging and Monitoring should be off-node and off-cluster"], ["description", "Without all systems, OS applications, Kubernetes components, and container applications logging and sending metrics to a centralized point outside of the primary cluster, the operations team will not be in a position to observe, triage, and accurately troubleshoot issues as they occur.  As a Security Analysis SaaS offering, system availability and reliable ingestion pipelines are vital to the value of the service.  Without a deep understanding of all critical aspects and logging tendencies of all applications and system components, a strong understanding of what falls inside the \"norm\" versus what is broken is difficult to diagnose when one component is not operating correctly."], ["platform", "global"], ["impact", 9], ["validation", "\nEnsure that all virtual machine instances and Kubernetes clusters are configured to ship logs and metrics to an appropriate, separate destination.  When new resources are being created, validate their logs and metrics are being correctly received."], ["remediation", "\nAll platform logs should be centrally collected, analyzed, and leveraged to understand system errors when they occur and how they affect operations.  All metrics should be centrally collected, charted, and leveraged to understand load, usage, and resource consumption as it relates to ingestion rates.  For example, all CPU/RAM/Network/Disk metrics should be collected for VMs and containers in addition to application-specific metrics such as logs per second, average log size, log processing time per \"hop\", etc.  Both performance metrics and log event metrics should be gathered outside the cluster they are originating from into a central point to be able to understand what \"healthy\" means for each and every system, Kubernetes component, and containerized deployment.  In GCP, the main point of log and metrics aggregation for all GKE clusters, GKE pods, GKE nodes, GCE instances, Firewall logs, VPC flow logs, and more is Stackdriver.  However, the log filtering and metrics visualization capabilities may not be as full-featured as commercial offerings, and this is a common point of third-party integration for GCP organizations."], ["refs", "[{\"text\":\"GCP Stackdriver\",\"url\":\"https://cloud.google.com/stackdriver#documentation\",\"ref\":\"link\"},{\"text\":\"Grafana Stackdriver Integration\",\"url\":\"https://grafana.com/docs/grafana/latest/features/datasources/stackdriver/\",\"ref\":\"link\"},{\"text\":\"Datadog\",\"url\":\"https://www.datadoghq.com/\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-2\",\"DE.AE-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:55.883833"], ["id", 2]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "a8e1c332-1fa8-5ea4-92df-56622a3b973c"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "a8e1c332-1fa8-5ea4-92df-56622a3b973c"], ["created_at", "2020-10-07 21:57:55.900155"], ["updated_at", "2020-10-07 21:57:55.900155"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 3]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 3], ["created_at", "2020-10-07 21:57:55.915160"], ["updated_at", "2020-10-07 21:57:55.915160"]]
  [1m[35m (4.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-9"], ["title", "Project Lifecycle should be automated"], ["description", "When creating GCP projects, there are several steps that should be followed to ensure consistency and standardization of the base configuration of all projects.  Using automation with infrastructure-as-code tools like Terraform to manage the creation and management of all GCP projects greatly improves the ease of administration and enforces security best practices."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud projects list` and review projects for consistent application of initial project settings and following of conventions using `gcloud compute networks list`, `gcloud compute firewall-rules list`, and `gcloud iam service-accounts list/get-iam-policy`."], ["remediation", "\nUsing Terraform code stored in source control repositories, define and create all GCP projects using code.  Ensure that projects do not include the default networks and firewall rules, the default compute service account is not bound to \"Project Editor\", and incorporate any other standard settings for all projects to have.  The Cloud Foundation Toolkit from Google offers a pre-made Terraform module to make this easier."], ["refs", "[{\"text\":\"Terraform\",\"url\":\"https://www.terraform.io/\",\"ref\":\"link\"},{\"text\":\"Google Project Factory\",\"url\":\"https://github.com/terraform-google-modules/terraform-google-project-factory\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-2\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:55.960217"], ["id", 3]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2607af8b-07eb-5f45-8105-c8f0a68247c8"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2607af8b-07eb-5f45-8105-c8f0a68247c8"], ["created_at", "2020-10-07 21:57:55.972815"], ["updated_at", "2020-10-07 21:57:55.972815"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 4]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 4], ["created_at", "2020-10-07 21:57:55.987214"], ["updated_at", "2020-10-07 21:57:55.987214"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-10"], ["title", "Security Policies should be enforced using Organization Policies"], ["description", "GCP IAM grants users the ability to create or modify resources, but GCP Organization Policies help control how those resources are defined.  For example, a user might be able to create a GCE instance, but a \"constraint\" has been placed by an Organization Policy that prevents the instance from having an external IP address attached.  Organization Policies can be applied at the Org node, a GCP Folder, or at a GCP Project level, and they offer a way for GCP Administrators to delegate control over resources so long as they follow the desired constraints."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud beta resource-manager org-policies list --organization=ORGID` or `--folder=FOLDERID` or `--project=PROJECTID` to validate the organization policies are in the correct place in the hierarchy."], ["remediation", "\nThe following policies are recommended:\n\n* Prevent Instances from having external IPs\n* Skip Default Network creation during project creation\n* Trusted GCE Images enforcement\n* Serial Port Access\n* Service Account Key creation of user-managed keys\n\nUsing GCP Folders directly under the Organization node, apply the above constraints to a Folder.  For approved exemptions, places those resources inside Projects under a sibling Folder under the Organization node and apply the modified Organization Policy to that Folder.  It's recommended that proper testing be performed in a dedicated folder containing only test projects and resources to understand the behavior."], ["refs", "[{\"text\":\"GCP Organization Policies\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/overview\",\"ref\":\"link\"},{\"text\":\"Understanding Organization Policies\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/understanding-constraints\",\"ref\":\"link\"},{\"ids\":[\"ID.GV-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:55.994246"], ["id", 4]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f4a5c64d-5db9-57e3-aa23-569e995cdb54"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f4a5c64d-5db9-57e3-aa23-569e995cdb54"], ["created_at", "2020-10-07 21:57:56.005327"], ["updated_at", "2020-10-07 21:57:56.005327"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 5]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 5], ["created_at", "2020-10-07 21:57:56.020895"], ["updated_at", "2020-10-07 21:57:56.020895"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.2ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-11"], ["title", "Project names should follow a consistent naming convention"], ["description", "GCP Project names are visible in many places in the UI, the CLI, and in logs.  Consistently naming projects can help ease administration as the purpose of the project can be encoded in the name with some upfront planning."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud projects list` and look for projects that do not follow the defined naming convention as potential points of project creation that do not follow automated processes."], ["remediation", "\nCreate all GCP project IDs using a scheme such as: <org abbrev>-<environment>-<application or stack name> and also use the same string for the project name.  e.g. acme-dev-frontend or acme-prod-backendcluster.  Do not include sensitive information in project IDs.  Project IDs can have 4-30 lowercase letters, digits, or hyphens, must start with a lowercase letter, and must end with a letter or number."], ["refs", "[{\"text\":\"GCP Projects\",\"url\":\"https://cloud.google.com/resource-manager/docs/creating-managing-projects\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.028800"], ["id", 5]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5be7cee6-ee00-56ec-b271-4b2b6a6a3b34"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5be7cee6-ee00-56ec-b271-4b2b6a6a3b34"], ["created_at", "2020-10-07 21:57:56.045311"], ["updated_at", "2020-10-07 21:57:56.045311"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 6]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 6], ["created_at", "2020-10-07 21:57:56.056694"], ["updated_at", "2020-10-07 21:57:56.056694"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-12"], ["title", "Resource Structure does not follow the proper hierarchy aligned with environment separation goals"], ["description", "Folders and Projects should be implemented in a hierarchical pattern aligned with the ownership of teams and applications.  Projects should contain a single set of directly related resources and separated into different projects for each environment type (dev/stage/prod).\n\nAny change to the network, virtual machines, operating system, Kubernetes components, and applications running inside Kubernetes requires proper testing to ensure that change operates as desired.  Managing the risk of each change is best handled by creating dedicated environments using identical infrastructure-as-code techniques.  Without a \"dev\" or \"test\" environment, every change in the sole production cluster is inherently untested and a potential point for causing an outage."], ["platform", "gcp"], ["impact", 9], ["validation", "\nUse the GCP UI to view the folder and project structure.  Ensure the hierarchy and naming align with environment types and resources inside each project correspond to that environment only."], ["remediation", "\nUsing infrastructure-as-code tools such as Terraform, create identical environments for development, test/staging to complement the production environment.  Test all changes, upgrades, and fixes in the development environment, and perform those changes cleanly on the test/staging environment.  With a solid understanding of the changes and effects, planning and deploying to production becomes much less risky.  As a side effect of building environments with code, it provides confidence of full-environment reproducibility.\n\nUnder the organization node, create one or more folders that represents each service offering or \"stack\". e.g. \"SaaS\".  Under the \"SaaS\" folder, create folders for \"Dev\", \"Stage\", and \"Prod\".  Under each of those folders, create one or more projects to hold those resources that align with the environment.  By using folders, IAM permissions can be granted on the parent folder and they are inherited by the projects under them.  In addition, Stackdriver audit log sinks (exports) can be configured on a folder and apply to all logs from all projects underneath.\n\nMoving from one environment to 3 requires some changes to the centralized administrative access and monitoring/logging systems, so consider the Shared VPC approach VPC peering to help isolate identical copies of environments yet still manage and monitor them consistently."], ["refs", "[{\"text\":\"GCP Shared VPCs\",\"url\":\"https://cloud.google.com/vpc/docs/shared-vpc\",\"ref\":\"link\"},{\"text\":\"Terraform\",\"url\":\"https://www.terraform.io/\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.AM-3\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.065941"], ["id", 6]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e895db93-5bf2-55a0-9adc-17731c080bd8"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e895db93-5bf2-55a0-9adc-17731c080bd8"], ["created_at", "2020-10-07 21:57:56.078410"], ["updated_at", "2020-10-07 21:57:56.078410"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 7]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 7], ["created_at", "2020-10-07 21:57:56.094296"], ["updated_at", "2020-10-07 21:57:56.094296"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.2ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-14"], ["title", "IAM ServiceAccountUser granted at the project level"], ["description", "When creating a GCP resources that attaches a GCP service account, the calling user or service account must have the permission to \"use\" that service account. Otherwise, the ability to create a GCE instance with any service account attached would be a direct path to privilege escalation if at least one other service account in the project had higher permissions. This permission can be granted on a specific service account or at the project level.  Granting the permission directly on the service account resource permits \"use\" of just that service account.  Granting the permission at the project level permits the \"use\" of any service account in the project.  Even if the project does not currently have a highly privileged service account today, it might in the future, and that would inadvertently increase the power of this binding."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud beta projects get-iam-policy PROJECTID --flatten='bindings[]' --filter=bindings.role:iam.serviceAccountUser --format=\"csv[no-heading](bindings.members[])\"` for each project and ensure no results are displayed."], ["remediation", "\nRemove the permission at the project level and instead assign \"iam.serviceAccountUser\" on the small number of service accounts in the project that are necessary."], ["refs", "[{\"text\":\"Granting IAM Roles to Service Accounts\",\"url\":\"https://cloud.google.com/iam/docs/granting-roles-to-service-accounts\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\",\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.100365"], ["id", 7]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5a21d6de-3854-514c-a2ec-23f35fcd161f"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5a21d6de-3854-514c-a2ec-23f35fcd161f"], ["created_at", "2020-10-07 21:57:56.111290"], ["updated_at", "2020-10-07 21:57:56.111290"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 8]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 8], ["created_at", "2020-10-07 21:57:56.125002"], ["updated_at", "2020-10-07 21:57:56.125002"]]
  [1m[35m (2.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTag Create (0.6ms)[0m  [1m[32mINSERT INTO "tags" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "k8s-logging"], ["created_at", "2020-10-07 21:57:56.144825"], ["updated_at", "2020-10-07 21:57:56.144825"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 8], ["created_at", "2020-10-07 21:57:56.152832"], ["updated_at", "2020-10-07 21:57:56.152832"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-15"], ["title", "Overuse of Primitive IAM Roles"], ["description", "GCP \"Primitive\" Roles of \"Project Owner\", \"Project Editor\", and \"Project Viewer\" are broad groupings of permissions that cross nearly every API in a project.  Assigning \"Project Owner\" is granting full control over that project.  Assigning \"Project Editor\" is granting read/write to nearly every resource in a project with exceptions for IAM management.  Assigning \"Project Viewer\" allows for reading nearly every resource in the project.  By their nature, they do not conform to the principle of least privilege.  Instead, binding predefined IAM Roles or creating custom IAM Roles is preferred."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud organizations get-iam-policy ORGIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/owner\" or .role==\"roles/editor\" or .role==\"roles/viewer\") | \"($role): (.members[])\"'` for the organization level.  For each folder, run `gcloud resource-manager folders get-iam-policy FOLDERIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/owner\" or .role==\"roles/editor\" or .role==\"roles/viewer\") | \"($role): (.members[])\"'`.  For each project, run `gcloud projects get-iam-policy PROJECTID --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/owner\" or .role==\"roles/editor\" or .role==\"roles/viewer\") | \"($role): (.members[])\"'` and validate that the minimum assignments necessary are present."], ["remediation", "\nUse the IAM Role recommendation information to gauge how many permissions are granted versus how many are in actual use over the past 90 days.  Consider implementing the predefined roles or custom roles it suggests and revoking the primitive role.  Considerations: At least one member of the project must have the Owner role (roles/owner). If the Owner role is revoked from all members, it might remove the ability to manage the project.  When using access controls that are separate from Cloud IAM, such as Cloud Storage access control lists (ACLs) or Kubernetes role-based access control (RBAC), make sure those access controls will work correctly after the primitive role is revoked."], ["refs", "[{\"text\":\"IAM Recommender Overview\",\"url\":\"https://cloud.google.com/iam/docs/recommender-overview\",\"ref\":\"link\"},{\"text\":\"Managing IAM Recommender\",\"url\":\"https://cloud.google.com/iam/docs/recommender-managing\",\"ref\":\"link\"},{\"text\":\"Using IAM Securely\",\"url\":\"https://cloud.google.com/iam/docs/using-iam-securely\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.159470"], ["id", 8]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7d7ec1dc-fdfb-5edd-91dd-cf09a6a8d987"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.0ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7d7ec1dc-fdfb-5edd-91dd-cf09a6a8d987"], ["created_at", "2020-10-07 21:57:56.167591"], ["updated_at", "2020-10-07 21:57:56.167591"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 9]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 9], ["created_at", "2020-10-07 21:57:56.182482"], ["updated_at", "2020-10-07 21:57:56.182482"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-18"], ["title", "Overlapping IAM Role Permissions"], ["description", "A project was found to have IAM Role assignments that fully overlap.  That is, one or more IAM Roles are assigned that have permissions fully covered by another IAM Role assigned.  This is a minor misconfiguration that should be resolved to clarify the explicit intent and aid in auditing permissions in the future."], ["platform", "gcp"], ["impact", 1], ["validation", "\nReview the permissions at the organization, folder, and project level, and look for combinations of primitive IAM Roles such as \"Project Owner\" or \"Project Editor\" assigned in combination with other custom or predefined IAM roles."], ["remediation", "\nReview the configuration of IAM permissions and consider consolidating the permissions down to the single IAM Role that encapsulates the permissions necessary to do the job role.  The most expeditious solution is to simply remove the smaller IAM Role.  A common example is a predefined role such as \"Compute Admin\" being fully encapsulated in a primitive role such as \"Project Owner\"."], ["refs", "[{\"text\":\"Using IAM Securely\",\"url\":\"https://cloud.google.com/iam/docs/using-iam-securely\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.189628"], ["id", 9]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e6504c23-cf7f-52aa-92a3-49e54ca7f332"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e6504c23-cf7f-52aa-92a3-49e54ca7f332"], ["created_at", "2020-10-07 21:57:56.199931"], ["updated_at", "2020-10-07 21:57:56.199931"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 10]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 10], ["created_at", "2020-10-07 21:57:56.211938"], ["updated_at", "2020-10-07 21:57:56.211938"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-19"], ["title", "Organization Admin assigned at the Folder or Project level"], ["description", "The predefined Organization Administrator IAM Role is meant to be assigned at the Organization level, not the Folder or Project level.  This is likely a misconfiguration.  However, it offers the `resourcemanager.projects.setIamPolicy` permission which allows modification of permissions on that Project including adding oneself or others as \"Project Owner\" and gaining full access to the Project and all resources contained inside it."], ["platform", "gcp"], ["impact", 3], ["validation", "\nFor each folder, run `gcloud resource-manager folders get-iam-policy FOLDERIDNUMBER --format=json `| jq -r 'select(.bindings) | .bindings[] | select(.role==\"roles/resourcemanager.organizationAdmin\") | .members[]'.  For each project, run `gcloud projects get-iam-policy PROJECTID --format=json | jq -r 'select(.bindings) | .bindings[] | select(.role==\"roles/resourcemanager.organizationAdmin\") | .members[]'` and validate that no entries are present."], ["remediation", "\nReview the need for Organization Administrator to be assigned at the Folder or Project level and instead grant the desired IAM Roles for those users."], ["refs", "[{\"text\":\"Organization Access Control\",\"url\":\"https://cloud.google.com/resource-manager/docs/access-control-org\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.220110"], ["id", 10]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "288c5376-739a-5da8-927d-b72a185f8439"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "288c5376-739a-5da8-927d-b72a185f8439"], ["created_at", "2020-10-07 21:57:56.229134"], ["updated_at", "2020-10-07 21:57:56.229134"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 11]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 11], ["created_at", "2020-10-07 21:57:56.242924"], ["updated_at", "2020-10-07 21:57:56.242924"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-20"], ["title", "Default Firewall Rules are present"], ["description", "The default firewalls in the default VPC permit inbound access to SSH, RDP, and ICMP from 0.0.0.0/0 and between all instances on the local subnet.  By default, GCE instances and GKE workers are created in the default subnet of the default VPC in a project and inherit this access for ease of use, but this means they are exposed via SSH or RDP to the entire Internet."], ["platform", "gcp"], ["impact", 8], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.name | test(\"^default-allow-\")) | .name' | grep -v 'default-allow-internal'` and ensure entries named `default-allow-icmp`, `default-allow-rdp`, and `default-allow-ssh` are not listed."], ["remediation", "\nDelete the default firewall rules in all projects and create new firewall rules explicitly with the principle of least privilege/access in mind."], ["refs", "[{\"text\":\"Default Firewall Rules\",\"url\":\"https://cloud.google.com/vpc/docs/firewalls#more_rules_default_vpc\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.249186"], ["id", 11]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3d56976e-3673-5c48-a501-33e0a2975038"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3d56976e-3673-5c48-a501-33e0a2975038"], ["created_at", "2020-10-07 21:57:56.262240"], ["updated_at", "2020-10-07 21:57:56.262240"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 12]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 12], ["created_at", "2020-10-07 21:57:56.276716"], ["updated_at", "2020-10-07 21:57:56.276716"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-21"], ["title", "Firewall logging should be enabled on all rules"], ["description", "Firewall rules do not enable logging of connections by default.  In regulated environments, firewall logging is a requirement in almost every situation to be able to understand when systems are accessed on certain ports or for evidence of which systems were accessed in the event of a security incident."], ["platform", "gcp"], ["impact", 9], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.logConfig.enable==false) | \"(.name)\"'` and ensure no entries are present."], ["remediation", "\nFor all TCP and UDP firewall rules, enable firewall logging on each rule.  Logs are sent automatically to Stackdriver for review for the default retention period of 30 days."], ["refs", "[{\"text\":\"Firewall Rules Logging\",\"url\":\"https://cloud.google.com/vpc/docs/firewall-rules-logging\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.CM-7\",\"DE.CM-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.302190"], ["id", 12]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8d492ba7-166e-5e64-8645-210040600af1"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8d492ba7-166e-5e64-8645-210040600af1"], ["created_at", "2020-10-07 21:57:56.312087"], ["updated_at", "2020-10-07 21:57:56.312087"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 13]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 13], ["created_at", "2020-10-07 21:57:56.323393"], ["updated_at", "2020-10-07 21:57:56.323393"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-22"], ["title", "VPC Flow logging should be enabled on all VPC Subnets"], ["description", "VPC flow logs record metadata about all traffic flowing in and out of a VPC. These logs are vital for auditing and review after security incidents to be able to create an accurate timeline of network events to go with application and Cloud API Audit logs."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute networks subnets list --format=json | jq -r '.[] | select(.logConfig.enable | not) | \"(.name) (.region)\"'` and ensure no entries are present."], ["remediation", "\nEnable VPC Flow logging on all VPCs with a 100% sample rate for production environments or those that hold sensitive data.  When directing to a GCS bucket, enable bucket versioning and optionally configure an object lifecycle policy to retain the data for the desired period only."], ["refs", "[{\"text\":\"Using VPC Flow Logs\",\"url\":\"https://cloud.google.com/vpc/docs/using-flow-logs\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.CM-7\",\"DE.CM-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.330792"], ["id", 13]]
  [1m[35m (1.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "09ca0a00-f921-54bf-ab6e-80690f9dd06d"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "09ca0a00-f921-54bf-ab6e-80690f9dd06d"], ["created_at", "2020-10-07 21:57:56.342776"], ["updated_at", "2020-10-07 21:57:56.342776"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 14]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 14], ["created_at", "2020-10-07 21:57:56.354361"], ["updated_at", "2020-10-07 21:57:56.354361"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-23"], ["title", "Firewall rules allows access to SSH TCP/22 from all hosts"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to administrative ports via SSH (TCP/22) should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 8], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"'` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `22`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires SSH access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets or to the bastion host(s) in the environment."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.361799"], ["id", 14]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.9ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39bd81b4-4925-5701-a5be-a2ee38b67166"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39bd81b4-4925-5701-a5be-a2ee38b67166"], ["created_at", "2020-10-07 21:57:56.372612"], ["updated_at", "2020-10-07 21:57:56.372612"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 15]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 15], ["created_at", "2020-10-07 21:57:56.385269"], ["updated_at", "2020-10-07 21:57:56.385269"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 15], ["created_at", "2020-10-07 21:57:56.394563"], ["updated_at", "2020-10-07 21:57:56.394563"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-24"], ["title", "Default deny egress rules should be configured"], ["description", "There are no egress firewall rules in place, so the implicit egress \"allow all\" firewall policy is in effect.  This allows any GCP resource to connect to any external destination on any port or protocol.  While this default configuration provides ease of use, it offers no protection for exfiltration of data, lateral movement, or network pivoting in the event of a compromise."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.destinationRanges) | select(.denied) | select(.direction==\"EGRESS\") | select(.destinationRanges[] | contains(\"0.0.0.0/0\")) | select(.denied[].IPProtocol==\"all\") | \"(.name)\"'` and ensure that an entry is present."], ["remediation", "\nConfigure an explicit deny egress firewall rule in each VPC of priority 65535, and configure explicit egress firewall rules that allow external access on the specific ports to specific destinations as needed.  When combined with firewall logging, this has the added benefit of detecting when applications are misconfigured or when potentially malicious activity is attempting to use non-approved ports."], ["refs", "[{\"text\":\"Default GCP Firewall Rules\",\"url\":\"https://cloud.google.com/vpc/docs/firewalls#default_firewall_rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.DS-5\",\"DE.AE-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.401603"], ["id", 15]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "27d34b2a-4b21-5a95-9707-30c32ade1045"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "27d34b2a-4b21-5a95-9707-30c32ade1045"], ["created_at", "2020-10-07 21:57:56.412314"], ["updated_at", "2020-10-07 21:57:56.412314"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 16]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 16], ["created_at", "2020-10-07 21:57:56.422360"], ["updated_at", "2020-10-07 21:57:56.422360"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-25"], ["title", "GCE Instances have public IPs"], ["description", "GCE Instances should not have public IP addresses assigned directly to them, and should be administered using their private IP and services running on them exposed only via load balancers.  This reduces the scope of attacks against vulnerable services and affords additional protection against denial-of-service."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud compute instances list --format=json | jq -r '.[] | . as $instance | .networkInterfaces[] | select(.accessConfigs) | .accessConfigs[] | select(.type==\"ONE_TO_ONE_NAT\") | \"($instance.name): (.natIP)\"'` and ensure that no entries with public IPs exist."], ["remediation", "\nConfigure all GCE Instances to not have public IP addresses assigned.  In GKE, enable private nodes.  For services running on these systems that should be exposed externally, configure a load balancer.  For remote administration, consider using the Identity-Aware Proxy service to create an SSH or RDP-over-TLS tunnel directly to the private IP of the instance."], ["refs", "[{\"text\":\"IAP Proxy for GCE\",\"url\":\"https://cloud.google.com/iap/docs/enabling-compute-howto\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.428783"], ["id", 16]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (1.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9352728c-93c6-55ee-a072-8c3132241cf9"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9352728c-93c6-55ee-a072-8c3132241cf9"], ["created_at", "2020-10-07 21:57:56.441187"], ["updated_at", "2020-10-07 21:57:56.441187"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 17]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 17], ["created_at", "2020-10-07 21:57:56.455694"], ["updated_at", "2020-10-07 21:57:56.455694"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-26"], ["title", "Default networks are present"], ["description", "Each project contains a default VPC/Network with default subnets in every region for ease of use, but the IP ranges used are likely not desired and may overlap between different projects.  This may cause issues in the future if VPC Peering is desired as the subnets will conflict and prevent routing."], ["platform", "gcp"], ["impact", 2], ["validation", "\nIn each project, run `gcloud compute networks list --format=json | jq -r 'select(.[]) | .[] | select(.name==\"default\") | .name'` and ensure no entries are listed."], ["remediation", "\nDelete the default VPC/Network and subnets in each project and instead create a new VPC and subnets according to the networking and IP address management needs of the organization to avoid overlap.  To ensure all projects created do not have the default VPC/Network and subnets created automatically, configure the constraints/compute.skipDefaultNetworkCreation organization policy at the organization node."], ["refs", "[{\"text\":\"Default VPC Network\",\"url\":\"https://cloud.google.com/vpc/docs/vpc#default-network\",\"ref\":\"link\"},{\"text\":\"Organization Policies\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/org-policy-constraints\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-3\",\"PR.AC-5\",\"PR.DS-7\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.463775"], ["id", 17]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1cc2e0e7-6dc9-5c4f-959e-3e60addad801"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1cc2e0e7-6dc9-5c4f-959e-3e60addad801"], ["created_at", "2020-10-07 21:57:56.474429"], ["updated_at", "2020-10-07 21:57:56.474429"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 18]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 18], ["created_at", "2020-10-07 21:57:56.486534"], ["updated_at", "2020-10-07 21:57:56.486534"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-27"], ["title", "User-managed GCP Service Account Keys older than 90 days"], ["description", "GCP Service Account Keys that are created by an administrator are known as \"user-managed\" keys.  Unless rotated by the user, they are static for their lifetime.  They should be rotated on a frequent basis to limit their active lifetime in the event the key material is compromised."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=ORGIDNUMBER --format=\"value(projectId)\"); do for sa in $(gcloud iam service-accounts list --format=\"value(email)\" --project=$project); do gcloud iam service-accounts keys list --iam-account $sa --project=$project --format=json | jq -r '.[] | select(.keyType==\"USER_MANAGED\") | \"(.name): (.validAfterTime) (.validBeforeTime)\"'; done; done` and review the validAfterTime and validBeforeTime values for each key to ensure they are not valid for longer than 90 days."], ["remediation", "\nGCP Service Accounts have native, dynamic key integrations to services like GCE, GKE, AppEngine, Cloud Functions, and more such that exporting a static key is only necessary for integrations from non-GCP services like Splunk, Sumologic, Datadog, etc that need access to GCP resources from outside the organization.  This removes the need for exporting keys for all but a small number of clearly defined use cases for those types of integrations.  Refactor GCP applications using static, exported service account keys to use the native integration.  For keys used by external services, rotate them every 90 days."], ["refs", "[{\"text\":\"Managing Service Account Keys\",\"url\":\"https://cloud.google.com/iam/docs/creating-managing-service-account-keys\",\"ref\":\"link\"},{\"text\":\"Security Health Analytics\",\"url\":\"https://cloud.google.com/security-command-center/docs/how-to-manage-security-health-analytics\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-3\",\"PR.AC-6\",\"PR.AC-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.493190"], ["id", 18]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f657ccb7-f778-5c52-9d83-a691e190e289"], ["LIMIT", 1]]
  [1m[35m (0.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f657ccb7-f778-5c52-9d83-a691e190e289"], ["created_at", "2020-10-07 21:57:56.502790"], ["updated_at", "2020-10-07 21:57:56.502790"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 19]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 19], ["created_at", "2020-10-07 21:57:56.516850"], ["updated_at", "2020-10-07 21:57:56.516850"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 19], ["created_at", "2020-10-07 21:57:56.527355"], ["updated_at", "2020-10-07 21:57:56.527355"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-28"], ["title", "GCP Projects should enable data access logging"], ["description", "GCP Audit logs automatically capture administrative activity logs for any creation or modification of resources via the GCP API.  e.g. \"create GCE instance\" or \"delete GCS bucket\".  By default, read requests to get/list resources and read/write requests that access user-provided data are not logged.  e.g. \"get or delete an object in a GCS bucket\".  These logs can and should be enabled on non-development projects to enable full capture of API activity necessary to support incident analysis and for meeting certain regulatory compliance requirements."], ["platform", "gcp"], ["impact", 8], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=ORGIDNUMBER --format=\"value(projectId)\"); do gcloud projects get-iam-policy $project --format=json | jq -r 'select(.auditConfigs)'; done` and ensure that it returns the following: `[\n      {\n        \"service\": \"allServices\",\n        \"auditLogConfigs\": [\n          { \"logType\": \"ADMIN_READ\" },\n          { \"logType\": \"DATA_READ\"  },\n          { \"logType\": \"DATA_WRITE\" },\n        ]\n      },\n    ]`."], ["remediation", "\nEnable \"Admin READ\" and \"Data READ and WRITE\" access logging for \"allServices\" at the organization level so that it applies to all downstream folders and projects.  Configure Stackdriver to export audit logs to a storage medium such as a GCS bucket and configure a lifecycle and retention policy to automatically move data to cheaper storage and to prune old data.  Caveat: Audit logs are often verbose and generate large volumes of log entries, and storing these in GCS buckets incurs an additional cost.  Use the exemption configuration to remove GCP internal service audit logs if necessary."], ["refs", "[{\"text\":\"Project Audit Logs\",\"url\":\"https://cloud.google.com/logging/docs/audit/understanding-audit-logs\",\"ref\":\"link\"},{\"text\":\"Configuring Data Access Logs\",\"url\":\"https://cloud.google.com/logging/docs/audit/configure-data-access\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.534251"], ["id", 19]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d2a48599-29d1-5e8a-a9e4-fb1fb35cfa75"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d2a48599-29d1-5e8a-a9e4-fb1fb35cfa75"], ["created_at", "2020-10-07 21:57:56.544809"], ["updated_at", "2020-10-07 21:57:56.544809"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 20]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 20], ["created_at", "2020-10-07 21:57:56.554882"], ["updated_at", "2020-10-07 21:57:56.554882"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-29"], ["title", "Cloud Security Command Center should be enabled"], ["description", "Security Command Center helps security teams gather data, identify threats, and act on them before they result in business damage or loss. It offers deep insight into application and data risk so that organizations can quickly mitigate threats to your their resources across and evaluate overall health. Security Command Center provides a single, centralized dashboard to:  - View and monitor an inventory of your cloud assets. - Scan storage systems for sensitive data. - Detect common web vulnerabilities and anomalous behavior. - Review access rights to your critical resources in your organization. - Apply recommended remediations to resolve vulnerabilities."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=ORGIDNUMBER --format=\"value(projectId)\"); do gcloud services list --project=$project | grep securitycenter; done` and ensure at least one entry is returned."], ["remediation", "\nLogged into GCP with roles/resourcemanager.organizationAdmin and roles/securitycenter.admin permissions, navigate to Security > Security Command Center in the UI and follow the prompts for enabling the service for all current and future projects.  Also, click on \"Security Health Analytics\" in the Dashboard and enable it.  Finally, navigate to Security > Threat Detection and enable Event Threat Detection to be able to receive events in Cloud Security Command Center."], ["refs", "[{\"text\":\"Cloud Security Command Center Quickstart\",\"url\":\"https://cloud.google.com/security-command-center/docs/quickstart-scc-setup\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.AM-5\",\"ID.GV-1\",\"ID.RA-1\",\"ID.RA-2\",\"ID.RA-3\",\"ID.RA-4\",\"ID.RA-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.561254"], ["id", 20]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5344a9bb-7f90-5b64-a466-111c6c59f09d"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5344a9bb-7f90-5b64-a466-111c6c59f09d"], ["created_at", "2020-10-07 21:57:56.572833"], ["updated_at", "2020-10-07 21:57:56.572833"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 21]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 21], ["created_at", "2020-10-07 21:57:56.584509"], ["updated_at", "2020-10-07 21:57:56.584509"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-30"], ["title", "CloudSQL Instances should have a private IP address"], ["description", "By default, CloudSQL instances are assigned a public IPv4 address, and the access list allows any source IP address to attempt to connect and authenticate to the database.  This facilitates development and ease of connectivity for troubleshooting, but it means an attacker can access the potentially sensitive data in the database without restriction if they obtain valid credentials."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.ipConfiguration.ipv4Enabled==true) | \"(.name) Public IP: (.settings.ipConfiguration.ipv4Enabled)\"'` and ensure no entries are listed."], ["remediation", "\nTo reduce the likelihood of an attacker to access the database service directly or to use stolen credentials from any source IP, the instance should be configured with a private IP address only. This should be configured during creation of the instance and a VPC peering relationship should be configured between the CloudSQL VPC and the VPCs where applications accessing the database reside."], ["refs", "[{\"text\":\"CloudSQL MySQL Private IP\",\"url\":\"https://cloud.google.com/sql/docs/mysql/configure-private-services-access\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Private IP\",\"url\":\"https://cloud.google.com/sql/docs/postgres/configure-private-services-access\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Private IP\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/configure-private-services-access\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-3\",\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.605016"], ["id", 21]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f033a7cd-69ce-53d9-8ca7-74579eb07a70"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f033a7cd-69ce-53d9-8ca7-74579eb07a70"], ["created_at", "2020-10-07 21:57:56.619428"], ["updated_at", "2020-10-07 21:57:56.619428"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 22]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 22], ["created_at", "2020-10-07 21:57:56.630212"], ["updated_at", "2020-10-07 21:57:56.630212"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-31"], ["title", "CloudSQL Instances should require SSL/TLS"], ["description", "By default, CloudSQL instances will accept both SSL/TLS and plaintext database connections.  As CloudSQL instances are provisioned inside a separate VPC within GCP that the user does not control, this means that database traffic will traverse a VPC peering connection without in-transit encryption.  Requiring SSL/TLS connections ensures that all connections are encrypted over the wire."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.ipConfiguration.requireSsl==null) | \"(.name) SSL: (.settings.ipConfiguration.requireSsl)\"'` and ensure no entries are listed."], ["remediation", "\nConfigure the instance during creation or while running to `require-ssl`.  For example, `gcloud sql instances patch [INSTANCE_NAME] --require-ssl`.  To allow applications to connect securely without changing application code, the cloudsql-proxy can be used.  It can handle setting up a localhost SSL proxy/tunnel and applications can be configured to connect to the database via that tunnel."], ["refs", "[{\"text\":\"CloudSQL MySQL Require SSL/TLS\",\"url\":\"https://cloud.google.com/sql/docs/mysql/configure-ssl-instance\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Require SSL/TLS\",\"url\":\"https://cloud.google.com/sql/docs/postgres/configure-ssl-instance\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Require SSL/TLS\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/configure-ssl-instance\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-7\",\"PR.DS-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.636542"], ["id", 22]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "6581aa85-27d2-5f66-95f5-b4f1f6b8a68f"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "6581aa85-27d2-5f66-95f5-b4f1f6b8a68f"], ["created_at", "2020-10-07 21:57:56.647714"], ["updated_at", "2020-10-07 21:57:56.647714"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 23]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 23], ["created_at", "2020-10-07 21:57:56.659954"], ["updated_at", "2020-10-07 21:57:56.659954"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-32"], ["title", "Firewalls ingress to TCP/3306 from 0.0.0.0/0"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to database ports via TCP/3306 should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `3306`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires Database access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets where the applications and administrative systems reside."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.667271"], ["id", 23]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "647dfcff-8bf4-5215-94e1-765d9da48454"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "647dfcff-8bf4-5215-94e1-765d9da48454"], ["created_at", "2020-10-07 21:57:56.678217"], ["updated_at", "2020-10-07 21:57:56.678217"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 24]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 24], ["created_at", "2020-10-07 21:57:56.688233"], ["updated_at", "2020-10-07 21:57:56.688233"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-33"], ["title", "Firewalls ingress to TCP/5432 from 0.0.0.0/0"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to database ports via TCP/5432 should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `5432`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires Database access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets where the applications and administrative systems reside."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.694410"], ["id", 24]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1dd1167e-7787-53b9-b32b-aa3cbfc49a11"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1dd1167e-7787-53b9-b32b-aa3cbfc49a11"], ["created_at", "2020-10-07 21:57:56.702500"], ["updated_at", "2020-10-07 21:57:56.702500"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 25]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 25], ["created_at", "2020-10-07 21:57:56.715551"], ["updated_at", "2020-10-07 21:57:56.715551"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-34"], ["title", "Firewalls ingress to TCP/3389 from 0.0.0.0/0"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to database ports via RDP (TCP/3389) should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `3389`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires Remote Desktop access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets or to the bastion host(s) in the environment."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.722297"], ["id", 25]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e738902b-746f-579b-981c-d36a054bf19f"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e738902b-746f-579b-981c-d36a054bf19f"], ["created_at", "2020-10-07 21:57:56.731494"], ["updated_at", "2020-10-07 21:57:56.731494"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 26]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 26], ["created_at", "2020-10-07 21:57:56.745928"], ["updated_at", "2020-10-07 21:57:56.745928"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-36"], ["title", "GCP usage within 30% of project quota limit"], ["description", "The GCP service enforces several quotas on all GCP projects to protect both service availability and the customer.  Without quotas, a compromised account would offer \"unlimited\" resources to mine bitcoin, or a single customer could attempt to exhaust all available resources of a given service type.  Quotas on Instance counts, Virtual CPUs, and Persistent Disks are commonly known, but there are several quotas that can easily catch users by surprise when attempting even modest scale-up activities.  As the process for increasing quota limits can take 1-3 days, it's best to request these increases well ahead of the need to prevent self-inflicted capacity based outages."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=1071234196403 --format=\"value(projectId)\"); do gcloud compute project-info describe --project $project --format=json | jq -r '.quotas[] | \"(.metric): (.usage) (.limit)\"'; done` and `gcloud compute regions list --format=json | jq -r '.[] | .name as $name | .quotas[] | \"($name) (.metric): (.usage) (.limit)\"'`.  Ensure that usage does not exceed 70% of the limit value for all quotas."], ["remediation", "\nReview the project-level and per-region quotas for all critical GCP projects on a routine basis.  For quotas that are within 30-50% of total capacity, evaluate the need for increasing those limits and use the GCP console to request them as needed."], ["refs", "[{\"text\":\"Managing GCP Quotas\",\"url\":\"https://cloud.google.com/compute/quotas\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"ID.AM-5\",\"ID.RA-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.752344"], ["id", 26]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7befc99c-0695-574a-b10a-af5c538a2171"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7befc99c-0695-574a-b10a-af5c538a2171"], ["created_at", "2020-10-07 21:57:56.760475"], ["updated_at", "2020-10-07 21:57:56.760475"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 27]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 27], ["created_at", "2020-10-07 21:57:56.771769"], ["updated_at", "2020-10-07 21:57:56.771769"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-39"], ["title", "Exported GCP Service Account Keys in use inside GCP/GKE resources"], ["description", "When application code needs to interact with the GCP APIs, it needs an identity and credentials.  The creation of a GCP Service Account represents the identity, and a GCP-managed keypair associated with that Service Account serves as the credentials used to generate session tokens needed during API interaction.  For applications that reside outside GCP, users can generate and export up to ten new Service Account Keys for a single Service Account.  These exported keys are then \"user-managed\" in that they don't expire or require any additional information to be used to authenticate as that Service Account using GCP APIs.  Until recently, it was common practice to manually export a Service Account Key in a JSON-file format and store that inside a GKE/Kubernetes Secret to support Pods having GCP API access.  However, these keys require manual rotation and replacement, and this makes automatic key rotation for compliance reasons or following a security incident extremely difficult."], ["platform", "gcp"], ["impact", 5], ["validation", "\nReview the presence of, age, and expiration of all user-managed/exported Service Account Keys in the account.  Ensure the description of the Service Account and/or Key provides an indication of where it is being used.  If GCP Organization Policies are enforcing, ensure the `iam.disableServiceAccountKeyCreation` control is applied to all but a small approved list of Folders and Projects."], ["remediation", "\nPeriodically review all Service Account Keys associated with Service Accounts, and ensure their usage is only in limited situations where there is no other option.  For GCE, attaching the Service Account to the instance is the preferred method as the credentials are short-lived and automatically rotated every hour.  For Pods in GKE, use the Workload Identity feature to map GKE/Kubernetes Service Accounts to GCP Service Accounts via IAM mapping and get similar behavior to the GCE instance metadata approach.  To prevent keys from being generated, consider enforcing the `iam.disableServiceAccountKeyCreation` GCP Organization Policy on all Folders/Projects that do not hold IAM responsibilities for external application authentication."], ["refs", "[{\"text\":\"GCP Service Accounts\",\"url\":\"https://cloud.google.com/iam/docs/understanding-service-accounts\",\"ref\":\"link\"},{\"text\":\"GCP Service Account Keys\",\"url\":\"https://cloud.google.com/iam/docs/creating-managing-service-account-keys\",\"ref\":\"link\"},{\"text\":\"GCP Organization Policy\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/restricting-service-accounts#disable_service_account_key_creation\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.780662"], ["id", 27]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9a58ed98-e24a-5f2a-a420-0b445ddb376d"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9a58ed98-e24a-5f2a-a420-0b445ddb376d"], ["created_at", "2020-10-07 21:57:56.789587"], ["updated_at", "2020-10-07 21:57:56.789587"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 28]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 28], ["created_at", "2020-10-07 21:57:56.799995"], ["updated_at", "2020-10-07 21:57:56.799995"]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-40"], ["title", "Shared VPC projects contain non VPC related resources"], ["description", "GCP Projects that contain VPCs to be \"shared\" with other GCP Projects are also known as \"Host\" Projects, and the GCP Projects that are associated with the Host Projects are known as \"Resource\" Projects.  This approach maintains the networking configuration centrally with dedicated IAM permissions, and the ability to \"use\" the network is granted to each Service Project which is typically owned by other teams in the organization who own the instances and clusters.  Where possible, the Shared VPC project should retain its single purpose configuration and not hold resources unrelated to the VPC networking, routing, and firewall settings.  Resources outside of those purposes should be held in one or more Service Projects instead to maintain cleaner ownership and permissions isolation."], ["platform", "gcp"], ["impact", 3], ["validation", "\nReview all Host Projects and validate that no GCE instances, GKE clusters, GCS buckets, etc exist and that IAM permissions for the Project are only network-focused."], ["remediation", "\nIf resources exist in the Shared VPC project that are not networking related, they should be migrated to a dedicated Service Project.  Permissions to manage the VPC resources in the Shared VPC Project should be carefully reviewed to ensure they only grant access to perform network configuration tasks."], ["refs", "[{\"text\":\"GCP Shared VPCs\",\"url\":\"https://cloud.google.com/vpc/docs/shared-vpc\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.PT-4\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.809523"], ["id", 28]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "cb1f71c5-e10d-5e0e-9057-4b794d1cd588"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "cb1f71c5-e10d-5e0e-9057-4b794d1cd588"], ["created_at", "2020-10-07 21:57:56.818336"], ["updated_at", "2020-10-07 21:57:56.818336"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 29]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 29], ["created_at", "2020-10-07 21:57:56.829948"], ["updated_at", "2020-10-07 21:57:56.829948"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-41"], ["title", "Load Balancers should use a MODERN or RESTRICTED SSL policy"], ["description", "By default, Load Balancers use an SSL/TLS policy equivalent to the COMPATIBLE profile which supports a wide range of ciphers and TLS versions of varying security.  In nearly all use cases, the more stringent profiles should be used to ensure client connections only negotiate with strong ciphers and recent TLS versions.  For compliance-focused environments, the RESTRICTED policy should be used."], ["platform", "gcp"], ["impact", 3], ["validation", "\nRun `gcloud compute target-https-proxies list --format=json | jq -r '.[] | select(.sslPolicy | not) | \"(.name) (.selfLink)\"'` and `gcloud compute target-ssl-proxies list --format=json | jq -r '.[] | select(.sslPolicy | not) | \"(.name) (.selfLink)\"'` and ensure they do not return any entries."], ["remediation", "\nConfigure all Load Balancers to leverage the MODERN or RESTRICTED SSL policy or a CUSTOM SSL policy with equivalent enforcement of secure ciphers and TLS versions."], ["refs", "[{\"text\":\"GCP SSL Policies\",\"url\":\"https://cloud.google.com/load-balancing/docs/ssl-policies-concepts\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-2\",\"PR.PT-4\",\"PR.AC-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.836343"], ["id", 29]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0089ced9-0d18-552a-88de-b5d77c179e2d"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0089ced9-0d18-552a-88de-b5d77c179e2d"], ["created_at", "2020-10-07 21:57:56.848125"], ["updated_at", "2020-10-07 21:57:56.848125"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 30]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 30], ["created_at", "2020-10-07 21:57:56.859233"], ["updated_at", "2020-10-07 21:57:56.859233"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-42"], ["title", "Firewall rules allows all ports from all hosts"], ["description", "Firewall rules that allow all ports from any CIDR range are effectively disabling firewall protection to the attached service or system."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"'` and ensure no entries that permit `IPProtocol` of `all`."], ["remediation", "\nFor each firewall rule, review the application needs for protocols and ports, and reconfigure the firewall rule(s) to only grant access to those."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.879005"], ["id", 30]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2f3f76ca-7048-5b40-97a1-350869c51f0c"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2f3f76ca-7048-5b40-97a1-350869c51f0c"], ["created_at", "2020-10-07 21:57:56.895435"], ["updated_at", "2020-10-07 21:57:56.895435"]]
  [1m[35m (2.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 31]]
  [1m[36mTag Load (5.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.9ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 31], ["created_at", "2020-10-07 21:57:56.939866"], ["updated_at", "2020-10-07 21:57:56.939866"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-43"], ["title", "GCS Bucket Logging should be enabled"], ["description", "GCS bucket logging helps maintain an audit trail of access that can be used in the event of a security incident.  Bucket logging is disabled by default, so any unauthorized access will go untraced unless this is explicitly enabled."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `for bucket in $(gsutil ls); do gsutil logging get $bucket; done | grep \"has no logging\"` and validate that no entries are present."], ["remediation", "\nEnable data access audit logs on all storage buckets that store data that requires auditable logging."], ["refs", "[{\"text\":\"GCS Audit Logs\",\"url\":\"https://cloud.google.com/storage/docs/audit-logs\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:56.949605"], ["id", 31]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9082de43-725d-5562-90a9-8204a5aba5c4"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.0ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9082de43-725d-5562-90a9-8204a5aba5c4"], ["created_at", "2020-10-07 21:57:56.962403"], ["updated_at", "2020-10-07 21:57:56.962403"]]
  [1m[35m (2.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (2.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 32]]
  [1m[36mTag Load (1.9ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (1.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 32], ["created_at", "2020-10-07 21:57:56.987315"], ["updated_at", "2020-10-07 21:57:56.987315"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-44"], ["title", "GCS Buckets without object versioning enabled"], ["description", "GCS Buckets that store sensitive data should have object versioning enabled to help protect against the overwriting of objects or data loss in the event of a compromise.  A concrete example is a bucket that receives audit/access logs from other services.  Without object versioning, an attacker might be able to delete evidence of their activities.  With object versioning enabled, they won't be able to remove the original version of the log data."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `for bucket in $(gsutil ls); do gsutil versioning get $bucket; done | grep \"Suspended\"` and validate that no entries are present."], ["remediation", "\nEnable object versioning on all storage buckets that store data that requires integrity protection."], ["refs", "[{\"text\":\"GCS Object Versioning\",\"url\":\"https://cloud.google.com/storage/docs/object-versioning\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.005783"], ["id", 32]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8f62fb14-a782-5888-b0cb-3d5ee30b4bdd"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8f62fb14-a782-5888-b0cb-3d5ee30b4bdd"], ["created_at", "2020-10-07 21:57:57.017330"], ["updated_at", "2020-10-07 21:57:57.017330"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 33]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 33], ["created_at", "2020-10-07 21:57:57.029502"], ["updated_at", "2020-10-07 21:57:57.029502"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-45"], ["title", "Predefined GKE IAM Roles should be avoided"], ["description", "Access to the GKE Cluster API Server resources is controlled by a combination of IAM and in-cluster RBAC permissions.  If either grants access to the resource, access is allowed.  When using IAM permissions, access is granted to the permitted resources in all namespaces.  Using RBAC policies allows for granting more granular access to resources on a cluster-wide or per-namespace level and follows the principle of least privilege.  In this case, only IAM permissions are being used for allowing access via the \"Project Owner\" IAM Role, and this effectively grants full access to all resources in the cluster and \"root\" access to all GKE worker nodes."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud organizations get-iam-policy ORGIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/container.admin\" or .role==\"roles/container.developer\" or .role==\"roles/container.viewer\") | \"($role): (.members[])\"'` for the organization level.  For each folder, run `gcloud resource-manager folders get-iam-policy FOLDERIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/container.admin\" or .role==\"roles/container.developer\" or .role==\"roles/container.viewer\") | \"($role): (.members[])\"'`.  For each project, run `gcloud projects get-iam-policy PROJECTID --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/container.admin\" or .role==\"roles/container.developer\" or .role==\"roles/container.viewer\") | \"($role): (.members[])\"'` and validate that the minimum assignments necessary are present."], ["remediation", "\nThe recommended approach is to avoid using IAM permissions to grant access to GKE clusters with one exception: a custom IAM Role that only permits cluster users with the ability to download a kubeconfig file via the \"gcloud container clusters get-credentials\" API call.  All Kubernetes access should be granted inside the cluster using RBAC ClusterRoleBindings or per-namespace RoleBindings.  Create a custom IAM Role call \"Kubernetes API Access\" with the following permissions: - container.apiServices.get - container.apiServices.list - container.clusters.get - container.clusters.getCredentials  Create a security group with all members that need cluster access, and bind the \"Kubernetes API Access\" IAM Role to that group at the project where the cluster lives.  For each administrator, create a ClusterRoleBinding that grants that user the \"Cluster Admin\" ClusterRole.  For each developer/CI system, create a RoleBinding that grants that user the Role they need in the namespace(s) they need access to that are not kube-system.  This is commonly the \"admin\" ClusterRole bound to the namespace to delegate them full control over that namespace."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control\",\"ref\":\"Kubernetes RBAC\"},{\"text\":\"GKE Multi-tenancy\",\"url\":\"https://speakerdeck.com/alp/multi-tenancy-best-practices-for-google-kubernetes-engine?slide=3\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.039421"], ["id", 33]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "50399e71-32dc-569b-bcd1-d63fa0a39a85"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "50399e71-32dc-569b-bcd1-d63fa0a39a85"], ["created_at", "2020-10-07 21:57:57.054511"], ["updated_at", "2020-10-07 21:57:57.054511"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 34]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 34], ["created_at", "2020-10-07 21:57:57.068757"], ["updated_at", "2020-10-07 21:57:57.068757"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 34], ["created_at", "2020-10-07 21:57:57.080446"], ["updated_at", "2020-10-07 21:57:57.080446"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-46"], ["title", "GKE Network Policy support should be installed"], ["description", "By default in Kubernetes, all Pods can communicate with each other by IP and egress to any subnet (including the Internet) unless routing or firewalls are added to prevent that traffic.  This presents ample opportunity for lateral movement from the perspective of a compromised workload. One of the best ways to reduce the scope of that movement is to deploy NetworkPolicy resources that define firewall rules for pod-to-pod traffic.  In GKE, the Network Policy add-on must be enabled to allow for the cluster to enforce firewall policies on Pods."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.networkPolicy.enabled==true and .networkPolicy.provider==\"CALICO\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the cluster to enabled Network Policy support to allow for in-cluster support for NetworkPolicy (firewall rules) resources."], ["refs", "[{\"text\":\"Kubernetes Network Policy\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#restrict_with_network_policy\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.096531"], ["id", 34]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9eb1bf9e-1214-510e-9675-397a7ffd52fb"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9eb1bf9e-1214-510e-9675-397a7ffd52fb"], ["created_at", "2020-10-07 21:57:57.111719"], ["updated_at", "2020-10-07 21:57:57.111719"]]
  [1m[35m (1.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 35]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 35], ["created_at", "2020-10-07 21:57:57.130009"], ["updated_at", "2020-10-07 21:57:57.130009"]]
  [1m[35m (3.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-47"], ["title", "GKE Control Plane IPs should be restricted to a known set of IP ranges"], ["description", "The Kubernetes API Server systems (Control Plane) expose the Kubernetes API Server TLS port publicly without an IP restrictions or limitations.  This provides convenient remote administrative access, but it affords only a single layer of defense in front of the Kubernetes cluster and all applications and data inside.  A pre-authentication or denial-of-service vulnerability could compromise or disrupt the cluster completely.  Several pre-authentication denial-of-service vulnerabilities have been discovered and fixed in recent Kubernetes releases."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.masterAuthorizedNetworksConfig.enabled==true) | select(.masterAuthorizedNetworksConfig.cidrBlocks[].cidrBlock!=\"0.0.0.0/0\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the master authorized networks on the GKE cluster to be restricted to a known set of IP ranges for API Server access.  In environments with bastion hosts or VPNs, their internal subnet range or security groups are commonly used."], ["refs", "[{\"text\":\"Billion Laughs Attack\",\"url\":\"https://www.stackrox.com/post/2019/09/protecting-kubernetes-api-against-cve-2019-11253-billion-laughs-attack/\",\"ref\":\"link\"},{\"text\":\"Billion Laughs PoC\",\"url\":\"https://gist.github.com/bgeesaman/0e0349e94cd22c48bf14d8a9b7d6b8f2\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.PT-3\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.145256"], ["id", 35]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "6506294c-7084-5b9a-a0c5-a94b5fca6082"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "6506294c-7084-5b9a-a0c5-a94b5fca6082"], ["created_at", "2020-10-07 21:57:57.157156"], ["updated_at", "2020-10-07 21:57:57.157156"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 36]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (1.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 36], ["created_at", "2020-10-07 21:57:57.169386"], ["updated_at", "2020-10-07 21:57:57.169386"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-48"], ["title", "GKE Workload Identity should be enabled and enforcing metadata protection on all NodePools"], ["description", "Currently, all pods have the ability to reach the Instance Metadata API corresponding to the underlying node.  By extension, those pods can access the APIs and data used to bootstrap the Kubernetes worker node.  The credentials used to bootstrap a Kubernetes worker node are very commonly sufficient to be used to privilege escalate to \"cluster-admin\".  Also by extension, this means that every container image ever run in this cluster in the non-\"prod\" namespace has had the ability to reach and export these credentials.  Therefore, it's very important for a cluster's security posture to prevent pods from being able to reach the Instance Metadata API to fetch those bootstrapping credentials."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.workloadIdentityConfig.workloadPool | test(\"svc.id.goog\")) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure Workload Identity on the cluster and every node pool in the cluster with the GKE_METADATA setting enabled.  Alternatively, deploy an egress NetworkPolicy blocking egress to 169.254.169.254 for all non-kube-system namespaces."], ["refs", "[{\"text\":\"GKE Workload Identity\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity\",\"ref\":\"link\"},{\"text\":\"Hardening GKE\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#workload_identity\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\",\"PR.AC-5\",\"PR.AC-6\",\"PR.AC-7\",\"PR.DS-2\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.180590"], ["id", 36]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "896263b0-7ac0-54db-a3c3-620c97edfd50"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "896263b0-7ac0-54db-a3c3-620c97edfd50"], ["created_at", "2020-10-07 21:57:57.190371"], ["updated_at", "2020-10-07 21:57:57.190371"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 37]]
  [1m[36mTag Load (1.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 37], ["created_at", "2020-10-07 21:57:57.210535"], ["updated_at", "2020-10-07 21:57:57.210535"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 37], ["created_at", "2020-10-07 21:57:57.222184"], ["updated_at", "2020-10-07 21:57:57.222184"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-49"], ["title", "GKE Node pools should use dedicated GCP ServiceAccounts"], ["description", "By default, GKE associates the \"default\" compute service account to GKE worker nodes, and it is automatically granted the \"Project Editor\" IAM Role.  To avoid using an inherently shared service account with over-provisioned permissions, create a dedicated service account for each GKE cluster in each project and grant it only the minimal IAM permissions needed."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.serviceAccount | test(\"-compute@developer.gserviceaccount.com\") | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nCreate a dedicated GCP service account for each cluster in each project. Create a custom IAM Role with the \"monitoring.viewer\", \"monitoring.metricWriter\", and \"logging.logWriter\" permissions, and associate that with the dedicated GCP service account.  Ensure the OAuth Scopes attached to the nodes are:\n\n* https://www.googleapis.com/auth/devstorage.read_only\n* https://www.googleapis.com/auth/logging.write\n* https://www.googleapis.com/auth/monitoring\n* https://www.googleapis.com/auth/servicecontrol\n* https://www.googleapis.com/auth/service.management.readonly\n* https://www.googleapis.com/auth/trace.append\n\nConsideration: Changing the service account or the OAuth Scopes will result in a rolling redeployment of the Node Pool."], ["refs", "[{\"text\":\"GKE NodePool OAuth Scopes\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#use_least_privilege_sa\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-6\",\"PR.IP-1\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.230381"], ["id", 37]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c0247bd6-3f66-5a6a-b867-817bff7dc370"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c0247bd6-3f66-5a6a-b867-817bff7dc370"], ["created_at", "2020-10-07 21:57:57.243820"], ["updated_at", "2020-10-07 21:57:57.243820"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 38]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 38], ["created_at", "2020-10-07 21:57:57.257825"], ["updated_at", "2020-10-07 21:57:57.257825"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-50"], ["title", "GKE Node pools should use Shielded GKE Nodes"], ["description", "Starting in GKE 1.13.6 and later, GKE Worker nodes can be provisioned with a Virtual Trusted Platform Module (vTPM) that can be used to cryptographically verify the integrity of the boot process and to securely distribute the bootstrapping credentials used by the Kubelet to attach the node to the cluster on first boot.  Without this feature, the Kubelet's bootstrapping credentials are available via the GCE Metadata API, and that can be accessed by any Pod unless additional protections are put in place.  These credentials can be leveraged to escalate to cluster-admin in most situations."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.shieldedInstanceConfig.enableIntegrityMonitoring==true and .nodePools[].config.shieldedInstanceConfig.enableSecureBoot==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nModify the cluster node pool configuration to enable shielded nodes (--enable-shielded-nodes) and secure boot (--shielded-secure-boot).  This will remove the sensitive bootstrapping credentials from the GCE Metadata API and enable additional verification checks to ensure the worker nodes have not been compromised at a fundamental level.  Considerations: The nodes must be running the COS or COS_CONTAINERD operating system, and enabling this change will require a node pool rolling redeployment performed at the next maintenance window."], ["refs", "[{\"text\":\"GKE Hardening\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#shielded_nodes\",\"ref\":\"link\"},{\"text\":\"GKE Shielded Nodes\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/shielded-gke-node\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-6\",\"PR.DS-8\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.265266"], ["id", 38]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1b62d4fd-a5c1-5624-9067-e45c3261c24c"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1b62d4fd-a5c1-5624-9067-e45c3261c24c"], ["created_at", "2020-10-07 21:57:57.279625"], ["updated_at", "2020-10-07 21:57:57.279625"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 39]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 39], ["created_at", "2020-10-07 21:57:57.293172"], ["updated_at", "2020-10-07 21:57:57.293172"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 39], ["created_at", "2020-10-07 21:57:57.308565"], ["updated_at", "2020-10-07 21:57:57.308565"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-51"], ["title", "Production GKE Clusters should have a highly-available control plane"], ["description", "By default, GKE creates a \"zonal\" cluster.  That is, a cluster where the single control plane GCE instance is deployed in one GCP availability zone.  GKE clusters can also be configured as \"regional\" clusters in which three control plane GCE instances can be deployed evenly across three availability zones at no direct, additional cost.  Having three control plane instances insulates from a single control plane instance failure and allows for zero-downtime API server upgrades."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.location | test(\"^[a-z]+-[a-z0-9]+$\")) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nFor all production GKE clusters, configure the \"location\" as the region name instead of the zone name.  This requires rebuilding the cluster if it is already deployed as a zonal cluster."], ["refs", "[{\"text\":\"GKE Regional Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/regional-clusters\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.315143"], ["id", 39]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "03cf095b-e748-59e1-b596-777da1ba23c3"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "03cf095b-e748-59e1-b596-777da1ba23c3"], ["created_at", "2020-10-07 21:57:57.339873"], ["updated_at", "2020-10-07 21:57:57.339873"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 40]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 40], ["created_at", "2020-10-07 21:57:57.355999"], ["updated_at", "2020-10-07 21:57:57.355999"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-52"], ["title", "GKE Clusters should use a Private Cluster Endpoint/IP"], ["description", "By default, GKE creates clusters with a public IP address on the control plane without any network restriction on source IP ranges that can access it.  Even though the access controls protecting the API server require authentication and authorization, the API server is open to denial-of-service attacks, being probed by bots/scanners inflating Stackdriver logs, and direct exploitation should a Kubernetes API Server vulnerability be discovered."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.privateClusterConfig.enablePrivateEndpoint==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConsider rebuilding GKE clusters with the \"private master endpoint\" configuration to ensure the API server is not assigned a routable public IP address.  Additional considerations:\n\n* Converting a public to a private GKE cluster requires rebuilding it.\n* Use a dedicated /28 subnet for the control plane IP space that does not overlap anywhere and is not part of 172.17.0.0/16.\n* Private control planes leverage VPC peering and count toward VPC peering quota.\n* Modifications to the VPC peering or firewall rules from the control plane to the worker nodes can break the cluster."], ["refs", "[{\"text\":\"GKE Private Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.PT-3\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.363676"], ["id", 40]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0e680f8d-95d8-5fcb-937e-9891dd11fe2e"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0e680f8d-95d8-5fcb-937e-9891dd11fe2e"], ["created_at", "2020-10-07 21:57:57.377215"], ["updated_at", "2020-10-07 21:57:57.377215"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 41]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 41], ["created_at", "2020-10-07 21:57:57.389463"], ["updated_at", "2020-10-07 21:57:57.389463"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-53"], ["title", "Production GKE Cluster NodePools should be spread across multiple availability zones"], ["description", "By default, GKE creates a \"zonal\" cluster.  That is, a cluster where the single control plane GCE instance is deployed in one GCP availability zone and the worker GCE instances are deployed as a node pool in that same availability zone.  This optimizes for cost and simplicity at the expense of redundancy and protection against a zone outage.  If the control plane is set to \"regional\", then the worker GCE instances are deployed evenly across the three availability zones with instance groups per zone.  Setting the node pool instance count to \"1\" on a regional cluster will create one GCE instance in each of the three zones for a total of three worker nodes."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.locations | length >= 3) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nFor all production GKE clusters, configure the \"location\" as the region name instead of the zone name.  This requires rebuilding the cluster if it is already deployed as a zonal cluster.  The worker nodes will automatically be spread evenly across all three availability zones.\n\nConsideration: as traffic goes from node to node over zone boundaries, additional network costs will be incurred."], ["refs", "[{\"text\":\"GKE Regional Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/regional-clusters\",\"ref\":\"link\"},{\"text\":\"GKE Network Pricing\",\"url\":\"https://cloud.google.com/compute/network-pricing\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.398415"], ["id", 41]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "ed4eb845-f04a-5774-986b-112d4a468704"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "ed4eb845-f04a-5774-986b-112d4a468704"], ["created_at", "2020-10-07 21:57:57.410327"], ["updated_at", "2020-10-07 21:57:57.410327"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 42]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.0ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 42], ["created_at", "2020-10-07 21:57:57.427808"], ["updated_at", "2020-10-07 21:57:57.427808"]]
  [1m[35m (2.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-54"], ["title", "GKE Maintenance Window should be explicitly set"], ["description", "The GKE service performs maintenance functions on the cluster control plane and workers automatically, and the default configuration is for the time to be chosen by the service.  However, an organization will often want to configure that time window to fall during hours when traffic levels are lowest, batch processing is not occurring, or when operations teams are available to troubleshoot application issues."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.maintenancePolicy.window | null | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure either a \"simple\" maintenance window of 4 hours (UTC) per day or a more complex maintenance window with rules to define a more granular schedule.  Consideration: The policy must allow at least 24 hours of maintenance availability in a 14-day rolling window. Only contiguous availability windows of at least four hours are considered."], ["refs", "[{\"text\":\"GKE Maintenance Windows\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/maintenance-windows-and-exclusions\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\",\"ID.RA-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.442869"], ["id", 42]]
  [1m[35m (1.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "54c8a422-1076-5507-afbc-1baf12e5bafc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "54c8a422-1076-5507-afbc-1baf12e5bafc"], ["created_at", "2020-10-07 21:57:57.458370"], ["updated_at", "2020-10-07 21:57:57.458370"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 43]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 43], ["created_at", "2020-10-07 21:57:57.470289"], ["updated_at", "2020-10-07 21:57:57.470289"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-55"], ["title", "GKE Intranode Visibility should be enabled"], ["description", "When enabling VPC Flow Logs on a VPC where GKE clusters are running, traffic that does not exit the node is not captured.  That is, traffic between two pods on the same node do not exit the host's network and therefore are omitted from VPC Flow Logging.  Enabling Intranode Visibility allows this traffic to be recorded in the VPC Flow Logs for analysis and diagnosis."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.networkConfig.enableIntraNodeVisibility==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure Intranode Visibility on GKE Clusters running in VPCs with Flow logging enabled.  Considerations: VPC Flow logs may increase in size and contribute to additional cost."], ["refs", "[{\"text\":\"GKE Intranode Visibility\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/intranode-visibility\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-3\",\"DE.CM-1\",\"DE.CM-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.478862"], ["id", 43]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "be0d8437-d539-53fc-b017-0c5e92b00050"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "be0d8437-d539-53fc-b017-0c5e92b00050"], ["created_at", "2020-10-07 21:57:57.487453"], ["updated_at", "2020-10-07 21:57:57.487453"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 44]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 44], ["created_at", "2020-10-07 21:57:57.498973"], ["updated_at", "2020-10-07 21:57:57.498973"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-56"], ["title", "GKE Logs should be sent to Stackdriver"], ["description", "By default, GKE enables a Stackdriver log export managed add-on capability that ships all Host OS, Kubernetes components, and container logs to the Stackdriver endpoint in the current project.  This provides a detailed record of nearly all activities in the cluster and nodes to support troubleshooting and auditing functions.  Even if a third party logging solution is implemented to capture and ship logs, it's recommended that this add-on is enabled to ensure all Host OS and Kubernetes component logs are captured off-cluster."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.loggingService==\"logging.googleapis.com/kubernetes\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the Kubernetes Engine Monitoring for \"System and workload logging and monitoring\" via the console or by way of the `--enable-stackdriver-kubernetes` option to gcloud on all GKE clusters. Existing clusters can have this feature enabled in-place with no downtime."], ["refs", "[{\"text\":\"Kubernetes Engine Monitoring\",\"url\":\"https://cloud.google.com/monitoring/kubernetes-engine/installing\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.507974"], ["id", 44]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39990107-d55c-5487-b87f-bbfe4d19bfd2"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39990107-d55c-5487-b87f-bbfe4d19bfd2"], ["created_at", "2020-10-07 21:57:57.516946"], ["updated_at", "2020-10-07 21:57:57.516946"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 45]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 45], ["created_at", "2020-10-07 21:57:57.536095"], ["updated_at", "2020-10-07 21:57:57.536095"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-57"], ["title", "GKE Metrics should be sent to Stackdriver"], ["description", "By default, GKE enables a Stackdriver metrics export managed add-on capability that ships all Host OS, Kubernetes components, and container metrics to the Stackdriver metrics endpoint in the current project.  This provides a detailed record of nearly all performance metrics in the cluster and nodes to support troubleshooting and auditing functions.  Even if a third party metrics solution is implemented, it's recommended that this add-on is enabled to ensure all Host OS and Kubernetes component metrics are captured off-cluster."], ["platform", "gcp"], ["impact", 6], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.monitoringService==\"monitoring.googleapis.com/kubernetes\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the Kubernetes Engine Monitoring for \"System and workload logging and monitoring\" via the console or by way of the `--enable-stackdriver-kubernetes` option to gcloud on all GKE clusters. Existing clusters can have this feature enabled in-place with no downtime."], ["refs", "[{\"text\":\"Kubernetes Engine Monitoring\",\"url\":\"https://cloud.google.com/monitoring/kubernetes-engine/installing\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.544580"], ["id", 45]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "15d42207-9457-5b63-acf8-186414fa05bb"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "15d42207-9457-5b63-acf8-186414fa05bb"], ["created_at", "2020-10-07 21:57:57.552690"], ["updated_at", "2020-10-07 21:57:57.552690"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 46]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 46], ["created_at", "2020-10-07 21:57:57.563355"], ["updated_at", "2020-10-07 21:57:57.563355"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-58"], ["title", "GKE Node Pools should use the COS or COS_CONTAINERD Operating System"], ["description", "GKE Nodes can leverage either Container-Optimized OS or Ubuntu-based operating system images.  Unless there is a very specific use-case that a Container-Optimized OS image cannot support such as installed certain drivers and/or kernel modules, Ubuntu nodes are not recommended.  Container-Optimized OS is a fully hardened operating system designed specifically to run containerized workloads with a high degree of security, and it receives automatic updates from Google.  The track record for security issues that affect Ubuntu nodes in GKE that did not affect COS nodes is also important to consider."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.imageType | test(\"^COS\")) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure your GKE Node Pools to leverage either the COS or COS_CONTAINERD image type.  The COS image leverages Docker, and the COS_CONTAINERD image implements only containerd and does not use the commonly known Docker socket at `/var/run/docker.sock` which allows applications that can access that socket to effectively be \"root\" on the host.  If your workloads do not require the ability to mount the docker socket for activities such as image building in-cluster or certain security features, COS_CONTAINERD offers an even smaller attack surface than COS.  Considerations: changing the image type recreates the nodes in the node pool."], ["refs", "[{\"text\":\"GKE Node Images\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/node-images\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.570971"], ["id", 46]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0208f5cf-e54b-5a4b-a90a-18f3db82d37e"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0208f5cf-e54b-5a4b-a90a-18f3db82d37e"], ["created_at", "2020-10-07 21:57:57.581498"], ["updated_at", "2020-10-07 21:57:57.581498"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 47]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 47], ["created_at", "2020-10-07 21:57:57.595448"], ["updated_at", "2020-10-07 21:57:57.595448"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.0ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-59"], ["title", "GCP Projects should have only one GKE Cluster"], ["description", "GCP Projects are typically the most granular point for IAM permissions to be declared, and the way GKE clusters expect to leverage the project's resources makes isolating multiple clusters in the same project very difficult.  Assignment of IAM Roles related to instance and cluster administration is typically only available at the Project level, so permissions apply to all clusters.  In addition, logs and metrics sent from GKE clusters go to the Project's shared Stackdriver location, and IAM Roles for logging and monitoring grant access for all logs and metrics for all clusters and applications--making it extremely difficult to prevent users of one cluster from seeing all logs from all applications and all namespaces.  Finally, in some cases of misconfiguration, a compromise of a GKE cluster can lead to compromise of all clusters in the same Project."], ["platform", "gcp"], ["impact", 2], ["validation", "\nFor each GCP Project, run `gcloud container clusters list` and ensure only one cluster is listed per project."], ["remediation", "\nOrganize GCP Projects such that each GKE Cluster has a designated Project with no other resources co-located unless they directly support the cluster.  Understand that certain IAM Roles such as \"Compute Admin\" equate to \"Kubernetes Engine Administrator\" because access to the GCE Instances that make up the GKE worker nodes as \"root\" means those users can also access all data, secrets, and applications inside Kubernetes.  Therefore, also review the IAM permissions in the Project to ensure unintended permission \"cross-over\" is minimized."], ["refs", "[{\"text\":\"IAM Concepts\",\"url\":\"https://cloud.google.com/iam/docs/concepts\",\"ref\":\"link\"},{\"text\":\"GCP Enterprise Best Practices\",\"url\":\"https://cloud.google.com/docs/enterprise/best-practices-for-enterprise-organizations\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.603890"], ["id", 47]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3f80d3c0-7172-5d22-9dc2-a46b12dc6919"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3f80d3c0-7172-5d22-9dc2-a46b12dc6919"], ["created_at", "2020-10-07 21:57:57.615847"], ["updated_at", "2020-10-07 21:57:57.615847"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 48]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 48], ["created_at", "2020-10-07 21:57:57.626253"], ["updated_at", "2020-10-07 21:57:57.626253"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-60"], ["title", "GKE Node pools should AutoRepair"], ["description", "GKE Nodes have several health checks that continuously run to validate that the worker node is running and capable of handling workloads.  If an issue occurs that the system cannot auto-resolve, the automatic repair feature will handle evicting workloads from the node and reprovisioning the underlying GCE instance for you.  This is highly recommended for reducing administrator load and maintaining healthy clusters."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].management.autoRepair==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the node pools to enable AutoRepair during node pool creation or to existing clusters with the `--enable-autorepair` feature set."], ["refs", "[{\"text\":\"GKE Node Auto Repair\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.632236"], ["id", 48]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2a0af119-6735-501b-964a-30efbcd4a153"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2a0af119-6735-501b-964a-30efbcd4a153"], ["created_at", "2020-10-07 21:57:57.643280"], ["updated_at", "2020-10-07 21:57:57.643280"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 49]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 49], ["created_at", "2020-10-07 21:57:57.657799"], ["updated_at", "2020-10-07 21:57:57.657799"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.2ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-61"], ["title", "GKE Node pools should AutoUpgrade"], ["description", "The GKE service will automatically maintain the version and patch release of the control plane nodes, but the Node Pools are left to the user to keep upgraded by default.  This can result in situations where security issues are patched on the control plane but not on the nodes, and performing node upgrades is an activity that can consume a large amount of administrative time if performed manually across many clusters and node pools.  If your workloads are properly configured to withstand a single node failure, these maintenance activities can be performed during upgrade windows without manual intervention or downtime."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].management.autoUpgrade==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the node pools to enable AutoUpgrade during node pool creation or to existing clusters with the `--enable-autoupgrade` feature set.  It's strongly recommended to validate that all workloads can handle the upgrade process smoothly in a development cluster before enabling this setting in production."], ["refs", "[{\"text\":\"GKE Node Auto Upgrade\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-upgrades\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.665444"], ["id", 49]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "4cef5a03-d6db-5fd8-92fe-453b24cdb3db"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "4cef5a03-d6db-5fd8-92fe-453b24cdb3db"], ["created_at", "2020-10-07 21:57:57.691227"], ["updated_at", "2020-10-07 21:57:57.691227"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 50]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 50], ["created_at", "2020-10-07 21:57:57.703476"], ["updated_at", "2020-10-07 21:57:57.703476"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 50], ["created_at", "2020-10-07 21:57:57.715168"], ["updated_at", "2020-10-07 21:57:57.715168"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-62"], ["title", "GKE Node pools should use the minimum OAuth Scopes"], ["description", "GKE Nodes are fundamentally GCE instances, and GCE instances with a Service Account attached have the permissions of the IAM Roles attached.  However, those permissions can be restricted even further by defining OAuth Scopes that explicitly list the APIs the OAuth Token generated for that Service Account are valid for.  For example, a GCE instance with an attached Service Account that is assigned the IAM Role of \"Project Owner\" but has only the \"https://www.googleapis.com/auth/devstorage\" OAuth Scope will only be able to interact with GCS Buckets.  However, if that OAuth Scope was set to \"https://www.googleapis.com/auth/cloud-platform\" (equivalent to \"any/all APIs\"), that instance would have the full privileges provided by \"Project Owner\".  By default, GKE Node Pools should only specify the following OAuth Scopes that provide the minimum access needed:\n\n* https://www.googleapis.com/auth/devstorage.read_only\n* https://www.googleapis.com/auth/logging.write\n* https://www.googleapis.com/auth/monitoring\n* https://www.googleapis.com/auth/service.management.readonly\n* https://www.googleapis.com/auth/servicecontrol\n* https://www.googleapis.com/auth/trace.append"], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.oauthScopes[] | test(\"cloud-platform\") | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure GKE Node Pools to explicitly set only the minimum OAuth Scopes.  For pods/applications that were running on these nodes and leveraging the node's Service Account for access to GCP APIs, understand that access is shared by all pods unless Workload Identity is deployed.  To map GCP Service Accounts to individual Pods/Workloads, create GCP Service Accounts in the Project with the necessary permissions and leverage Workload Identity to attach those credentials directly."], ["refs", "[{\"text\":\"GKE NodePool OAuth Scopes\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#use_least_privilege_sa\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-1\",\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.721521"], ["id", 50]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1dc51c31-05b3-5fe8-9b79-9d09c7a9db93"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1dc51c31-05b3-5fe8-9b79-9d09c7a9db93"], ["created_at", "2020-10-07 21:57:57.731895"], ["updated_at", "2020-10-07 21:57:57.731895"]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 51]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 51], ["created_at", "2020-10-07 21:57:57.745188"], ["updated_at", "2020-10-07 21:57:57.745188"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-63"], ["title", "GKE Subnet Alias ranges should be configured"], ["description", "In order to support private GKE Clusters, Alias IP ranges on the VPC Subnets is required.  In addition to private clusters, Alias IP ranges simplify the route tables in the VPC, reduce the number of \"hops\" traffic takes from load balancers to Pods, and allows the GCE network interfaces to perform anti-spoofing checks as IP forwarding is not required on the instance.  Finally, the separation of VM IPs from Container IPs allows for native firewall rules to be configured for pod traffic separately from VM traffic."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.ipAllocationPolicy.useIpAliases==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nDuring cluster creation, specify a VPC Subnet that supports Alias IP ranges and secondary ranges for Pods and Services.  This can only be done at cluster creation time."], ["refs", "[{\"text\":\"VPC Alias IPs\",\"url\":\"https://cloud.google.com/vpc/docs/alias-ip\",\"ref\":\"link\"},{\"text\":\"VPC-Native GKE Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/alias-ips\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.PT-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.751837"], ["id", 51]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8aced34e-ed35-50d8-aaab-3bd7271bb6f7"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8aced34e-ed35-50d8-aaab-3bd7271bb6f7"], ["created_at", "2020-10-07 21:57:57.761154"], ["updated_at", "2020-10-07 21:57:57.761154"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 52]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 52], ["created_at", "2020-10-07 21:57:57.773200"], ["updated_at", "2020-10-07 21:57:57.773200"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 52], ["created_at", "2020-10-07 21:57:57.783583"], ["updated_at", "2020-10-07 21:57:57.783583"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-64"], ["title", "Legacy ABAC authorization in GKE"], ["description", "Role-Based Access Control has been the default authorization mechanism in Kubernetes since version 1.6.  GKE still provides a legacy capability that supports ABAC, but it should not be used.  It essentially provides \"cluster admin\" access for any authenticated credential to the cluster and has no method for changing this policy.  This is an extremely permissive setting that allows for full cluster compromise should an attacker gain access to a single pod with a mounted Kubernetes service account or a valid cluster credential."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.legacyAbac.enabled | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the cluster without the `--enable-legacy-authorization` flag set.  If migrating an existing cluster from ABAC to RBAC by modifying this setting in-place, ensure that all the required RBAC RoleBindings and ClusterRoleBindings are present first.  This should be performed in a development environment before applying this process to production clusters."], ["refs", "[{\"text\":\"GKE Cluster Hardening\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.789858"], ["id", 52]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "055adcff-8a12-503a-8056-fe418d714bbf"], ["LIMIT", 1]]
  [1m[35m (0.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "055adcff-8a12-503a-8056-fe418d714bbf"], ["created_at", "2020-10-07 21:57:57.799749"], ["updated_at", "2020-10-07 21:57:57.799749"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 53]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 53], ["created_at", "2020-10-07 21:57:57.811905"], ["updated_at", "2020-10-07 21:57:57.811905"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-65"], ["title", "CloudSQL Instances High-Availability"], ["description", "By default, CloudSQL instances are deployed as a single instance, and this means an instance failure or availability-zone outage would take the database offline.  Production applications should be relying on access to data stores that can withstand these failure conditions where possible, and the CloudSQL service offering provides a high-availability instance type that runs in multiple availability-zones in the same region for this purpose."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.availabilityType==\"ZONAL\") | \"(.name) Type: (.settings.availabilityType)\"'` and ensure no entries are listed as \"ZONAL\"."], ["remediation", "\nCreate or update the CloudSQL instances used in production with the \"REGIONAL\" availability type instead of the default of \"ZONAL\". Existing instances can be modified to have these settings take effect, but it requires the instance to be restarted."], ["refs", "[{\"text\":\"CloudSQL MySQL High Availability\",\"url\":\"https://cloud.google.com/sql/docs/mysql/high-availability\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL High Availability\",\"url\":\"https://cloud.google.com/sql/docs/postgres/high-availability\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver High Availability\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/high-availability\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.818160"], ["id", 53]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "323aca0a-eab5-5ecc-8e58-ea66f6cb8103"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "323aca0a-eab5-5ecc-8e58-ea66f6cb8103"], ["created_at", "2020-10-07 21:57:57.827329"], ["updated_at", "2020-10-07 21:57:57.827329"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 54]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 54], ["created_at", "2020-10-07 21:57:57.840324"], ["updated_at", "2020-10-07 21:57:57.840324"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-66"], ["title", "CloudSQL Instances maintenance windows"], ["description", "The CloudSQL service performs maintenance functions on the instances automatically, and the default configuration is for the time to be chosen by the service.  However, an organization will often want to configure that time window to fall during hours when traffic levels are lowest, batch processing is not occurring, or when operations teams are available to troubleshoot application issues."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.maintenanceWindow.day==0 and .settings.maintenanceWindow.hour==0) | \"(.name) Type: (.settings.maintenanceWindow.day) (.settings.maintenanceWindow.hour)\"'` and ensure no entries are listed as \"0 0\"."], ["remediation", "\nConfigure the maintenance preferences on the CloudSQL instance to a preferred window that has the days and hours when updates should occur, and select the order of update to be \"Any\", \"Earlier\", or \"Later\" to correspond to the timing of when the rolling updates should include this instance.  Typically, development instances should be set to \"Earlier\" and production instances set to \"Later\" to help validate upgrades and patches on less critical databases first.  Also, opt-in to email notifications for maintenance on the communications page at `https://console.cloud.google.com/user-preferences/communication`."], ["refs", "[{\"text\":\"CloudSQL MySQL Maintenance Windows\",\"url\":\"https://cloud.google.com/sql/docs/mysql/maintenance\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Maintenance Windows\",\"url\":\"https://cloud.google.com/sql/docs/postgres/maintenance\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Maintenance Windows\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/maintenance\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.848642"], ["id", 54]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e8f23fba-c1ab-5c39-8a2b-faf957ded12c"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e8f23fba-c1ab-5c39-8a2b-faf957ded12c"], ["created_at", "2020-10-07 21:57:57.857241"], ["updated_at", "2020-10-07 21:57:57.857241"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 55]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.0ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 55], ["created_at", "2020-10-07 21:57:57.868872"], ["updated_at", "2020-10-07 21:57:57.868872"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-67"], ["title", "CloudSQL Instance automatic backups with point-in-time recovery"], ["description", "By default, CloudSQL instances have automatic backups with point-in-time recovery enabled.  It's important that these settings are not disabled to ensure that all databases can be restored to a known-good state should a security incident occur.  For example, a SQL injection attack that results in the deletion or modification of tables in the database."], ["platform", "gcp"], ["impact", 9], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.backupConfiguration.enabled==false) | \"(.name) Backups on: (.settings.backupConfiguration.enabled) and PITR on: (.settings.backupConfiguration.binaryLogEnabled)\"'` and ensure no entries are listed."], ["remediation", "\nEnsure all CloudSQL instances are configured with automatic backups during a desired window and point-in-time recovery is enabled.  Existing instances can be modified to have these settings take effect, but it requires the instance to be restarted."], ["refs", "[{\"text\":\"CloudSQL MySQL Backups\",\"url\":\"https://cloud.google.com/sql/docs/mysql/backup-recovery/backups\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Backups\",\"url\":\"https://cloud.google.com/sql/docs/postgres/backup-recovery/backups\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Backups\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/backup-recovery/backups\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-4\",\"PR.PT-5\",\"PR.IP-10\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.878156"], ["id", 55]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9bde9d05-e5e0-545e-bcea-a722d5e0d511"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9bde9d05-e5e0-545e-bcea-a722d5e0d511"], ["created_at", "2020-10-07 21:57:57.886122"], ["updated_at", "2020-10-07 21:57:57.886122"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 56]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 56], ["created_at", "2020-10-07 21:57:57.897849"], ["updated_at", "2020-10-07 21:57:57.897849"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-68"], ["title", "Public nodes via SSH"], ["description", "The Kubernetes Worker nodes are exposed publicly via SSH.  This provides convenient remote administrative access, but it affords only a single layer of defense in front of the Kubernetes cluster and all applications and data inside. Having \"root\" access to one Kubernetes cluster node is very often sufficient to become \"cluster-admin\" in the cluster which grants full control of the cluster and the underlying nodes."], ["platform", "k8s"], ["impact", 5], ["validation", "\nEnsure that all Kubernetes worker nodes are not available on TCP/22 from any IP address using a simple port probe. e.g. `nc -vz ip.of.the.worker 22`."], ["remediation", "\nConfigure the firewall rules on the Kubernetes worker systems to be restricted to a known set of IP ranges for SSH access.  In environments with bastion hosts or VPNs, their internal subnet range or security groups are commonly used."], ["refs", "[{\"text\":\"Kubernetes Security Best Practices\",\"url\":\"https://kubernetes.io/blog/2016/08/security-best-practices-kubernetes-deployment/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.MA-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.906473"], ["id", 56]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "68066452-dd6e-5468-a50d-f70ef5bb4adc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "68066452-dd6e-5468-a50d-f70ef5bb4adc"], ["created_at", "2020-10-07 21:57:57.915968"], ["updated_at", "2020-10-07 21:57:57.915968"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 57]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 57], ["created_at", "2020-10-07 21:57:57.941824"], ["updated_at", "2020-10-07 21:57:57.941824"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-69"], ["title", "Secrets in ConfigMaps"], ["description", "Kubernetes ConfigMaps can be used to store configuration key/value pairs and files to be dynamically mounted into pods at runtime, and those can often contain sensitive data like API keys and other credentials.  However, this exposes them to users and other workloads that interact with the API server who have the RBAC permission \"get configmaps\" in the cluster which is commonly a much wider audience than desired."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get configmaps --all-namespaces -o yaml > cfgmaps.yml` and use a tool like TruffleHog to review the data for potentially sensitive items."], ["remediation", "\nEnsure that no secret material is directly defined in ConfigMaps.  Instead, store them in a Secret and use the secretKeyRef mechanism to mount them in as files inside the container at runtime."], ["refs", "[{\"text\":\"Kubernetes ConfigMaps\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/\",\"ref\":\"link\"},{\"text\":\"TruffleHog\",\"url\":\"https://github.com/dxa4481/truffleHog\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:57.951815"], ["id", 57]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0b473d00-130f-5be6-a6ff-3ef74e8ee55e"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0b473d00-130f-5be6-a6ff-3ef74e8ee55e"], ["created_at", "2020-10-07 21:57:57.969366"], ["updated_at", "2020-10-07 21:57:57.969366"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 58]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (2.0ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 58], ["created_at", "2020-10-07 21:57:57.993790"], ["updated_at", "2020-10-07 21:57:57.993790"]]
  [1m[35m (10.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (2.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (4.2ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-70"], ["title", "Ensure resource specification enforcement is installed"], ["description", "By default in Kubernetes, the ability to create resources is only controlled via RBAC authorization.  If a user has the ability to create or modify a Pod, they are able to create or modify any setting during its creation.  This can include settings that allow it to run as root/privileged, mount the host filesystem, to add Linux system capabilities, to attach to the host's network and process namespace, and more.  All of these settings are potential pathways for escaping to the underlying nodes and compromising the entire cluster.  To prevent users from creating resources with undesired configurations, an administrator can deploy an \"Admission Controller\" such as PodSecurityPolicy or a \"Dynamic Admission Control Webhook\" to ask a service like Gatekeeper.  If either determines the workload to not meet policy, it can prevent the workload from running."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get psps --all-namespaces` to identify `PodSecurityPolicy` resources in place, or run `kubectl get deployments --all-namespaces` and look for `gatekeeper` or `k-rail` deployments to be present."], ["remediation", "\nWhile PodSecurityPolicy is a native admission controller that can protect clusters from users running insecure pod workloads, it is still in Kubernetes beta, and it is limited only to Pod resources.  The Gatekeeper project, which uses Open Policy Agent as its policy engine, can be deployed more easily, can review any resource in the cluster if desired, and allows for full customization of what to look for.  Deploying either OPA/Gatekeeper or K-Rail is therefore the recommended solution for those that do not already have PodSecurityPolicy implemented."], ["refs", "[{\"text\":\"Kubernetes PodSecurityPolicy\",\"url\":\"https://kubernetes.io/docs/concepts/policy/pod-security-policy/\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"text\":\"K-rail\",\"url\":\"https://github.com/cruise-automation/k-rail\",\"ref\":\"link\"},{\"text\":\"GKE PodSecurityPolicy\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/pod-security-policies\",\"ref\":\"link\"},{\"text\":\"EKS PodSecurityPolicy\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/pod-security-policy.html\",\"ref\":\"link\"},{\"text\":\"AKS PodSecurityPolicy\",\"url\":\"https://docs.microsoft.com/en-us/azure/aks/use-pod-security-policies\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.050022"], ["id", 58]]
  [1m[35m (7.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "261a1a40-e362-5bbc-ad48-cc59419ac436"], ["LIMIT", 1]]
  [1m[35m (1.9ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (3.2ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "261a1a40-e362-5bbc-ad48-cc59419ac436"], ["created_at", "2020-10-07 21:57:58.085279"], ["updated_at", "2020-10-07 21:57:58.085279"]]
  [1m[35m (6.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 59]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (2.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (2.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 59], ["created_at", "2020-10-07 21:57:58.115969"], ["updated_at", "2020-10-07 21:57:58.115969"]]
  [1m[35m (5.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (1.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 59], ["created_at", "2020-10-07 21:57:58.145339"], ["updated_at", "2020-10-07 21:57:58.145339"]]
  [1m[35m (3.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-71"], ["title", "Validate NetworkPolicies are defined in each namespace"], ["description", "By default in Kubernetes, all Pods can communicate with each other by IP and egress to any subnet (including the Internet) unless routing or firewalls are added to prevent that traffic.  This presents ample opportunity for lateral movement from the perspective of a compromised workload. One of the best ways to reduce the scope of that movement is to deploy NetworkPolicy resources that define firewall rules for pod-to-pod traffic.  All pod-to-pod and egress traffic is allowed, and this means that pods that handle customer data can talk directly to core Kubernetes system pods, the Internet, and other systems inside the VPC if the security groups allow."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get networkpolicies --all-namespaces` and ensure each namespace has the desired policies defined."], ["remediation", "\nImplement NetworkPolicy rules on the kube-system namespace to prevent all inbound traffic from non-kube-system namespaces to all workloads in the kube-system namespace with the exception of UDP/TCP 53 for DNS lookups.  Next, identify the network traffic patterns of externally exposed workloads and implement NetworkPolicies that restrict their traffic to the \"next hop\" service or ranges.  Finally, perform the same pattern to all internal workloads.  Considerations: Implementing NetworkPolicies should be performed in a development environment to fully understand implications and to avoid introducing an outage in production."], ["refs", "[{\"text\":\"Kubernetes Network Policies\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/network-policies/\",\"ref\":\"link\"},{\"text\":\"NetworkPolicy Recipes\",\"url\":\"https://github.com/ahmetb/kubernetes-network-policy-recipes\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.158823"], ["id", 59]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1666b935-62e1-5594-a7a6-ab0395b90ed4"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.9ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1666b935-62e1-5594-a7a6-ab0395b90ed4"], ["created_at", "2020-10-07 21:57:58.169373"], ["updated_at", "2020-10-07 21:57:58.169373"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 60]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 60], ["created_at", "2020-10-07 21:57:58.188223"], ["updated_at", "2020-10-07 21:57:58.188223"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-72"], ["title", "ServiceAccount mounted unnecessarily"], ["description", "By default, the \"default\" Service Account in each namespace will be mounted inside every container in every Pod unless explicitly configured to use another Service Account or to not be mounted.  The Service Account token that is mounted for convenience inside the pod in case the container workload needs a valid credential to communicate with the Kubernetes API.  However, most workloads do not require this access, and so they should be explicitly configured not to mount it to minimize exposure to these credentials."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace +\"/\"+ .metadata.name +\": \"+ .spec.serviceAccount'` and review the listing for pods that mount service accounts where API access is not required.  Typically, workloads that mount the \"default\" service account are likely candidates as pods should be mounting dedicated service accounts if needed."], ["remediation", "\nFor every non-kube-system namespace, modify all Service Accounts to opt out of automounting API credentials by setting automountServiceAccountToken: false.  Ensure RBAC bindings to all \"default\" Service Accounts are removed, and use dedicated Service Accounts for each workload that needs API Access with dedicated RBAC Role/ClusterRoleBindings."], ["refs", "[{\"text\":\"Kubernetes ServiceAccounts\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.198933"], ["id", 60]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9feaff35-13bb-5856-aac9-7cd93cae3beb"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9feaff35-13bb-5856-aac9-7cd93cae3beb"], ["created_at", "2020-10-07 21:57:58.211560"], ["updated_at", "2020-10-07 21:57:58.211560"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 61]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 61], ["created_at", "2020-10-07 21:57:58.224339"], ["updated_at", "2020-10-07 21:57:58.224339"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-73"], ["title", "Orphaned Persistent Volume Claims found"], ["description", "Multiple persistent disk volume claims were found to be in the \"Released\" state, and they indicate a potential misconfiguration in a deployment or statefulset leaving them behind."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pvc --all-namespaces` and look for items in the \"Released\" state.  Ideally, all should be in use."], ["remediation", "\nEnsure the workloads that created and abandoned the affected persistent volume claims correctly clean up after themselves and delete the persistent volume claims if they are no longer needed."], ["refs", "[{\"text\":\"Kubernetes Persistent Volumes\",\"url\":\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.238288"], ["id", 61]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "329030a1-3e54-50be-99c1-ff580fce5595"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "329030a1-3e54-50be-99c1-ff580fce5595"], ["created_at", "2020-10-07 21:57:58.252962"], ["updated_at", "2020-10-07 21:57:58.252962"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.0ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 62]]
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 62], ["created_at", "2020-10-07 21:57:58.280092"], ["updated_at", "2020-10-07 21:57:58.280092"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-74"], ["title", "Inconsistent use of CPU/RAM requests/limits"], ["description", "By default in Kubernetes, workloads that do not specify how many resources they expect to use and/or a limit to their resources receive the default settings.  The default settings depend on a LimitRange resource in the namespace, and the default is to request 1/10th of a CPU core (100 millicores or \"100m\"), no request for RAM, and no CPU or RAM limits.  This means that every pod is able to burst up to the total physical resources of the node, and the scheduler will tightly pack pods on a node.  This configuration is typically no problem at low or average load, so it might take a while to surface and cause resource constraint problems.  But when those resources are exhausted, the node becomes \"Unready\" and all workloads are evicted.  When they land on the other nodes that are already heavily loaded, it overloads them until they evict all pods.  This can cause a cascading resource failure outage."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace as $ns | .metadata.name as $name| .spec.containers[] | $ns +\"/\"+ $name +\"[\"+ .name +\"]: \"+ .resources.requests.cpu +\",\"+ .resources.limits.cpu +\",\"+ .resources.requests.memory +\",\"+ .resources.limits.memory'` to get a comma separated listing of \"CPU Req, CPU Limits, Memory Reqs, Memory Limits\" for each container in every pod.  All containers should specify all four values explicitly."], ["remediation", "\nFor every deployment in the cluster, ensure it has the proper settings for CPU and Memory \"Requests\" and CPU and Memory \"Limits\".  The \"Requests\" settings are vital for the scheduler to correctly place workloads on nodes without going over actual capacity.  The \"Limits\" settings are vital for the node to ensure the workload does not consume all physical resources on the node.  \"Requests\" should be set at 10% above average consumption and \"Limits\" should be 10-20% higher than maximum consumption.  Use \"kubectl top node\" and \"kubectl top pods --all-namespaces\" to see actual usage for running workloads."], ["refs", "[{\"text\":\"Kubernetes Resourcing\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/\",\"ref\":\"link\"},{\"text\":\"Kubectl Cheat Sheet\",\"url\":\"https://kubernetes.io/docs/reference/kubectl/cheatsheet/#interacting-with-running-pods\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.287017"], ["id", 62]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d8276fe4-4044-5077-be5c-d95fc59f6e14"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d8276fe4-4044-5077-be5c-d95fc59f6e14"], ["created_at", "2020-10-07 21:57:58.300021"], ["updated_at", "2020-10-07 21:57:58.300021"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 63]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 63], ["created_at", "2020-10-07 21:57:58.317339"], ["updated_at", "2020-10-07 21:57:58.317339"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-75"], ["title", "Ensure all pods reference container images from known sources"], ["description", "By default, Kubernetes allows users with the ability to create pods to reference any container image path, including public registries like DockerHub.  This allows developers to share and use pre-made container images easily, but it enables unvalidated and untrusted code to run inside your cluster with potential access to mounted secrets and service account tokens.  Container images should be verified to be conformant to security standards before being run, and the first step to this is to validate that all container images are being pulled from a known set of registries.  This helps development teams and security teams work from the same base location for running and validating images."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get po -A -ojsonpath='{..image}' | kubectl get pods --all-namespaces -o jsonpath='{..image}' |tr -s '[[:space:]]' '\n' | sort | uniq -c ` and ensure all images are sourced from the official Kubernetes or cloud provider registries and your own internal container registries."], ["remediation", "\nReview all deployments and pod specifications, and find any that reference non-approved container registries.  Create a dedicated container registry in your environment, validate those container images meet your security policies, and store/mirror them to that dedicated container registry/registries.  Consider enforcing image sources early with a validation step in the CI/CD pipeline and enforcing the policy with OPA/Gatekeeper or other policy-based admission controller inside the cluster."], ["refs", "[{\"text\":\"Kubectl List Images\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/list-all-running-container-images/\",\"ref\":\"link\"},{\"text\":\"DockerHub Library\",\"url\":\"https://hub.docker.com/u/library\",\"ref\":\"link\"},{\"text\":\"Google Container Registry\",\"url\":\"https://cloud.google.com/container-registry\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.324695"], ["id", 63]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "51a10d61-4108-5f95-9db4-c172cc4d03a7"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.1ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "51a10d61-4108-5f95-9db4-c172cc4d03a7"], ["created_at", "2020-10-07 21:57:58.336404"], ["updated_at", "2020-10-07 21:57:58.336404"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 64]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 64], ["created_at", "2020-10-07 21:57:58.353274"], ["updated_at", "2020-10-07 21:57:58.353274"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-76"], ["title", "Containers are not built using centralized, automated CI pipeline"], ["description", "Currently, the custom containers are built manually from an administrator's workstation and not via a centralized, automated process.  The key concern is reproducibility.  Without centralizing the source code and the code and configuration to build images, only one person with a specific laptop can build and change container images confidently."], ["platform", "k8s"], ["impact", 9], ["validation", "\nFor each running container image, ensure that there is a source control repository where it holds the instructions for how to build the image and that it leverages a CI or automated build system to generate a new image artifact.  Review the build history to ensure there are recent passing builds."], ["remediation", "\nImplement a CI system or leverage native container build services within the cloud provider to build newly tagged container images and push them to a private registry.  This ensures repeatability of the process by any member of the team as well as a shared history for build success and failures are present."], ["refs", "[{\"text\":\"GCP Cloud Build\",\"url\":\"https://cloud.google.com/cloud-build/docs/\",\"ref\":\"link\"},{\"text\":\"Google Container Registry\",\"url\":\"https://cloud.google.com/container-registry/docs/\",\"ref\":\"link\"},{\"ids\":[\"ID.SC-4\",\"ID.SC-2\",\"PR.IP-2\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.361718"], ["id", 64]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "df3d2443-7fdc-5024-a970-135a7e32d438"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "df3d2443-7fdc-5024-a970-135a7e32d438"], ["created_at", "2020-10-07 21:57:58.379926"], ["updated_at", "2020-10-07 21:57:58.379926"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 65]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 65], ["created_at", "2020-10-07 21:57:58.396383"], ["updated_at", "2020-10-07 21:57:58.396383"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-77"], ["title", "Ensure continuous container scanning and redeployment"], ["description", "When deploying container images into a Kubernetes cluster, they should first be reviewed to meet an acceptable risk profile.  This is typically done using automated container vulnerability scans at build time.  However, container deployments with infrequent needs for changes will mean that they can exist for long periods without being rebuilt in order to receive security fixes.  As the number of deployments grows, this process must be automated or it will be quickly beyond a human's ability to manage."], ["platform", "k8s"], ["impact", 9], ["validation", "\nEnsure a solution is implemented, validate that it is deployed in all clusters if needed, and verify that all container registries and images are being scanned daily (or more frequently) for new vulnerabilities.  If possible, validate that a policy is in place to alert administrators of severe vulnerabilities and even block them from being deployed."], ["remediation", "\nDeploy either a cloud provider solution or leverage a third party tool that continuously scans images in use against all current vulnerabilities.  Configure a security policy such that all high/critical vulnerabilities alert the appropriate teams.  If possible, configure the tooling to automatically trigger a new container build."], ["refs", "[{\"text\":\"Kritis\",\"url\":\"https://github.com/grafeas/kritis\",\"ref\":\"link\"},{\"text\":\"Grafeas\",\"url\":\"https://github.com/grafeas/kritis/blob/master/docs/tutorial.md\",\"ref\":\"link\"},{\"text\":\"Sysdig\",\"url\":\"https://sysdig.com\",\"ref\":\"link\"},{\"text\":\"Twistlock\",\"url\":\"https://twistlock.com\",\"ref\":\"link\"},{\"text\":\"Aqua Security\",\"url\":\"https://aquasec.com\",\"ref\":\"link\"},{\"text\":\"GKE Binary Authorization\",\"url\":\"https://cloud.google.com/binary-authorization/docs/setting-up\",\"ref\":\"link\"},{\"text\":\"GCP Container Analysis\",\"url\":\"https://cloud.google.com/container-registry/docs/container-analysis\",\"ref\":\"link\"},{\"ids\":[\"ID.SC-4\",\"ID.SC-2\",\"PR.DS-6\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.407844"], ["id", 65]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "86d03ac3-702b-567a-9407-7bd74e633bc3"], ["LIMIT", 1]]
  [1m[35m (0.9ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "86d03ac3-702b-567a-9407-7bd74e633bc3"], ["created_at", "2020-10-07 21:57:58.424701"], ["updated_at", "2020-10-07 21:57:58.424701"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 66]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 66], ["created_at", "2020-10-07 21:57:58.448355"], ["updated_at", "2020-10-07 21:57:58.448355"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-78"], ["title", "Cluster workloads mount the Docker socket directly"], ["description", "In Kubernetes clusters running on nodes that leverage Docker for running containers, providing access to the /var/run/docker.sock is equivalent to granting that container 'root' on the underlying host as it allows for running containers on the node with any permission.  It should not be mounted inside a container as it bridges two layers in the infrastructure that should be kept independent from each other.  With the socket mounted, cluster users do not have to have 'cluster admin' to be able to get 'root' on the nodes.  Instead, they only need the 'exec pod' permission in this namespace to be able to exec commands inside this container to become 'root' on the nodes and compromise the cluster.  In addition, many Kubernetes distributions are moving to ContainerD which does not have a listening Docker socket and therefore a smaller attack surface.  In GKE, this workload cannot operate on the newer 'COS_CONTAINERD' image types."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace as $ns | .metadata.name as $name| .spec.volumes[] |select(.hostPath.path|tostring|test(\".sock\")) | $ns +\"/\"+ $name +\"[\"+ .name +\"]: \"+ .hostPath.path'` and validate that no pods are returned that mount \"/var/run/docker.sock\" or similar."], ["remediation", "\nConsider modifying the workload or choosing another workload that does similar functionality but does not mount the Docker socket.  This will remove the attack surface added by this workload and also enable the migration to the COS_CONTAINERD image type when it becomes the default."], ["refs", "[{\"text\":\"GKE Containerd\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/using-containerd\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.456686"], ["id", 66]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7ff475ce-ef30-5d68-b04a-e96be923090a"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.9ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7ff475ce-ef30-5d68-b04a-e96be923090a"], ["created_at", "2020-10-07 21:57:58.470769"], ["updated_at", "2020-10-07 21:57:58.470769"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 67]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 67], ["created_at", "2020-10-07 21:57:58.484728"], ["updated_at", "2020-10-07 21:57:58.484728"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-79"], ["title", "Ensure privileged containers are only in system namespaces"], ["description", "Container run in Kubernetes that require deep access to the underlying worker nodes are often run in a `privileged` security context.  Common examples are daemonsets that implement functionality for container and host logging or metrics export, driver installation, and container and host security detection.  Privileged containers are essentially \"root\" on the underlying node, and they should therefore be kept in \"system\" namespaces to allow for proper RBAC and admission control policies to be created to protect them.  If they are in namespaces with other normal application workloads, it becomes difficult to ensure proper separation and prevent host escapes."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | \"(.metadata.namespace)/(.metadata.name): (.spec.containers[].securityContext.privileged)\"' | grep -v \"null$\"` and validate that all privileged pods are in namespaces named and dedicated for system workloads."], ["remediation", "\nEither leverage the `kube-system` namespace or deploy privileged daemonsets to dedicated namespaces only used for these purposes.  Restrict RBAC permissions and admission control policies to only permit the required admins access to operate and exec into them for troubleshooting."], ["refs", "[{\"text\":\"Kubernetes port-forward\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\",\"PR.PT-3\",\"PR.AT-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.491217"], ["id", 67]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (4.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3957d9b0-4a99-5b41-9520-2b7228e9d343"], ["LIMIT", 1]]
  [1m[35m (0.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3957d9b0-4a99-5b41-9520-2b7228e9d343"], ["created_at", "2020-10-07 21:57:58.522862"], ["updated_at", "2020-10-07 21:57:58.522862"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 68]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 68], ["created_at", "2020-10-07 21:57:58.542992"], ["updated_at", "2020-10-07 21:57:58.542992"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-80"], ["title", "Container images do not refer to the exact tag or commit"], ["description", "When referring to a container image stored in a registry, it's common practice for the owner of the image to tag the most recent image with a semver tag and also the `latest` tag when uploading it.  This is a convenenience for users wanting to work with the most up-to-date image, but it presents an opportunity for inconsistencies inside Kubernetes.  If a deployment with more than one replica references an image with the tag `latest`, the underlying node will pull and run that image at that time.  If the image in the registry is updated with a new `latest` image and the deployment scales the number of replicas such that a new worker node is to run it, that node will potentially pull the newer `latest` image. This could result in multiple pods in a single deployment running a different image with different functionality or even cause a difficult to trace outage.  During the image build process, it's common practice to tag the image with shortened hash from the git commit that triggered the image build to help with tracing an image directly back to the code and process that created it and to satisfy certain auditing requirements."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get po -A -ojsonpath='{..image}' | kubectl get pods --all-namespaces -o jsonpath='{..image}' |tr -s '[[:space:]]' '\n' | sort | uniq -c | grep latest` and ensure no images reference the `latest` tag."], ["remediation", "\nReview all deployments and pod specifications, and modify any that reference the `latest` tag to use a specific version tag or even the `sha256` hash.  Consider enforcing this practice early with a validation step in the CI/CD pipeline and enforcing the policy with OPA/Gatekeeper or other policy-based admission controller inside the cluster."], ["refs", "[{\"text\":\"Container Image Tagging\",\"url\":\"https://docs.docker.com/engine/reference/commandline/build/#tag-an-image--t\",\"ref\":\"link\"},{\"text\":\"Kubectl List Images\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/list-all-running-container-images/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Configuration Best Practices\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/overview/#container-images\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.550821"], ["id", 68]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "640b3852-f894-5537-b656-6bb5501f9602"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "640b3852-f894-5537-b656-6bb5501f9602"], ["created_at", "2020-10-07 21:57:58.559977"], ["updated_at", "2020-10-07 21:57:58.559977"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 69]]
  [1m[36mTag Load (0.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 69], ["created_at", "2020-10-07 21:57:58.572441"], ["updated_at", "2020-10-07 21:57:58.572441"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-81"], ["title", "Inconsistent use of Liveness and Readiness probes on pods listening on a port"], ["description", "By default, pods that listen on ports do not have Liveness and Readiness probes configured.  These are both required for pods to be able to support zero-downtime deployment upgrades for services that handle continuous traffic.  Readiness probes are network or command checks that have to succeed before the pod goes to the 'Ready' state.  This means traffic routed to them by a Service will not occur until they are 'ready' to handle that traffic successfully.  Liveness probes are network or command checks that have to succeed on a routine basis for the pod to remain in the 'Ready' state.  If the checks fail, the pod will be removed from the 'Ready' state, and the service will know not to route traffic to that pod."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace as $ns | .metadata.name as $name| .spec.containers[] | select(.ports) | $ns +\"/\"+ $name + \"[\"+ .name +\"]: \"+ (.readinessProbe.successThreshold|tostring) +\" \"+ (.livenessProbe.successThreshold|tostring)'` and ensure every container that exposes ports also has non-zero numbers representing the readiness and liveness probes."], ["remediation", "\nAll pods that listen on ports behind services should have Liveness and Readiness probes configured in their pod specification to behave properly and reduce network-related errors."], ["refs", "[{\"text\":\"Liveness and Readiness Probes\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.579233"], ["id", 69]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39a7bf62-d40d-5b79-93e3-3abc0512d3a3"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39a7bf62-d40d-5b79-93e3-3abc0512d3a3"], ["created_at", "2020-10-07 21:57:58.587806"], ["updated_at", "2020-10-07 21:57:58.587806"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 70]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 70], ["created_at", "2020-10-07 21:57:58.600142"], ["updated_at", "2020-10-07 21:57:58.600142"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.0ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-82"], ["title", "AppArmor profiles are not implemented"], ["description", "AppArmor is a Linux kernel security module that supplements the standard Linux user and group based permissions to confine programs to a limited set of resources. AppArmor can be configured for any application to reduce its potential attack surface and provide greater in-depth defense. It is configured through profiles tuned to whitelist the access needed by a specific program or container, such as Linux capabilities, network access, file permissions, etc.  AppArmor can help you to run a more secure deployment by restricting what containers are allowed to do, and/or provide better auditing through system logs. It is important to keep in mind that AppArmor is not a full exploit prevention mechanism, but it can reduce the abilities of a process inside a container that can limit further damage.  GKE nodes running Ubuntu and COS or COS_CONTAINERD have AppArmor support automatically enabled, but Kubernetes deployments must opt-in to be able to use AppArmor pods when they are run."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[].metadata | \"(.namespace)/(.name): (.annotations)\"' | grep -v apparmor` to find the pods that do not specify an apparmor profile in their annotations."], ["remediation", "\nFor all non-kube-system deployments/statefulsets, annotate the pod specification with \"container.apparmor.security.beta.kubernetes.io/<container_name>: \"runtime/default\" for each container in the pod specification.  This will enable the default AppArmor profile if the container is not running as a \"privileged\" container and afford protection against sensitive endpoints in /proc and /sys."], ["refs", "[{\"text\":\"Kubernetes AppArmor\",\"url\":\"https://kubernetes.io/docs/tutorials/clusters/apparmor/\",\"ref\":\"link\"},{\"text\":\"Docker AppArmor\",\"url\":\"https://docs.docker.com/engine/security/apparmor/\",\"ref\":\"link\"},{\"text\":\"Default AppArmor Profile\",\"url\":\"https://github.com/moby/moby/blob/master/profiles/apparmor/template.go\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-3\",\"DE.CM-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.609702"], ["id", 70]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d363bc20-2c74-582a-9bfd-8ac5bc228dbd"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d363bc20-2c74-582a-9bfd-8ac5bc228dbd"], ["created_at", "2020-10-07 21:57:58.620380"], ["updated_at", "2020-10-07 21:57:58.620380"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 71]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 71], ["created_at", "2020-10-07 21:57:58.630917"], ["updated_at", "2020-10-07 21:57:58.630917"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-83"], ["title", "Seccomp profiles are not implemented"], ["description", "Seccomp profiles define which system calls should be allowed or blocked, and the container runtime will apply then at container start time so the kernel can enforce it. Once applied, you are effectively decreasing your attack surface and limiting the container processes from making privileged syscalls in the event of a container compromise."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[].metadata | \"(.namespace)/(.name): (.annotations)\"' | grep -v seccomp` to find the pods that do not specify a seccomp profile in their annotations."], ["remediation", "\nFor all non-kube-system deployments/statefulsets, annotate the pod specification with \"container.seccomp.security.alpha.kubernetes.io/<container_name>: \"runtime/default\" for each container in the pod specification.  This will enable the default Seccomp profile if the container is not running as a \"privileged\" container and afford protection against dangerous syscalls."], ["refs", "[{\"text\":\"Kubernetes SecurityContext\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Seccomp\",\"url\":\"https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp\",\"ref\":\"link\"},{\"text\":\"Seccomp Examples\",\"url\":\"https://github.com/kubernetes/kubernetes/blob/release-1.4/docs/design/seccomp.md#examples\",\"ref\":\"link\"},{\"text\":\"Getting Started with Seccomp and Kubernetes\",\"url\":\"https://itnext.io/seccomp-in-kubernetes-part-i-7-things-you-should-know-before-you-even-start-97502ad6b6d6\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-3\",\"DE.CM-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.638202"], ["id", 71]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5ad73b30-7bdd-51a2-8f89-0354a88a0878"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5ad73b30-7bdd-51a2-8f89-0354a88a0878"], ["created_at", "2020-10-07 21:57:58.649909"], ["updated_at", "2020-10-07 21:57:58.649909"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 72]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 72], ["created_at", "2020-10-07 21:57:58.660736"], ["updated_at", "2020-10-07 21:57:58.660736"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-84"], ["title", "Namespaces do not have ResourceQuotas defined"], ["description", "ResourceQuotas can be applied to a Kubernetes namespace to ensure the resources contained inside the namespace do not exceed a desired quota.  Setting appropriate limits on each namespace can ensure workloads to not exhaust all available resources and cause an outage."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get resourcequotas --all-namespaces` and ensure each namespace has a ResourceQuota resource configured."], ["remediation", "\nIn each non-kube-system namespace, define a ResourceQuota that places limits on the maximum number of pods, CPU, and memory that can be used.  Ensure that every workload running in the namespace specifies a valid CPU and RAM requests and limits setting."], ["refs", "[{\"text\":\"Kubernetes Resource Quotas\",\"url\":\"https://kubernetes.io/docs/concepts/policy/resource-quotas/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.668534"], ["id", 72]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "870ac85c-d995-5c86-9a4f-f3b85491144b"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "870ac85c-d995-5c86-9a4f-f3b85491144b"], ["created_at", "2020-10-07 21:57:58.679929"], ["updated_at", "2020-10-07 21:57:58.679929"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 73]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 73], ["created_at", "2020-10-07 21:57:58.690660"], ["updated_at", "2020-10-07 21:57:58.690660"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-85"], ["title", "Namespaces do not have LimitRanges defined"], ["description", "LimitRanges can be applied to a Kubernetes namespace to ensure that all pods that fail to set a CPU and RAM requests and limits setting get an appropriate setting.  This ensures that pods are more accurately indicating to the Kubernetes scheduler how many actual resources they require, and that translates to nodes with more balanced workloads and avoids oversubscription situations that can cause outages."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get limitranges --all-namespaces` and ensure each namespace has a LimitRange resource configured."], ["remediation", "\nIn each non-kube-system namespace, define a LimitRange that places a minimum setting for CPU and RAM requests/limits on all workloads that fail to define their own setting."], ["refs", "[{\"text\":\"Kubernetes LimitRanges\",\"url\":\"https://kubernetes.io/docs/concepts/policy/limit-range/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.697171"], ["id", 73]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.8ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "ca95e423-1cd2-5349-b256-e66fcc5570b8"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "ca95e423-1cd2-5349-b256-e66fcc5570b8"], ["created_at", "2020-10-07 21:57:58.708428"], ["updated_at", "2020-10-07 21:57:58.708428"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 74]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 74], ["created_at", "2020-10-07 21:57:58.720521"], ["updated_at", "2020-10-07 21:57:58.720521"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.0ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-86"], ["title", "Malformed RBAC RoleBindings"], ["description", "A review of the ClusterRoleBindings and RoleBindings determined that there were incorrectly formed entries that are not enforcing a desired policy."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get clusterrolebinding -o yaml` and `kubectl get rolebinding --all-namespaces -o yaml` and review the output to ensure each has a `roleRef` and a `subjects` block with one or more entries each."], ["remediation", "\nReview each ClusterRoleBinding and Rolebinding for correctness and ensure that each one has valid `roleRef` and `subjects` blocks defined."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.726861"], ["id", 74]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (1.0ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "16aab1d2-3514-5377-b886-f9ff87be9f63"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "16aab1d2-3514-5377-b886-f9ff87be9f63"], ["created_at", "2020-10-07 21:57:58.739667"], ["updated_at", "2020-10-07 21:57:58.739667"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 75]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 75], ["created_at", "2020-10-07 21:57:58.751365"], ["updated_at", "2020-10-07 21:57:58.751365"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-87"], ["title", "Application-level encryption of secrets in etcd is not implemented"], ["description", "The Kubernetes API Server has the ability to leverage an external KMS provider for encryption and decryption of secrets stored inside etcd.  This provides additional protection in the event of unauthorized access to the disk or datastore where etcd maintains the cluster state.  It also ensures that the most sensitive data in etcd backups are not directly readable if stored in cloud storage buckets."], ["platform", "k8s"], ["impact", 2], ["validation", "\nFollow the instructions for your specific cloud provider's Kubernetes offering to verify that application level encryption of Kubernetes Secrets with KMS keys is configured."], ["remediation", "\nFollow the instructions for your specific cloud provider's Kubernetes offering to enable application level encryption of Kubernetes Secrets with KMS keys."], ["refs", "[{\"text\":\"Kubernetes KMS Provider\",\"url\":\"https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/\",\"ref\":\"link\"},{\"text\":\"GKE Application Secrets Encryption\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/encrypting-secrets\",\"ref\":\"link\"},{\"text\":\"EKS Application Secrets Encryption\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-1\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.757498"], ["id", 75]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "128b1a5e-3506-549b-a527-31a2527c976c"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.9ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "128b1a5e-3506-549b-a527-31a2527c976c"], ["created_at", "2020-10-07 21:57:58.766542"], ["updated_at", "2020-10-07 21:57:58.766542"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 76]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 76], ["created_at", "2020-10-07 21:57:58.780244"], ["updated_at", "2020-10-07 21:57:58.780244"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-88"], ["title", "Pod Disruption Budgets are not used for all critical deployments"], ["description", "Deployments with more than one replica require two critical elements to be able to handle a node failure or upgrade gracefully: Node anti-affinity to keep pods from being scheduled on the same node, and PodDisruptionBudgets (PDBs) which prevent the cluster from evicting pods unless enough other pods in that same deployment are healthy.  Without a PDB in place, a single node failure can temporarily evict too many pods and cause a service outage."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get pdb --all-namespaces` and ensure that a PDB exists for each `deployment` and `statefulset`."], ["remediation", "\nFor each workload, determine if it requires high availability for the overall service to function.  If so, configure the deployment to have at least two replicas, have node anti-affinity to tell the Kubernetes scheduler to place them on separate nodes, use a service in front of the deployments for a discoverable name to reach, and configure a PodDisruptionBudget (PDB) to ensure that either a certain percentage of replicas are available or a certain number are not unavailable."], ["refs", "[{\"text\":\"Kubernetes PodDisruptionBudgets\",\"url\":\"https://kubernetes.io/docs/tasks/run-application/configure-pdb/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.786724"], ["id", 76]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "cb315c62-1b51-5a5f-b447-73a4fa73e305"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "cb315c62-1b51-5a5f-b447-73a4fa73e305"], ["created_at", "2020-10-07 21:57:58.795371"], ["updated_at", "2020-10-07 21:57:58.795371"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 77]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 77], ["created_at", "2020-10-07 21:57:58.809352"], ["updated_at", "2020-10-07 21:57:58.809352"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-89"], ["title", "Container level malicious activity prevention/detection is not installed"], ["description", "In production Kubernetes clusters handling sensitive data, visibility into potentially malicious activity inside the containers is vital for maintaining positive control of the environment.  When a pod is compromised and actively being used to gain further access into other applications or data, it's important to be alerted immediately to be able to take defensive action to kill the pod, identify the vulnerability, fix the container, and redeploy as quickly as possible."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get daemonsets --all-namespaces -o wide` and ensure that each node has a healthy instance of the per-node agent running."], ["remediation", "\nConsider deploying a container security monitoring solution like Falco, Twistlock, or Aqua Security to monitor all nodes for container behavior that has high confidence of being malicious.  Configure it to alert to the primary on-call person for triage, and perform tuning to ensure it is not over-alerting with false positives."], ["refs", "[{\"text\":\"Sysdig\",\"url\":\"https://sysdig.com\",\"ref\":\"link\"},{\"text\":\"Falco\",\"url\":\"https://falco.org\",\"ref\":\"link\"},{\"text\":\"Palo Alto/Twistlock\",\"url\":\"https://twistlock.com\",\"ref\":\"link\"},{\"text\":\"Aqua Security\",\"url\":\"https://aquasecurity.com\",\"ref\":\"link\"},{\"ids\":[\"DE.CM-1\",\"DE.CM-4\",\"DE.CM-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.831854"], ["id", 77]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (1.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5f994da4-66b3-5b4b-a187-c67970bc112b"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5f994da4-66b3-5b4b-a187-c67970bc112b"], ["created_at", "2020-10-07 21:57:58.842760"], ["updated_at", "2020-10-07 21:57:58.842760"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 78]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 78], ["created_at", "2020-10-07 21:57:58.854685"], ["updated_at", "2020-10-07 21:57:58.854685"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-90"], ["title", "Automated Kubernetes resource backups are not configured"], ["description", "Backing up the contents of etcd is essential for backing up the desired state of the Kubernetes cluster, and it could be vital as part of a disaster recovery or security incident response plan to regain successful operation."], ["platform", "k8s"], ["impact", 9], ["validation", "\nManually validate that the backup location is being populated on the schedule desired with backup files clearly marked with the timestamp.  Ensure that the latest backup file is readable and contains the necessary data."], ["remediation", "\nInstall and configure the latest version of VMWare's Velero (formerly Heptio Ark) to export automated backups of all resources in etcd to a cloud storage bucket."], ["refs", "[{\"text\":\"VMWare Velero\",\"url\":\"https://github.com/vmware-tanzu/velero\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-4\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.861009"], ["id", 78]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.8ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3bc617f8-f8c7-5073-9d3d-ebf8cb55477a"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3bc617f8-f8c7-5073-9d3d-ebf8cb55477a"], ["created_at", "2020-10-07 21:57:58.873937"], ["updated_at", "2020-10-07 21:57:58.873937"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 79]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 79], ["created_at", "2020-10-07 21:57:58.886234"], ["updated_at", "2020-10-07 21:57:58.886234"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-91"], ["title", "Kubernetes resource backup/restore processes not exercised."], ["description", "A key step for recovering a breached cluster is having a full backup of etcd, but backups are not useful unless properly validated on a routine basis.  There are any number of misconfigurations that could result in the backup having incorrect or partial coverage, for example."], ["platform", "k8s"], ["impact", 9], ["validation", "\nEnsure the date/time of the last tested backup is within a desired timeframe (e.g. < 90 days)."], ["remediation", "\nPerform validation of the backups by testing the full restoration process on a routine basis, and configure alerts if the backup processes fail."], ["refs", "[{\"text\":\"VMWare Velero\",\"url\":\"https://github.com/vmware-tanzu/velero\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-10\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.893148"], ["id", 79]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "ed41f165-65e0-57e9-b43d-9aedd95d911a"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "ed41f165-65e0-57e9-b43d-9aedd95d911a"], ["created_at", "2020-10-07 21:57:58.905978"], ["updated_at", "2020-10-07 21:57:58.905978"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 80]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 80], ["created_at", "2020-10-07 21:57:58.918413"], ["updated_at", "2020-10-07 21:57:58.918413"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-92"], ["title", "Full operating system base images in use"], ["description", "When building container images, choosing a base image that is based on a \"full\" operating system has several downsides:\n\n* They are typically larger in size, and this increases bandwidth for pushing/pulling the image layers, storage costs, and image pull times during container startup.\n* They often contain a large number of libraries and packages that may not be used by the container application, and this can exponentially increase the effort spent tracking and patching vulnerabilities in the container.\n* They often include more administrative utilities by default such as `curl`, `wget`, and `nc` that an attacker can leverage if they get access to a running container.\n\nUsing a minimal base distribution with a small number of base packages can lead to smaller images with less vulnerabilities to patch.  Another approach is to use \"distroless\" images where the container is a \"scratch\" image with just a single compiled binary to be run."], ["platform", "k8s"], ["impact", 5], ["validation", "\nPerform a vulnerability scan of the last three minor releases of several base image types that your application could potentially use (e.g. `ubuntu` and `alpine`), and then scan the final images after your application is loaded.  Evaluate the results to find the balance between security, ease of maintenance, and application functionality."], ["remediation", "\nEnsure all container image build pipelines are configured to leverage a known set of approved base images that have minimal base packages and a track record for low vulnerability counts in the base layers.  Another approach to consider is \"Docker-Slim\" for minifying your final images based on profiling a running container and automatically stripping out unneeded components."], ["refs", "[{\"text\":\"Snyk Analysis of top base images\",\"url\":\"https://snyk.io/blog/the-top-two-most-popular-docker-base-images-each-have-over-500-vulnerabilities/\",\"ref\":\"link\"},{\"text\":\"Docker-Slim\",\"url\":\"https://github.com/docker-slim/docker-slim\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-12\",\"DE.CM-8\",\"PR.PT-3\",\"PR.IP-1\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.925134"], ["id", 80]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "cf0d95ac-b646-518d-aa8e-f216e45d7dab"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "cf0d95ac-b646-518d-aa8e-f216e45d7dab"], ["created_at", "2020-10-07 21:57:58.934860"], ["updated_at", "2020-10-07 21:57:58.934860"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 81]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 81], ["created_at", "2020-10-07 21:57:58.949906"], ["updated_at", "2020-10-07 21:57:58.949906"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-93"], ["title", "Large Number of Cluster Admins"], ["description", "The number of groups and/or users that have the RBAC permission \"cluster-admin\" should be limited to a small number of total users.  When the majority of users in a cluster are operating as administrators, it defeats the purpose for separation of duties, increases the chances for an error to cause an outage, and it violates the principle of least privilege."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get clusterrolebinding -o json | jq -r '.items[] | select((.roleRef.name==\"cluster-admin\") and .roleRef.kind==\"ClusterRole\") | .subjects[] | \"(.kind) (.namespace) (.name)\"'` and evaluate the listing to ensure it contains only the required cluster administrators."], ["remediation", "\nReduce the number of users with \"cluster-admin\" privileges to the smallest number feasible while still maintaining operational safety.  This is typically 3-6 users.  To ease administration, create groups and bind the permissions to the group."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\",\"PR.AT-2\",\"PR.IP-1\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.956870"], ["id", 81]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "6728d76f-de9a-50a2-bbee-33f4da917054"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "6728d76f-de9a-50a2-bbee-33f4da917054"], ["created_at", "2020-10-07 21:57:58.967370"], ["updated_at", "2020-10-07 21:57:58.967370"]]
  [1m[35m (1.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 82]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 82], ["created_at", "2020-10-07 21:57:58.980792"], ["updated_at", "2020-10-07 21:57:58.980792"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-94"], ["title", "Ensure the Kubernetes Dashboard is not present"], ["description", "While the Kubernetes dashboard is not inherently insecure on its own, it is often coupled with a misconfiguration of RBAC permissions that can unintentionally overgrant access and is not commonly protected with `NetworkPolicies` preventing all pods from being able to reach it.  In increasingly rare circumstances, the Kubernetes dashboard is exposed publicly to the Internet."], ["platform", "k8s"], ["impact", 3], ["validation", "\nRunning `kubectl get pods --all-namespaces -l k8s-app=kubernetes-dashboard` should not return any pods."], ["remediation", "\nInstead of running a workload inside the cluster to display a UI, leverage the cloud provider's UI for listing/managing workloads or consider a tool such as Octant running on local systems.  Run `kubectl get pods --all-namespaces -l k8s-app=kubernetes-dashboard` to find pods part of deployments and use kubectl to delete those deployments."], ["refs", "[{\"text\":\"Kubernetes Dashboard\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:58.987847"], ["id", 82]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "b80127b9-8df6-5689-9449-18249a4e7c1f"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "b80127b9-8df6-5689-9449-18249a4e7c1f"], ["created_at", "2020-10-07 21:57:58.996285"], ["updated_at", "2020-10-07 21:57:58.996285"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 83]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 83], ["created_at", "2020-10-07 21:57:59.010124"], ["updated_at", "2020-10-07 21:57:59.010124"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-95"], ["title", "Unsupported Kubernetes Versions in use"], ["description", "The Kubernetes project is fast-moving and has historically released a minor version 3-4 times per year, and it maintains release branches for the three most recent minor releases (e.g. 1.18, 1.17, 1.16).  This means that the \"upstream\" Kubernetes project maintains security and bug fixes for a given minor release for about nine months.  When running on managed Kubernetes offerings like AKS, EKS, and GKE, the support policy is slightly different as there is a delay in validating and testing new minor releases before making them available to customers.  While it might be technically possible to be running an unsupported version, it means an upgrade is necessary to be able to get security and bug fixes, and managed providers may not be able to automatically patch your cluster on your behalf."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl version --short | grep \"^Server\"` to identify the version of the control plane."], ["remediation", "\nMaintain awareness of the latest releases relative to the current running versions.  Perform upgrade testing in a development/sandbox environment first to avoid API deprecation issues.  If using a cloud provider's managed offering, consider enabling automatic upgrades in development/sandbox environments to ease administration burden and to identify issues early.  Practice and perform upgrades routinely to ensure the process does not go stale by administrators and application owners."], ["refs", "[{\"text\":\"Kubernetes Version Support\",\"url\":\"https://kubernetes.io/docs/setup/release/version-skew-policy/\",\"ref\":\"link\"},{\"text\":\"GKE Versions\",\"url\":\"https://cloud.google.com/kubernetes-engine/versioning-and-upgrades\",\"ref\":\"link\"},{\"text\":\"EKS Versions\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/kubernetes-versions.html\",\"ref\":\"link\"},{\"text\":\"AKS Versions\",\"url\":\"https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.RA-1\",\"ID.SC-2\",\"PR.IP-1\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.018403"], ["id", 83]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "a40a1f40-0597-5ea5-b72e-005fbeea3ac6"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "a40a1f40-0597-5ea5-b72e-005fbeea3ac6"], ["created_at", "2020-10-07 21:57:59.026779"], ["updated_at", "2020-10-07 21:57:59.026779"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 84]]
  [1m[36mTag Load (1.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 84], ["created_at", "2020-10-07 21:57:59.042239"], ["updated_at", "2020-10-07 21:57:59.042239"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-96"], ["title", "Third party images should be validated for policy conformance before use"], ["description", "Container images that are not part of the default Kubernetes system components and are not owned or maintained by the organization are considered third-party images.  These images are often introduced via Helm Charts or Operators, and they should be evaluated with the same scrutiny as any base image with regards to packages, vulnerabilities, running as a non-root user, and more."], ["platform", "k8s"], ["impact", 5], ["validation", "\nIdentify images from third-party registries in use, perform vulnerability scans regularly, and validate that they follow your organization's security standards."], ["remediation", "\nIdentify container images that are not controlled by the organization and determine if their posture meets your organization's security baseline.  If they do not and the original Dockerfile and supporting assets are available in public source control, consider maintaining a \"fork\" of that image with the security modifications necessary.  Alternatively, consider submitting patches upstream to that project so that they can be automatically incorporated going forward.  Focus on containers that run as \"root\" and may need privileged access to the host first."], ["refs", "[{\"text\":\"Snyk Analysis of top base images\",\"url\":\"https://snyk.io/blog/the-top-two-most-popular-docker-base-images-each-have-over-500-vulnerabilities/\",\"ref\":\"link\"},{\"text\":\"Docker-Slim\",\"url\":\"https://github.com/docker-slim/docker-slim\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-12\",\"DE.CM-8\",\"PR.PT-3\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.048808"], ["id", 84]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "efb02cbe-f686-5e6c-b9bc-aa1fa5fee143"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "efb02cbe-f686-5e6c-b9bc-aa1fa5fee143"], ["created_at", "2020-10-07 21:57:59.058858"], ["updated_at", "2020-10-07 21:57:59.058858"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 85]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 85], ["created_at", "2020-10-07 21:57:59.070542"], ["updated_at", "2020-10-07 21:57:59.070542"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-97"], ["title", "Namespaces should be used to separate unrelated workloads"], ["description", "By default, user-managed resources will be placed in the `default` namespace.  This makes it difficult to properly define policies for RBAC permissions, service account usage, network policies, and more.  Creating dedicated namespaces and running workloads and supporting resources in each helps support proper API server permissions separation and network microsegmentation."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get all` in the `default`, `kube-public`, and if present, `kube-node-lease` namespaces.  There should only be the `kubernetes` service."], ["remediation", "\nCreate dedicated namespaces for each type of related workload, and migrate those resources into those namespaces.  Ensure that RBAC permissions are not granted at the cluster scope but per namespace for the application owners at each namespace level."], ["refs", "[{\"text\":\"Kubernetes Namespaces\",\"url\":\"https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.AC-5\",\"PR.IP-1\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.079909"], ["id", 85]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c89183b3-b5c8-57ef-af97-1d9df089335b"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c89183b3-b5c8-57ef-af97-1d9df089335b"], ["created_at", "2020-10-07 21:57:59.088791"], ["updated_at", "2020-10-07 21:57:59.088791"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 86]]
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 86], ["created_at", "2020-10-07 21:57:59.101638"], ["updated_at", "2020-10-07 21:57:59.101638"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 86], ["created_at", "2020-10-07 21:57:59.113809"], ["updated_at", "2020-10-07 21:57:59.113809"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (2.1ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-98"], ["title", "Workloads do not have dedicated Kubernetes Service Accounts"], ["description", "By default, pods that do not specify a service account have the \"default\" service account token for that namespace automatically mounted inside them.  This, by definition, becomes a shared credential that multiple workloads will use.  Similarly, workloads that do specify the same, non-default service account are also sharing credentials.  Multiple workloads sharing a service account credential makes it difficult to properly apply RBAC permissions following least privilege and also more difficult to identify which pod/deployment was responsible for an API call when reviewing audit logs during an incident."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods -o json -A | jq -r '.items[] | select(.spec.serviceAccountName!=null) | \"(.metadata.namespace)/(.metadata.name): (.spec.serviceAccountName)\"'` to help identify which pods are mapping service accounts and to see if any are shared across workloads.  For all workload namespaces, consider disabling the automounting of the \"default\" service account.  Finally, enforce the use of non-default service accounts via dynamic admission control (e.g. OPA/Gatekeeper)."], ["remediation", "\nEnsure all deployments, daemonsets, and statefulsets are only mounting a service account if necessary and ensure it is unique to that workload.  Typically, naming the deployment and the service account with the same prefix helps this process.  Also, consider configuring the namespace to prevent the default service account from being mounted."], ["refs", "[{\"text\":\"Default Mounting of Service Accounts\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\",\"PR.AC-6\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.120804"], ["id", 86]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "26577009-7e3b-5ba7-9c94-e9b8cb293075"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "26577009-7e3b-5ba7-9c94-e9b8cb293075"], ["created_at", "2020-10-07 21:57:59.150129"], ["updated_at", "2020-10-07 21:57:59.150129"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 87]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 87], ["created_at", "2020-10-07 21:57:59.160737"], ["updated_at", "2020-10-07 21:57:59.160737"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.1ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-99"], ["title", "Nodepools are not used to separate workloads of different resource profiles"], ["description", "While Kubernetes can manage workloads of different resource profiles on the same physical compute and network capacity, situations can occur where workloads can become \"noisy neighbors\" and compete for the same resources with other Pods on the same node.  Pods that run resource-intensive data processing jobs but are otherwise dormant are a good example.  Specifying inaccurate resource requests and limits can further exacerbate this issue as the scheduler may overcrowd the node."], ["platform", "k8s"], ["impact", 5], ["validation", "\nReview the resource usage of each type of workload and ensure workloads with \"bursty\" resource usage are placed on dedicated nodes.  `kubectl top nodes` and `kubectl top pods` can be helpful for point-in-time usage statistics, but observing workloads over 24-48 hrs is ideal."], ["remediation", "\nWorkloads that have variable resource needs should be physically separated from workloads with steady resource needs in terms of compute and network capacity.  The most common approach is to place a `taint` on a dedicated node pool/group and specify that `toleration` and node selector on the workloads that should only operate on that node pool.  In addition, ensure all workloads have accurate resource requests and limits assigned and that node pools/groups are configured to autoscale up to the total capacity plus 10-20% of headroom of the workloads configured to run on them."], ["refs", "[{\"text\":\"Node Selectors\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\",\"ref\":\"link\"},{\"text\":\"Taints and Tolerations\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.167440"], ["id", 87]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39a35933-b735-52f6-952d-f3903ce75ef6"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39a35933-b735-52f6-952d-f3903ce75ef6"], ["created_at", "2020-10-07 21:57:59.178349"], ["updated_at", "2020-10-07 21:57:59.178349"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 88]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 88], ["created_at", "2020-10-07 21:57:59.189199"], ["updated_at", "2020-10-07 21:57:59.189199"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-100"], ["title", "Secrets in Pod Environment Variables"], ["description", "Kubernetes pods can take statically defined environment variables, and those can often contain sensitive data like API keys and other credentials.  However, this exposes them to users and other workloads that interact with the API server who have the RBAC permission \"get pods\" in the cluster which is commonly a much wider audience than desired."], ["platform", "k8s"], ["impact", 7], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | select(.spec.containers[].env) | \"(.metadata.namespace)/(.metadata.name): (.spec.containers[].env[].value)\"'` and verify that no sensitive data is present."], ["remediation", "\nEnsure that no secret material is directly defined in Pod environment variable specifications.  Instead, store them in a Secret and use the secretKeyRef mechanism to reference them as Environment variables in the container at runtime."], ["refs", "[{\"text\":\"Kubernetes ENV Variables from Secret\",\"url\":\"https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#define-a-container-environment-variable-with-data-from-a-single-secret\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.196490"], ["id", 88]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d0031c18-5bd3-5fa2-9533-07a464e0aa6f"], ["LIMIT", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d0031c18-5bd3-5fa2-9533-07a464e0aa6f"], ["created_at", "2020-10-07 21:57:59.206704"], ["updated_at", "2020-10-07 21:57:59.206704"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 89]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 89], ["created_at", "2020-10-07 21:57:59.221510"], ["updated_at", "2020-10-07 21:57:59.221510"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-101"], ["title", "RBAC Roles/ClusterRoles use Wildcards"], ["description", "When defining `Roles` and `ClusterRoles` in Kubernetes RBAC, it's possible to specify a wildcard using a `*` for both verbs and resources to simplify the policy creation process.  However, the Kubernetes API can change in subtle ways over time, and new resources and/or verbs may be introduced.  If a policy expresses \"all resources\" using a `*` and a new version of Kubernetes exposes a sensitive new resource, it may now match.  The intent of the previous policy will have been altered and potentially to an undesired effect."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get roles --all-namespaces -o json | jq -r '.items[] | . as $role | .rules[] | select(((.resources!=null) and (.resources[] | contains(\"*\")) or ((.nonResourceURLs!=null) and (.nonResourceURLs[] | contains(\"*\")))) or select(.verbs[] | contains(\"*\"))) | $role.metadata.name' | sort -u` to identify all `Roles` that specify a `*` for either resources or verbs.  Run `kubectl get clusterroles -o json | jq -r '.items[] | . as $role | .rules[] | select(((.resources!=null) and (.resources[] | contains(\"*\")) or ((.nonResourceURLs!=null) and (.nonResourceURLs[] | contains(\"*\")))) or select(.verbs[] | contains(\"*\"))) | $role.metadata.name' | sort -u` for ClusterRoles."], ["remediation", "\nReview all `ClusterRoles` and `Roles` and ensure that all resources and verbs do not use the `*` declaration.  If they do, modify that policy to decleare the explicity resources and verbs instead."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.227859"], ["id", 89]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0fb4069a-689c-53e1-a159-95c40cb065e8"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0fb4069a-689c-53e1-a159-95c40cb065e8"], ["created_at", "2020-10-07 21:57:59.236630"], ["updated_at", "2020-10-07 21:57:59.236630"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 90]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 90], ["created_at", "2020-10-07 21:57:59.251810"], ["updated_at", "2020-10-07 21:57:59.251810"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-102"], ["title", "Pods are in an undesired state"], ["description", "Pods were identified with a current status that indicates a failure condition or an incorrect deployment configuration, and they should be corrected or removed."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -o json | jq -r '.items[] | select((.status.phase==\"Failed\") or select(.status.containerStatuses[].restartCount > 4)) | \"(.metadata.namespace)/(.metadata.name) -- Status: (.status.phase), High Restart Count: (.status.containerStatuses[].restartCount > 4)\"'` in each cluster to identify pods in an undesired state.  There should be none listed."], ["remediation", "\nFor each workload, identify the underlying cause of the failure condition.  It may need a correction to the container image, a pod specification adjustment, or the presence of a dependent resource such as a ConfigMap, a Secret, or a Persistent Volume.  Typically, the container logs (`kubectl logs`) and pod events (`kubectl describe pod) will provide the information needed to address the issue."], ["refs", "[{\"text\":\"Kubernetes Application Debugging\",\"url\":\"https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application-introspection/\",\"ref\":\"link\"},{\"text\":\"Kubernets Pod Lifecycle\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-5\",\"PR.PT-5\",\"DE.CM-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.259258"], ["id", 90]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "29b51317-7143-5795-817b-e36d1da89363"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "29b51317-7143-5795-817b-e36d1da89363"], ["created_at", "2020-10-07 21:57:59.269366"], ["updated_at", "2020-10-07 21:57:59.269366"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 91]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 91], ["created_at", "2020-10-07 21:57:59.283900"], ["updated_at", "2020-10-07 21:57:59.283900"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-103"], ["title", "Replicasets that are not part of Deployments in use"], ["description", "In all but the most custom use cases, ReplicaSets should only be used indirectly via a Deployment that manages it.  \"Bare\" ReplicaSets should be considered for migration to a full Deployment resource to take advantage of useful management features such as rolling update strategies, rollbacks, and garbage collection."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get rs --all-namespaces -o json | jq -r '.items[] | . as $rs | .metadata | select((.ownerReferences==null) or .ownerReferences[].kind!=\"Deployment\") | \"($rs.metadata.namespace)/($rs.metadata.name)\"'` and ensure there are no items listed."], ["remediation", "\nConsider redeploying the ReplicaSet as a Deployment resource."], ["refs", "[{\"text\":\"Kubernetes ReplicaSets\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Deployments\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.291824"], ["id", 91]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7b7f2133-9328-5767-8b43-3d5ac80c9192"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7b7f2133-9328-5767-8b43-3d5ac80c9192"], ["created_at", "2020-10-07 21:57:59.302444"], ["updated_at", "2020-10-07 21:57:59.302444"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 92]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 92], ["created_at", "2020-10-07 21:57:59.316784"], ["updated_at", "2020-10-07 21:57:59.316784"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-105"], ["title", "Deployments should have more than one desired replica"], ["description", "Deployments with only a single desired replica cannot maintain service during upgrades or node failures as there will always be a delay for the system to notice the pod is no longer running and when it can be scheduled on another node.  In conjunction with having a PodDisruptionBudget configured, having multiple replicas allows for continued availability of the workload during scheduled or unscheduled outages."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | select(.status.replicas==1) | \"(.metadata.namespace)/(.metadata.name)\"'` and ensure that all deployments listed can be unavailable for up to 10 minutes without harming the successful operation of the cluster or dependent workloads."], ["remediation", "\nConfigure the Deployment replica count to be 2 or greater, and ensure a PodDisruptionBudget is configured for that deployment that enforces an appropriate `minAvailable` constraint."], ["refs", "[{\"text\":\"Kubernetes PodDisruptionBudgets\",\"url\":\"https://kubernetes.io/docs/tasks/run-application/configure-pdb/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.323820"], ["id", 92]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "99976c03-eeca-5bba-90d4-fadeaa87c106"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "99976c03-eeca-5bba-90d4-fadeaa87c106"], ["created_at", "2020-10-07 21:57:59.333027"], ["updated_at", "2020-10-07 21:57:59.333027"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 93]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 93], ["created_at", "2020-10-07 21:57:59.347742"], ["updated_at", "2020-10-07 21:57:59.347742"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-106"], ["title", "Pods have a large TermintionGracePeriodSeconds set"], ["description", "When a Pod is told to exit, Kubernetes will wait `terminationGracePeriodSeconds` before sending a SIGKILL signal to the container process.  The default is 30 seconds, but it can and should be increased if the Pod requires extra time to finish processing work cleanly or to execute a PreStop Hook.  However, if the timeout is extended too far, this can cause long delays during node upgrades and rolling deployments."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods --all-namespaces -o json | jq -r '.items[] | select(.spec.terminationGracePeriodSeconds>299) | \"(.metadata.namespace)/(.metadata.name): (.spec.terminationGracePeriodSeconds)\"'` and consider the possibilities for reducing that timeout safely."], ["remediation", "\nIdentify workloads that have `terminationGracePeriodSeconds` set to 5 or more minutes and validate that they need that time.  If possible, engineer the workload to handle termination more quickly while still maintaining overall application state."], ["refs", "[{\"text\":\"Termination of Kubernetes Pods\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.354219"], ["id", 93]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "88560633-a807-54c7-ad3a-4719d665468f"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "88560633-a807-54c7-ad3a-4719d665468f"], ["created_at", "2020-10-07 21:57:59.363031"], ["updated_at", "2020-10-07 21:57:59.363031"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 94]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 94], ["created_at", "2020-10-07 21:57:59.376014"], ["updated_at", "2020-10-07 21:57:59.376014"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.2ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-107"], ["title", "Critical Workloads do not have Anti-Affinity Rules set"], ["description", "Deployments and Statefulsets that require a certain number of Pods running at all times to maintain service availability should be configured with anti-affinity rules to avoid situations where multiple replicas are scheduled on the same node or in a common failure zone.  Should that node or failure zone experience an outage, an unexpected service disruption could result."], ["platform", "k8s"], ["impact", 8], ["validation", "\nRun `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | select(.spec.template.spec.affinity==null) | \"(.metadata.namespace)/(.metadata.name)\"'` and determine if affinity or anti-affinity rules are necessary to help avoid suboptimal scheduling.  Run `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | select(.spec.template.spec.affinity==null) | \"(.metadata.namespace)/(.metadata.name)\"'` for statefulsets."], ["remediation", "\nReview all Deployments and Statefulsets for criticality and determine if additional guidance should be given to the scheduler in the form of affinity and/or anti-affinity rules.  Most commonly, this is either a \"hard\" or \"soft\" requirement to ensure only one Pod of a Deployment lands on the same node."], ["refs", "[{\"text\":\"Assigning Pods to Nodes\",\"url\":\"https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.391721"], ["id", 94]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2079b140-b95a-5c1a-b1df-a273809e5047"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2079b140-b95a-5c1a-b1df-a273809e5047"], ["created_at", "2020-10-07 21:57:59.409389"], ["updated_at", "2020-10-07 21:57:59.409389"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 95]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 95], ["created_at", "2020-10-07 21:57:59.425653"], ["updated_at", "2020-10-07 21:57:59.425653"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-108"], ["title", "Deployments/Statefulsets do not have minimum desired healthy"], ["description", "In a healthy cluster, all running pods should be active, and all Deployments and Statefulsets should have the desired number of active pods.  There are any number of reasons why the number of active replicas in a Deployment or Statefulset is not equal to the desired number, but the result is typically that the services being provided by the workload are degraded or even completely unavailable."], ["platform", "k8s"], ["impact", 8], ["validation", "\nRun `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | . as $wkl | .status.conditions[] | select((.type==\"Available\") and .status!=\"True\") | \"($wkl.metadata.namespace)/($wkl.metadata.name): (.message)\"'` to identify unhealthy workloads and investigate with `kubectl describe pod <podname>` how to alleviate the underlying issue. Run `kubectl get statefulsets --all-namespaces -o json | jq -r '.items[] | . as $wkl | .status.conditions[] | select((.type==\"Available\") and .status!=\"True\") | \"($wkl.metadata.namespace)/($wkl.metadata.name): (.message)\"'` for statefulsets."], ["remediation", "\nThe most common cause of this issue is due to insufficient cluster capacity to be able to successfully run the pod(s).  They will typically appear in the \"Pending\" state, and running `kubectl describe pod` will reveal the reason why the pod can't be scheduled.  That root cause should be addressed to allow the workload to continue operating normally.  For example, if a pod is \"Pending\" because there aren't enough CPU resources to satisfy the pods \"CPU request\", the cluster either needs additional nodes or larger nodes with greater CPU capacity."], ["refs", "[{\"text\":\"Kubernetes Deployments\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.432784"], ["id", 95]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (1.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f89d387b-a421-53a4-b5ea-142f243a4935"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f89d387b-a421-53a4-b5ea-142f243a4935"], ["created_at", "2020-10-07 21:57:59.443881"], ["updated_at", "2020-10-07 21:57:59.443881"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 96]]
  [1m[36mTag Load (12.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (3.9ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 96], ["created_at", "2020-10-07 21:57:59.482729"], ["updated_at", "2020-10-07 21:57:59.482729"]]
  [1m[35m (2.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-109"], ["title", "Services have fewer than two healthy Endpoints"], ["description", "Cluster services that refer to pods via label selectors and port mappings will results in having `endpoint` resources created.  A healthy `service` should have at least 2 valid endpoints at all times which indicates that multiple pods are alive and actively handling requests.  Having \"none\" is an indication of misconfiguraion or outage, and having just one endpoint indicates a potential for service disruption during upgrades or node failures."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `for ns in $(kubectl get ns -o custom-columns=NAME:.metadata.name); do for svc in $(kubectl get -n $ns svc -o custom-columns=NAME:.metadata.name --no-headers); do EP=\"$(kubectl get endpoints -n $ns $svc -o json 2> /dev/null)\";if [[ \"$?\" -ne 0 ]]; then echo \"$ns/$svc has 0 endpoints\"; else echo \"$EP\" | jq -r 'select((.subsets[].addresses | length) < 2) | \"(.metadata.namespace)/(.metadata.name) has fewer than 2 endpoints\"'; fi; done; done` to identify services with fewer than 2 healthy endpoints."], ["remediation", "\nReview all services in all namespaces for having at least two valid endpoints and address the misconfiguration or number of replicas as needed to ensure the correct number are active."], ["refs", "[{\"text\":\"Debugging Services\",\"url\":\"https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/#does-the-service-have-any-endpoints\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.503248"], ["id", 96]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c5d0ad1c-feaf-5997-9fdf-c5af4dcc7543"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c5d0ad1c-feaf-5997-9fdf-c5af4dcc7543"], ["created_at", "2020-10-07 21:57:59.517357"], ["updated_at", "2020-10-07 21:57:59.517357"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 97]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 97], ["created_at", "2020-10-07 21:57:59.536895"], ["updated_at", "2020-10-07 21:57:59.536895"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-110"], ["title", "Pods in the kube-system namespace should be configured to avoid eviction"], ["description", "Pods in the `kube-system` namespace should be assigned the \"system-cluster-critical\" or \"system-node-critical\" `priorityClassName` to designate that the cluster should evict other pods not critical to the cluster or node's operation first.  When a worker node runs out of resources, it evicts the lowest priority pods that would remedy the resource exhaustion first.  Setting a `priority` at or above 2 billion (2000000000) indicates that a specific workload is critical to the functionality of the cluster."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods -n kube-system -o json | jq -r '.items[] | select(.spec.priority < 2000000000) | \"(.metadata.namespace)/(.metadata.name): (.spec.priority)\"'` and ensure no items are listed."], ["remediation", "\nReview the specifications for the pods in the `kube-system` namespace and ensure it specifies a `priorityClassName` that has a numeric priority value above 2 billion."], ["refs", "[{\"text\":\"Pod Quality of Service\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/\",\"ref\":\"link\"},{\"text\":\"Out of Resource Handling\",\"url\":\"https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/\",\"ref\":\"link\"},{\"text\":\"Guaranteed Scheduling for Critical Pods\",\"url\":\"https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.547129"], ["id", 97]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "b259e239-3547-5930-9d17-b1dc60f3a2ec"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.0ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "b259e239-3547-5930-9d17-b1dc60f3a2ec"], ["created_at", "2020-10-07 21:57:59.561780"], ["updated_at", "2020-10-07 21:57:59.561780"]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 98]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 98], ["created_at", "2020-10-07 21:57:59.580432"], ["updated_at", "2020-10-07 21:57:59.580432"]]
  [1m[35m (1.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-111"], ["title", "Services specifications do not have the correct naming convention set"], ["description", "For the sake of clarity and current/future support for Istio service mesh, all port names in `service` definitions need to follow a convention to aid in proper protocol identification.  For example, a service exposes TCP port 443, but it's not clear to the service mesh if that is passing plain TCP, HTTP, HTTPS, TLS, or gRPC traffic.  Naming the port `tls` or `tls-foo` makes it clear what protocol is intended to pass through this service."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get svc -A -o json | jq -r '.items[] | . as $svc | .spec.ports[] | select(.name | test(\"^grpc|^http|^mongo|^mysql|^redis|^tcp|^tls|^udp\")|not) | \"($svc.metadata.namespace)/($svc.metadata.name): (.name)\"'` and ensure no items are listed."], ["remediation", "\nReview all the ports exposed by services and ensure they follow the <protocol>[-<suffix>] naming convention."], ["refs", "[{\"text\":\"Istio Service Naming Convention\",\"url\":\"https://istio.io/docs/reference/config/analysis/ist0118/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.589329"], ["id", 98]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "af258b39-ba3c-56cf-ab22-fc0f082f9fb0"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "af258b39-ba3c-56cf-ab22-fc0f082f9fb0"], ["created_at", "2020-10-07 21:57:59.603339"], ["updated_at", "2020-10-07 21:57:59.603339"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 99]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 99], ["created_at", "2020-10-07 21:57:59.622145"], ["updated_at", "2020-10-07 21:57:59.622145"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-112"], ["title", "Containers should have ImagePullPolicy set to Always"], ["description", "Pod specifications should explicitly set the `imagePullPolicy` to `Always` to ensure the correct version of the image is always being used.  This helps avoid issues where container image tags were overwritten in the container registry but the node uses its local cached version instead.  Note that the caching semantics of the underlying image provider make even imagePullPolicy: Always efficient. With Docker, for example, if the image already exists, the pull attempt is fast because all image layers are cached and no image download is needed."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods -A -o json | jq -r '.items[] | . as $pod | .spec.containers[] | select(.imagePullPolicy!=\"Always\") | \"($pod.metadata.namespace)/($pod.metadata.name): (.name) (.imagePullPolicy)\"'` and ensure no items are listed."], ["remediation", "\nReview all containers in pod specifications and ensure the `imagePullPolicy` setting is configured to be `Always`."], ["refs", "[{\"text\":\"Kubernetes Best Practices\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/overview/#container-images\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-5\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.628328"], ["id", 99]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f46f6fd4-1a4b-562d-934b-3ef8b9f07075"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f46f6fd4-1a4b-562d-934b-3ef8b9f07075"], ["created_at", "2020-10-07 21:57:59.637416"], ["updated_at", "2020-10-07 21:57:59.637416"]]
  [1m[35m (2.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 100]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.1ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 100], ["created_at", "2020-10-07 21:57:59.656770"], ["updated_at", "2020-10-07 21:57:59.656770"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.0ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-113"], ["title", "Containers should have no sensitive information in Command or Args specifications"], ["description", "Kubernetes pods can specify the `command` and `args` for a container to use at runtime, and those can often contain sensitive data like API keys and other credentials.  However, this exposes them to users and other workloads that interact with the API server who have the RBAC permission \"get pods\" in the cluster which is commonly a much wider audience than desired."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | . as $pod | .spec.containers[] | select((.command) or .args) | .command as $cmd | .args as $args | \"($pod.metadata.namespace)/($pod.metadata.name)[(.name)]: ($cmd) ($args)\"'` and review the output.  Ensure no secret material is present."], ["remediation", "\nEnsure that no secret material is directly defined in container `command` or `args` specifications.  Instead, store them in a Secret and use the secretKeyRef mechanism to reference them as files in the container at runtime."], ["refs", "[{\"text\":\"Kubernetes Container Command and Arguments\",\"url\":\"https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.666754"], ["id", 100]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d5adf736-690c-53dd-af10-67bc040f2db4"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d5adf736-690c-53dd-af10-67bc040f2db4"], ["created_at", "2020-10-07 21:57:59.681503"], ["updated_at", "2020-10-07 21:57:59.681503"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (3.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 101]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 101], ["created_at", "2020-10-07 21:57:59.698153"], ["updated_at", "2020-10-07 21:57:59.698153"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-114"], ["title", "All resources should have a standard set of labels for ownership and purpose"], ["description", "Kubernetes resources have a standard labeling mechanism that can take arbitrary key/value pairs, and this makes tagging resources with labels for ownership, environment, data sensitivity, and more straightforward.  In addition to being able to quickly understand the intent of a workload or resource, labels can be used in the definition of security policies.  As cluster resources grow, having a standard convention for labeling resources helps keep track of things and maintain flexible policies."], ["platform", "k8s"], ["impact", 3], ["validation", "\nRun `kubectl get all -A -o json | jq -r '.items[] | \"(.kind)/(.metadata.namespace)/(.metadata.name) (.metadata.labels | tostring)\"'` and ensure all resources contain the desired labels."], ["remediation", "\nEnsure that all resources created and updated contain appropriate values for a small number of labels that make sense for the organization.  Suggested labels are `owner`, `env`, `app`, and `data` for the team responsbile, the dev/stage/prod type, the name of the application, and the sensitivity of the data in the workload, respectively.  Enforcement can be done with OPA/Gatekeeper admission control."], ["refs", "[{\"text\":\"Kubernetes Labels\",\"url\":\"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper Sample Policy\",\"url\":\"https://github.com/open-policy-agent/gatekeeper/tree/master/library/general/requiredlabels\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.AM-5\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.705277"], ["id", 101]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.8ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8ed3cd97-4415-5024-9d9a-dab55cd0fe53"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8ed3cd97-4415-5024-9d9a-dab55cd0fe53"], ["created_at", "2020-10-07 21:57:59.720724"], ["updated_at", "2020-10-07 21:57:59.720724"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 102]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 102], ["created_at", "2020-10-07 21:57:59.744912"], ["updated_at", "2020-10-07 21:57:59.744912"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-115"], ["title", "Nodeport Services directly exposed"], ["description", "While Kubernetes supports exposing pods via a port on the underlying node from the TCP/30000-32768 range via the `NodePort` service type, it's not typically the desired approach.  Typically, clusters expose a shared set of load balancers and ingress controllers to handle external service exposure via standard APIs that handle path routing, logging, access control lists, and more.  `NodePort` services require opening uncommon TCP ports in the firewall and typicaly require tight coupling of worker node IPs to be used successfully, and that becomes problematic when nodes fail or when a scale event occurs."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get svc -A -o json | jq -r '.items[] | select(.spec.type==\"NodePort\") | \"(.metadata.namespace)/(.metadata.name): (.spec.type):(.spec.ports[].nodePort)\"'` and ensure that no items are listed."], ["remediation", "\nConvert `NodePort` services into type `LoadBalancer` or consider leveraging an ingress controller to expose the service on a specific hostname and port instead."], ["refs", "[{\"text\":\"NodePort Services\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/service/#nodeport\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.DS-5\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.753941"], ["id", 102]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "90ce3f57-138b-566e-a61e-77c95a9a243b"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "90ce3f57-138b-566e-a61e-77c95a9a243b"], ["created_at", "2020-10-07 21:57:59.763872"], ["updated_at", "2020-10-07 21:57:59.763872"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 103]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.9ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 103], ["created_at", "2020-10-07 21:57:59.777140"], ["updated_at", "2020-10-07 21:57:59.777140"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-116"], ["title", "Services should have ExternalTrafficPolicy set to Local to preserve source IP address"], ["description", "In certain cloud providers, service specifications can be set to the default of 'Cluster' or 'Local'.  Cluster obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading. Local preserves the client source IP and avoids a second hop for `LoadBalancer` and `NodePort` type services, but risks potentially imbalanced traffic spreading.  Preserving the client source IP is critical to being able to perform attribution if an attacker is probing or exploiting an exposed service."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get svc -A -o json | jq -r '.items[] | select(.spec.type!=\"ClusterIP\") | \"(.metadata.namespace)/(.metadata.name): (.spec.externalTrafficPolicy)\"'` and validate that no items are listed."], ["remediation", "\nIn GCP/GKE, ensure IP Aliasing is enabled on the subnet where the cluster is created and the cluster is configured to utilize those ranges.  In AWS, using the \"Network Load Balancer\" instead of the \"Elastic Load Balancer\" in combination with this setting, the source IP can be preserved."], ["refs", "[{\"text\":\"Preserving the Source IP\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-3\",\"PR.AC-3\",\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.787291"], ["id", 103]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (1.0ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "95220b3a-127b-5240-aece-35c61d8bc3f9"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "95220b3a-127b-5240-aece-35c61d8bc3f9"], ["created_at", "2020-10-07 21:57:59.801301"], ["updated_at", "2020-10-07 21:57:59.801301"]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 104]]
  [1m[36mTag Load (0.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 104], ["created_at", "2020-10-07 21:57:59.819447"], ["updated_at", "2020-10-07 21:57:59.819447"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-117"], ["title", "Ingresses should point to active services with multiple healthy endpoints"], ["description", "Ingress resources describe how to route traffic based on hostname and/or URI path to a desired service, and it's very easy to misconfigure an ingress configuration to point to an invalid service or an \"empty\" service."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `for entry in \"$( kubectl get ingress -A -o json | jq -r '.items[] | . as $svc | .spec | .. | .backend? | select(.!=null) | \"($svc.metadata.namespace) (.serviceName)\"')\"; do ns=\"$(echo $entry | awk '{print $1}')\"; svc=\"$(echo $entry | awk '{print $2}')\"; EP=\"$(kubectl get endpoints -n $ns $svc -o json 2> /dev/null)\"; if [[ \"$?\" -ne 0 ]]; then echo \"$ns/$svc has 0 endpoints\"; else echo \"$EP\" | jq -r 'select(.subsets) // \"(.metadata.namespace)/(.metadata.name) has fewer than 2 endpoints\"'; echo \"$EP\" | jq -r 'select(.subsets) | select((.subsets[].addresses | length) < 2) | \"(.metadata.namespace)/(.metadata.name) has fewer than 2 endpoints\"'; fi; done` and ensure that no services are listed."], ["remediation", "\nReview all ingress resource configurations, and ensure the `backend` configurations that point to a `service` are pointing to a service that exists and one that has healthy endpoints."], ["refs", "[{\"text\":\"Kubernetes Ingress\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/ingress/#the-ingress-resource\",\"ref\":\"link\"},{\"text\":\"Kubernetes Services\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/service/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.828901"], ["id", 104]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "de9455b1-f948-5a70-8645-cd9176125614"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "de9455b1-f948-5a70-8645-cd9176125614"], ["created_at", "2020-10-07 21:57:59.842193"], ["updated_at", "2020-10-07 21:57:59.842193"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 105]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 105], ["created_at", "2020-10-07 21:57:59.856551"], ["updated_at", "2020-10-07 21:57:59.856551"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-118"], ["title", "All Nodes are Ready and Schedulable"], ["description", "Healthy clusters running at optimal efficiency have all nodes in the \"Ready\" state and are actively receiving workloads.  Nodes that are not in the \"Ready\" state or are cordoned/unschedulable are incurring costs but are not contributing to the cluster's capacity."], ["platform", "k8s"], ["impact", 3], ["validation", "\nRun `kubectl get nodes -o json | jq -r '.items[] | . as $node | .status.conditions[] | select((.type==\"Ready\") and .status!=\"True\") | \"($node.metadata.name): (.message)\"'` and ensure no nodes are listed.  Also, run `kubectl get nodes -o json | jq -r '.items[] | . as $node | select(.spec.unschedulable==true) | \"($node.metadata.name): cordoned/unschedulable\"'` and validate no nodes are listed."], ["remediation", "\nRepair all unhealthy nodes, and migrate workloads off of cordoned nodes before removing nodes."], ["refs", "[{\"text\":\"Node Cordoning\",\"url\":\"https://kubernetes.io/docs/concepts/architecture/nodes/#manual-node-administration\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.862107"], ["id", 105]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (19.9ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7230ef0b-0924-509b-9b12-6c245add2d06"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7230ef0b-0924-509b-9b12-6c245add2d06"], ["created_at", "2020-10-07 21:57:59.898780"], ["updated_at", "2020-10-07 21:57:59.898780"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 106]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 106], ["created_at", "2020-10-07 21:57:59.912960"], ["updated_at", "2020-10-07 21:57:59.912960"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-119"], ["title", "All Nodes are running the identical OS, Image, and Version"], ["description", "To ensure consistent and reliable operation of the cluster and its workloads, the worker nodes should be running identical versions of the operating system image, kernel version, kube-proxy version, and kubelet version for each node pool or operating system type."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get nodes -o json | jq -r '.items[] | \"(.status.nodeInfo.containerRuntimeVersion)|(.status.nodeInfo.kernelVersion)|(.status.nodeInfo.kubeProxyVersion)|(.status.nodeInfo.kubeletVersion)|(.status.nodeInfo.osImage)\"' | wc -l` and ensure the output equals \"1\" to indicate that all nodes are identical.  Clusters that have multiple node pools or mixed operating system types should have one line count per nodepool or OS type."], ["remediation", "\nUpgrade all nodes of each node pool to a common version for each underlying component.  Mixed operating system clusters should have identical versions per operating system."], ["refs", "[{\"text\":\"Kubernetes Version Skew Support\",\"url\":\"https://kubernetes.io/docs/setup/release/version-skew-policy/\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\",\"PR.IP-1\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.919975"], ["id", 106]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f0521c23-989d-53f5-bd2f-c235b6b4abe3"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f0521c23-989d-53f5-bd2f-c235b6b4abe3"], ["created_at", "2020-10-07 21:57:59.928990"], ["updated_at", "2020-10-07 21:57:59.928990"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 107]]
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 107], ["created_at", "2020-10-07 21:57:59.943406"], ["updated_at", "2020-10-07 21:57:59.943406"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-120"], ["title", "All Nodes have > 20% capacity allocatable"], ["description", "Kubernetes can pack workloads tightly onto nodes for excellent resource efficiency, but overutilized nodes are more prone to exhausting available resources. This can cause other colocated applications to run more slowly or even cause the kubelet to become unhealthy and evict workloads.  In addition, clusters should always have at least one node's worth of excess capacity ready to gracefully handle workloads rescheduled due to node maintenance or evictions."], ["platform", "k8s"], ["impact", 7], ["validation", "\nRun `echo \"Node CPU Memory\"; kubectl top nodes --no-headers | awk '{print $1\" \"$3\" \"$5}'` and ensure that CPU and Memory are below 80% for all nodes."], ["remediation", "\nEnsure allocated capacity per node remains below 80%, and ensure that workloads are scheduled evenly across nodes.  Consider scaling the number of nodes up to ensure the total workload doesn't exceed 80% of the total cluster capacity."], ["refs", "[{\"text\":\"Kubernetes Metrics Server\",\"url\":\"https://kubernetes.io/docs/tasks/debug-application-cluster/resource-metrics-pipeline/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.951291"], ["id", 107]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5f226c37-de2c-56a0-8e19-3c94a23a9d7a"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5f226c37-de2c-56a0-8e19-3c94a23a9d7a"], ["created_at", "2020-10-07 21:57:59.960941"], ["updated_at", "2020-10-07 21:57:59.960941"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 108]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 108], ["created_at", "2020-10-07 21:57:59.973014"], ["updated_at", "2020-10-07 21:57:59.973014"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-121"], ["title", "All Nodes are spread evenly across availability zones"], ["description", "When running Kubernetes clusters on cloud providers, production clusters should have their nodes spread as evenly as possible across multiple availability-zones in a given region.  Coupled with anti-affinity rules on critical workloads and multi-zone aware persistent-volumes, it's possible to withstand a single availability-zone outage should one occur."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get nodes -ojson | jq -r '.items[].metadata | select(.annotations.\"failure-domain.beta.kubernetes.io/zone\") | \"(.name): (.annotations.\"failure-domain.beta.kubernetes.io/zone\")\"'` and validate there are multiple availability zones listed and an equal (or near equal) number of nodes in each."], ["remediation", "\nConfigure the node pool/groups to leverage multiple availability zones.  Three zones are recommended in most cases.  Most cloud providers have a configuration option for spreading nodes of the same group across multiple availability zones."], ["refs", "[{\"text\":\"Kubernetes Node Labels\",\"url\":\"https://kubernetes.io/docs/reference/kubernetes-api/labels-annotations-taints/#topologykubernetesiozone\",\"ref\":\"link\"},{\"text\":\"AKS Multiple AZ Node Groups\",\"url\":\"https://docs.microsoft.com/en-us/azure/aks/availability-zones#create-an-aks-cluster-across-availability-zones\",\"ref\":\"link\"},{\"text\":\"EKS Multiple AZ Node Pools\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/create-managed-node-group.html\",\"ref\":\"link\"},{\"text\":\"GKE Multiple AZ Node Pools\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/creating-a-regional-cluster\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:57:59.982408"], ["id", 108]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "390bbf33-bc2c-514d-a878-e1d17282157f"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "390bbf33-bc2c-514d-a878-e1d17282157f"], ["created_at", "2020-10-07 21:57:59.992714"], ["updated_at", "2020-10-07 21:57:59.992714"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 109]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 109], ["created_at", "2020-10-07 21:58:00.003502"], ["updated_at", "2020-10-07 21:58:00.003502"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-122"], ["title", "Local disk PersistentVolumes should not mount sensitive host paths"], ["description", "While pods can be configured to mount a directory of the underlying worker node's filesystem to \"escape\" from the container, another similar pathway is by manually creating a \"Local/HostPath\" persistent volume and mounting it into the pod.  PodSecurityPolicy has native controls for the former approach, but it cannot prevent the latter.  The approach requires RBAC permissions to either create or use a custom storageclass, manually create or use a custom persistent volume, and permissions to create pods, so it is less likely to be available to non-privileged users."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pv -o json | jq -r '.items[] | select(.spec.hostPath) | \"(.metadata.name): (.spec.hostPath.path)\"'` and `kubectl get pv -o json | jq -r '.items[] | select(.spec.local) | \"(.metadata.name): (.spec.local.path)\"'` and verify that no entries are listed."], ["remediation", "\nEnsure that permissions for creating custom storage classes are only granted to cluster admins, and review all storage classes and currently bound persistent volumes do not permit mounting sensitive paths on the underlying nodes in pod specifications.  Consider enforcing with a dynamic admission controller such as OPA/Gatekeeper."], ["refs", "[{\"text\":\"Kubernetes Local Persistent Volumes\",\"url\":\"https://kubernetes.io/docs/concepts/storage/volumes/#local\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:00.011985"], ["id", 109]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c578b676-324d-51fe-ac5c-2af5a73044d6"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c578b676-324d-51fe-ac5c-2af5a73044d6"], ["created_at", "2020-10-07 21:58:00.021545"], ["updated_at", "2020-10-07 21:58:00.021545"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 110]]
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 110], ["created_at", "2020-10-07 21:58:00.033882"], ["updated_at", "2020-10-07 21:58:00.033882"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-123"], ["title", "Only approved Mutating/ValidatingWebHookConfigurations in use"], ["description", "Mutating and Validating Webhooks (Webhooks) are powerful extensions to the API server request flow, and they are typically used for adding functionality to resources before they are persisted and for enforcing security policy by way of dynamic admission controllers.  Because they defer authorization to an arbitrary location and get a full copy of the request, they can potentially see sensitive information.  They also can introduce latency in the API requiest flow as the API server needs to get a response or wait for a timeout before allowing the request to proceed.  Therefore, their usage should be limited to the smallest number necessary."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get mutatingwebhookconfiguration -A -oyaml` and `kubectl get validatingwebhookconfiguration -A -oyaml` and ensure the listed entries are desired."], ["remediation", "\nReview the current configuration and ensure only the desired and authorized Webhooks are installed and that they are only watching the specific resourcesneeded."], ["refs", "[{\"text\":\"Dynamic Admission Control\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:00.041568"], ["id", 110]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "16bf3c73-d5c7-5f71-abc2-e440f81c761b"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "16bf3c73-d5c7-5f71-abc2-e440f81c761b"], ["created_at", "2020-10-07 21:58:00.051829"], ["updated_at", "2020-10-07 21:58:00.051829"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 111]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 111], ["created_at", "2020-10-07 21:58:00.062593"], ["updated_at", "2020-10-07 21:58:00.062593"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-124"], ["title", "PersistentVolumes should use cross-zone/Regional StorageClasses"], ["description", "Where possible, deployments and statefulsets that mount persistent volumes should be using storageclasses that support being mounted in multiple zones.  By default, cloud provider network attached storage disks are only available in a single zone.  Should a zone experience a failure or outage, that data cannot be remounted by a pod until a healthy node in that zone returns unless that disk is configured as a type that should be replicated automatically."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get storageclass -o json | jq -r '.items[]'` and review the storage classes available inside the cluster and their settings to see if regional support (vs single zone) is configured.  Then run `kubectl get deployments -A -o json | jq -r '.items[] | .spec.template.spec.volumes'` and `kubectl get sts -A -o json | jq -r '.items[] | .spec.template.spec.volumes'` to see which types of storageclass for persistent volumes are in use."], ["remediation", "\nIf supported, configure the storageclass to support multiple zones and ensure that all critical deployments and statefulsets are configured to use them."], ["refs", "[{\"text\":\"Kubernetes Persistent Volumes\",\"url\":\"https://kubernetes.io/docs/concepts/storage/volumes/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Storageclasses\",\"url\":\"https://kubernetes.io/docs/concepts/storage/storage-classes/\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:00.069611"], ["id", 111]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d62c8685-fcf8-5cec-941a-0c07c7db2eb6"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d62c8685-fcf8-5cec-941a-0c07c7db2eb6"], ["created_at", "2020-10-07 21:58:00.080004"], ["updated_at", "2020-10-07 21:58:00.080004"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 112]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 112], ["created_at", "2020-10-07 21:58:00.091334"], ["updated_at", "2020-10-07 21:58:00.091334"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-125"], ["title", "CronJobs/Jobs should be healthy"], ["description", "Jobs and CronJobs can often become unhealthy over time and may go unnoticed unless manually reviewed.  A common example is that of the VMWare Valero backup job to backup the contents of etcd to an external location like a cloud storage bucket.  Without that backup running successfully at a regular interval, the ability to restore the cluster to a recent state in a failure situation is compromised."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get job -A -ojson | jq -r '.items[] | select(.status.conditions) | select(.status.conditions[].type==\"Failed\" and .status.conditions[].status==\"True\") | \"(.metadata.namespace)/(.metadata.name) failed: (.status.conditions[].message)\"'` and `kubectl get cronjob -A -ojson | jq -r '.items[] | select(.status.conditions) | select(.status.conditions[].type==\"Failed\" and .status.conditions[].status==\"True\") | \"(.metadata.namespace)/(.metadata.name) failed: (.status.conditions[].message)\"'` and ensure no entries are listed."], ["remediation", "\nManually examine all CronJobs and Jobs resources for a successful execution history and resolve any issues identified.  If the Job is no longer needed, remove it."], ["refs", "[{\"text\":\"Kubernetes Jobs\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:00.097945"], ["id", 112]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0991c5c8-2e42-5237-a66b-c0b7ad84317d"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0991c5c8-2e42-5237-a66b-c0b7ad84317d"], ["created_at", "2020-10-07 21:58:00.109474"], ["updated_at", "2020-10-07 21:58:00.109474"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 113]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 113], ["created_at", "2020-10-07 21:58:00.122409"], ["updated_at", "2020-10-07 21:58:00.122409"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-126"], ["title", "Nodes should have only one valid Certificate Signing Request"], ["description", "Some Kubernetes clusters initially provision their nodes using \"bootstrap\" credentials that are just used to create and issue a certificate signing request via the Kubernetes API for a certificate keypair to be used by that node's kubelet process.  This should be a one-time event, but it may be possible for an attacker that has compromised a worker node to generate a second keypair and impersonate the kubelet.  This process would leave traces by way of the API server having more than one valid CSR entry for that node."], ["platform", "k8s"], ["impact", 3], ["validation", "\nThe output of `kubectl get nodes --no-headers | wc -l` and `kubectl get csr -A -o json | jq -r '.items[] | select(.spec.groups) | select(.spec.groups[] | contains(\"system:nodes\")) | .spec.username' | sort -u | wc -l` should be identical, signaling that only one per node has been created."], ["remediation", "\nPeriodically inspect the certificate signing requests used by bootstrap credentials to ensure that only one has been created.  If more than one is present, validate the details of each one to see if it was potentially created by a malicious user."], ["refs", "[{\"text\":\"Kubernetes Certificate Signing Requests\",\"url\":\"https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/#create-a-certificate-signing-request\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-6\",\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:00.129678"], ["id", 113]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "da93b32f-bb47-51a9-b6ac-4ce2aa5936c5"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "da93b32f-bb47-51a9-b6ac-4ce2aa5936c5"], ["created_at", "2020-10-07 21:58:00.138480"], ["updated_at", "2020-10-07 21:58:00.138480"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 114]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 114], ["created_at", "2020-10-07 21:58:00.153869"], ["updated_at", "2020-10-07 21:58:00.153869"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-127"], ["title", "RBAC Roles/ClusterRoles should not grant permissions to system:anonymous"], ["description", "The built-in group named `system:anonymous` includes any user, group, or service account without a valid credential to the API server.  In earlier versions of Kubernetes, this \"meta\" group had a small number of permissions related to API discovery, but it is no longer intended for direct use.  This group should not be used to grant permissions to cluster subjects in nearly any legitimate situation, but it can occur by mistake and lead to unnecessary pathways to data leakage and privilege escalation."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get clusterrolebinding -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:anonymous\" and .kind==\"Group\") | $crb.roleRef.name'` and `kubectl get rolebinding -A -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:anonymous\" and .kind==\"Group\") | $crb.roleRef.name'` and validate that no entries are listed that would indicate non-standard permissions were granted."], ["remediation", "\nReview the permissions on the `system:anonymous` group and ensure that it has no granted permissions.  Remove or modify any ClusterRoleBinding that grants additional permissions, and grant permissions directly to authenticated users, groups, or service accounts instead."], ["refs", "[{\"text\":\"Kubernetes API Discovery Roles\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#discovery-roles\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-4\",\"PR.AC-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:00.161280"], ["id", 114]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7314bdf0-27f6-5102-a381-3bce416deb98"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7314bdf0-27f6-5102-a381-3bce416deb98"], ["created_at", "2020-10-07 21:58:00.169359"], ["updated_at", "2020-10-07 21:58:00.169359"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 115]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 115], ["created_at", "2020-10-07 21:58:00.181563"], ["updated_at", "2020-10-07 21:58:00.181563"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.9ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-128"], ["title", "RBAC Permissions for system:authenticated should not be elevated"], ["description", "The built-in group named `system:authenticated` includes any user, group, or service account with a valid credential to the API server.  This \"meta\" group is useful for providing a baseline set of permissions that all cluster users, groups, and service accounts need for API discovery purposes.  This group should not be used to grant additional permissions to cluster subjects beyond the defaults, but it can occur by mistake and lead to unnecessary pathways to data leakage and privilege escalation."], ["platform", "k8s"], ["impact", 8], ["validation", "\nRun `kubectl get clusterrolebinding -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:authenticated\" and .kind==\"Group\") | $crb.roleRef.name' | egrep -v \"system:basic-user|system:discovery|system:public-info-viewer\"` and `kubectl get rolebinding -A -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:authenticated\" and .kind==\"Group\") | $crb.roleRef.name' | egrep -v \"system:basic-user|system:discovery|system:public-info-viewer\"` to ensure no additional ClusterRoles or Roles have been granted to `system:authenticated`.  You can also run `kubectl auth can-i --list --as=system:authenticated` to see the current list of permissions."], ["remediation", "\nReview the permissions on the `system:authenticated` group and ensure that it is only bound to the baseline ClusterRoles: `system:basic-user`, `system:discovery`, and `system:public-info-viewer`.  Remove or modify any ClusterRoleBinding that grants additional permissions beyond these, and grant permissions directly to users, groups, or service accounts instead."], ["refs", "[{\"text\":\"Kubernetes API Discovery Roles\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#discovery-roles\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-4\",\"PR.AC-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:00.204152"], ["id", 115]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "fa458515-7fca-52fb-b080-bec839be4779"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "fa458515-7fca-52fb-b080-bec839be4779"], ["created_at", "2020-10-07 21:58:00.216647"], ["updated_at", "2020-10-07 21:58:00.216647"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 116]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 116], ["created_at", "2020-10-07 21:58:00.227379"], ["updated_at", "2020-10-07 21:58:00.227379"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-129"], ["title", "Tiller (Helm v2) should not be deployed"], ["description", "Helm version 1.x and 2.x rely on an in-cluster deployment named `Tiller` to handle lifecycle management of Kubernetes application bundles called `charts`.  The `Tiller` deployment is commonly granted elevated privileges to be able to carry out creation/deletion of resources contained inside `charts`, and it exposes a gRPC port on TCP/44134 without authentication or authorization, by default.  This combination was common, and it afforded a simple and direct path to escalation to cluster-admin from any pod in the cluster.  Now that Helm v3 no longer relies on an in-cluster component, `Tiller` is a signal that the cluster administrators have not upgraded to the more secure version."], ["platform", "k8s"], ["impact", 10], ["validation", "\nRun `kubectl get pods --all-namespaces -o name | grep tiller` and validate that no pods starting with the name `tiller-deploy-****` exist."], ["remediation", "\nRefer to https://helm.sh/docs/topics/v2_v3_migration/ for guidance on migrating away from `Tiller`.  For new cluster deployments, use Helm v3 and above going forward."], ["refs", "[{\"text\":\"Helm\",\"url\":\"https://helm.sh\",\"ref\":\"link\"},{\"text\":\"Tiller v2\",\"url\":\"https://helm.sh/docs/faq/#removal-of-tiller\",\"ref\":\"link\"},{\"text\":\"Helm Migration from v2 to v3\",\"url\":\"https://helm.sh/docs/topics/v2_v3_migration/\",\"ref\":\"link\"},{\"text\":\"Misusing Tiller\",\"url\":\"https://engineering.bitnami.com/articles/helm-security.html\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.DS-2\",\"PR.IP-1\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:00.234315"], ["id", 116]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.4ms)[0m  [1m[35mCREATE DATABASE "opencspm_development" ENCODING = 'unicode'[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE DATABASE "opencspm_test" ENCODING = 'unicode'[0m
  [1m[35m (0.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35m (0.3ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35m (0.3ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35mSQL (0.3ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (3.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "campaigns" CASCADE[0m
  [1m[35m (4.7ms)[0m  [1m[35mCREATE TABLE "campaigns" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "user_id" bigint NOT NULL, "filters" jsonb, "control_count" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_name" ON "campaigns"  ("name")[0m
  [1m[35m (2.8ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_organization_id" ON "campaigns"  ("organization_id")[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_user_id" ON "campaigns"  ("user_id")[0m
  [1m[35m (2.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "controls" CASCADE[0m
  [1m[35m (6.9ms)[0m  [1m[35mCREATE TABLE "controls" ("id" bigserial primary key, "guid" character varying, "name" character varying, "title" character varying, "description" text, "platform" character varying, "impact" integer, "validation" character varying, "remediation" character varying, "refs" jsonb, "status" integer DEFAULT 0, "resources_failed" integer DEFAULT 0, "resources_total" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_guid" ON "controls"  ("guid")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_name" ON "controls"  ("name")[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_platform" ON "controls"  ("platform")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_title" ON "controls"  ("title")[0m
  [1m[35m (2.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "identities" CASCADE[0m
  [1m[35m (5.5ms)[0m  [1m[35mCREATE TABLE "identities" ("id" bigserial primary key, "user_id" bigint NOT NULL, "provider" character varying, "uid" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_identities_on_user_id" ON "identities"  ("user_id")[0m
  [1m[35m (1.9ms)[0m  [1m[35mDROP TABLE IF EXISTS "issues" CASCADE[0m
  [1m[35m (4.5ms)[0m  [1m[35mCREATE TABLE "issues" ("id" bigserial primary key, "status" integer, "result_id" bigint NOT NULL, "resource_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_resource_id" ON "issues"  ("resource_id")[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_result_id" ON "issues"  ("result_id")[0m
  [1m[35m (2.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "jobs" CASCADE[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "jobs" ("id" bigserial primary key, "token" character varying, "status" integer, "issue_count" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (8.4ms)[0m  [1m[35mCREATE  INDEX  "index_jobs_on_token" ON "jobs"  ("token")[0m
  [1m[35m (1.9ms)[0m  [1m[35mDROP TABLE IF EXISTS "organizations" CASCADE[0m
  [1m[35m (8.2ms)[0m  [1m[35mCREATE TABLE "organizations" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE  INDEX  "index_organizations_on_name" ON "organizations"  ("name")[0m
  [1m[35m (1.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "profiles" CASCADE[0m
  [1m[35m (5.6ms)[0m  [1m[35mCREATE TABLE "profiles" ("id" bigserial primary key, "name" character varying, "author" character varying, "platform" character varying, "tags" jsonb, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "resources" CASCADE[0m
  [1m[35m (4.1ms)[0m  [1m[35mCREATE TABLE "resources" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE  INDEX  "index_resources_on_name" ON "resources"  ("name")[0m
  [1m[35m (1.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "results" CASCADE[0m
  [1m[35m (4.2ms)[0m  [1m[35mCREATE TABLE "results" ("id" bigserial primary key, "job_id" bigint NOT NULL, "data" jsonb, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL, "observed_at" timestamp(6))[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_control_id" ON "results"  ("control_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_job_id" ON "results"  ("job_id")[0m
  [1m[35m (1.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "roles" CASCADE[0m
  [1m[35m (6.1ms)[0m  [1m[35mCREATE TABLE "roles" ("id" bigserial primary key, "name" character varying, "resource_type" character varying, "resource_id" bigint, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_name_and_resource_type_and_resource_id" ON "roles"  ("name", "resource_type", "resource_id")[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_resource_type_and_resource_id" ON "roles"  ("resource_type", "resource_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "sources" CASCADE[0m
  [1m[35m (5.9ms)[0m  [1m[35mCREATE TABLE "sources" ("id" bigserial primary key, "name" character varying, "location" character varying, "status" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "taggings" CASCADE[0m
  [1m[35m (3.7ms)[0m  [1m[35mCREATE TABLE "taggings" ("id" bigserial primary key, "tag_id" bigint NOT NULL, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_control_id" ON "taggings"  ("control_id")[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_tag_id" ON "taggings"  ("tag_id")[0m
  [1m[35m (2.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "tags" CASCADE[0m
  [1m[35m (4.6ms)[0m  [1m[35mCREATE TABLE "tags" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "users" CASCADE[0m
  [1m[35m (4.4ms)[0m  [1m[35mCREATE TABLE "users" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "username" character varying DEFAULT '' NOT NULL, "password_digest" character varying DEFAULT '' NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_users_on_organization_id" ON "users"  ("organization_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE UNIQUE INDEX  "index_users_on_username" ON "users"  ("username")[0m
  [1m[35m (1.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "users_roles" CASCADE[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE TABLE "users_roles" ("user_id" bigint, "role_id" bigint)[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_role_id" ON "users_roles"  ("role_id")[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id_and_role_id" ON "users_roles"  ("user_id", "role_id")[0m
  [1m[35m (2.9ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id" ON "users_roles"  ("user_id")[0m
  [1m[35m (2.4ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_a74bb03c49"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (1.6ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_9eb8249bf2"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "identities" ADD CONSTRAINT "fk_rails_5373344100"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_41670766b9"
FOREIGN KEY ("resource_id")
  REFERENCES "resources" ("id")
[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_0da50c43eb"
FOREIGN KEY ("result_id")
  REFERENCES "results" ("id")
[0m
  [1m[35m (1.9ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_efb2ffdf17"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_66a308b2c3"
FOREIGN KEY ("job_id")
  REFERENCES "jobs" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_b9f82f696d"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.2ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_9fcd2e236b"
FOREIGN KEY ("tag_id")
  REFERENCES "tags" ("id")
[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "users" ADD CONSTRAINT "fk_rails_d7b9ff90af"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (0.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (0.6ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (0.7ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "schema_sha1"], ["LIMIT", 1]]
  [1m[35mSQL (0.4ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (3.0ms)[0m  [1m[35mDROP TABLE IF EXISTS "campaigns" CASCADE[0m
  [1m[35m (4.2ms)[0m  [1m[35mCREATE TABLE "campaigns" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "user_id" bigint NOT NULL, "filters" jsonb, "control_count" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_name" ON "campaigns"  ("name")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_organization_id" ON "campaigns"  ("organization_id")[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_user_id" ON "campaigns"  ("user_id")[0m
  [1m[35m (3.0ms)[0m  [1m[35mDROP TABLE IF EXISTS "controls" CASCADE[0m
  [1m[35m (4.7ms)[0m  [1m[35mCREATE TABLE "controls" ("id" bigserial primary key, "guid" character varying, "name" character varying, "title" character varying, "description" text, "platform" character varying, "impact" integer, "validation" character varying, "remediation" character varying, "refs" jsonb, "status" integer DEFAULT 0, "resources_failed" integer DEFAULT 0, "resources_total" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_guid" ON "controls"  ("guid")[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_name" ON "controls"  ("name")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_platform" ON "controls"  ("platform")[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_title" ON "controls"  ("title")[0m
  [1m[35m (1.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "identities" CASCADE[0m
  [1m[35m (5.7ms)[0m  [1m[35mCREATE TABLE "identities" ("id" bigserial primary key, "user_id" bigint NOT NULL, "provider" character varying, "uid" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_identities_on_user_id" ON "identities"  ("user_id")[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "issues" CASCADE[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "issues" ("id" bigserial primary key, "status" integer, "result_id" bigint NOT NULL, "resource_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_resource_id" ON "issues"  ("resource_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_result_id" ON "issues"  ("result_id")[0m
  [1m[35m (1.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "jobs" CASCADE[0m
  [1m[35m (5.1ms)[0m  [1m[35mCREATE TABLE "jobs" ("id" bigserial primary key, "token" character varying, "status" integer, "issue_count" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_jobs_on_token" ON "jobs"  ("token")[0m
  [1m[35m (1.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "organizations" CASCADE[0m
  [1m[35m (4.2ms)[0m  [1m[35mCREATE TABLE "organizations" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_organizations_on_name" ON "organizations"  ("name")[0m
  [1m[35m (1.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "profiles" CASCADE[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "profiles" ("id" bigserial primary key, "name" character varying, "author" character varying, "platform" character varying, "tags" jsonb, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "resources" CASCADE[0m
  [1m[35m (6.6ms)[0m  [1m[35mCREATE TABLE "resources" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_resources_on_name" ON "resources"  ("name")[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "results" CASCADE[0m
  [1m[35m (4.0ms)[0m  [1m[35mCREATE TABLE "results" ("id" bigserial primary key, "job_id" bigint NOT NULL, "data" jsonb, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL, "observed_at" timestamp(6))[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_control_id" ON "results"  ("control_id")[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_job_id" ON "results"  ("job_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "roles" CASCADE[0m
  [1m[35m (4.7ms)[0m  [1m[35mCREATE TABLE "roles" ("id" bigserial primary key, "name" character varying, "resource_type" character varying, "resource_id" bigint, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_name_and_resource_type_and_resource_id" ON "roles"  ("name", "resource_type", "resource_id")[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_resource_type_and_resource_id" ON "roles"  ("resource_type", "resource_id")[0m
  [1m[35m (1.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "sources" CASCADE[0m
  [1m[35m (4.3ms)[0m  [1m[35mCREATE TABLE "sources" ("id" bigserial primary key, "name" character varying, "location" character varying, "status" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "taggings" CASCADE[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE TABLE "taggings" ("id" bigserial primary key, "tag_id" bigint NOT NULL, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_control_id" ON "taggings"  ("control_id")[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_tag_id" ON "taggings"  ("tag_id")[0m
  [1m[35m (1.2ms)[0m  [1m[35mDROP TABLE IF EXISTS "tags" CASCADE[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "tags" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "users" CASCADE[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "users" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "username" character varying DEFAULT '' NOT NULL, "password_digest" character varying DEFAULT '' NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_users_on_organization_id" ON "users"  ("organization_id")[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE UNIQUE INDEX  "index_users_on_username" ON "users"  ("username")[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "users_roles" CASCADE[0m
  [1m[35m (1.3ms)[0m  [1m[35mCREATE TABLE "users_roles" ("user_id" bigint, "role_id" bigint)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_role_id" ON "users_roles"  ("role_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id_and_role_id" ON "users_roles"  ("user_id", "role_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id" ON "users_roles"  ("user_id")[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_a74bb03c49"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (1.2ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_9eb8249bf2"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.1ms)[0m  [1m[35mALTER TABLE "identities" ADD CONSTRAINT "fk_rails_5373344100"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.2ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_41670766b9"
FOREIGN KEY ("resource_id")
  REFERENCES "resources" ("id")
[0m
  [1m[35m (1.1ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_0da50c43eb"
FOREIGN KEY ("result_id")
  REFERENCES "results" ("id")
[0m
  [1m[35m (1.0ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_efb2ffdf17"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (2.0ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_66a308b2c3"
FOREIGN KEY ("job_id")
  REFERENCES "jobs" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_b9f82f696d"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.0ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_9fcd2e236b"
FOREIGN KEY ("tag_id")
  REFERENCES "tags" ("id")
[0m
  [1m[35m (0.9ms)[0m  [1m[35mALTER TABLE "users" ADD CONSTRAINT "fk_rails_d7b9ff90af"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mActiveRecord::InternalMetadata Update (0.4ms)[0m  [1m[33mUPDATE "ar_internal_metadata" SET "value" = $1, "updated_at" = $2 WHERE "ar_internal_metadata"."key" = $3[0m  [["value", "development"], ["updated_at", "2020-10-07 21:58:16.613399"], ["key", "environment"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mActiveRecord::InternalMetadata Update (0.4ms)[0m  [1m[33mUPDATE "ar_internal_metadata" SET "value" = $1, "updated_at" = $2 WHERE "ar_internal_metadata"."key" = $3[0m  [["value", "test"], ["updated_at", "2020-10-07 21:58:16.621683"], ["key", "environment"]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.5ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "schema_sha1"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mOrganization Load (0.4ms)[0m  [1m[34mSELECT "organizations".* FROM "organizations" WHERE "organizations"."name" = $1 LIMIT $2[0m  [["name", "Demo Organization"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mOrganization Create (8.9ms)[0m  [1m[32mINSERT INTO "organizations" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Demo Organization"], ["created_at", "2020-10-07 21:58:16.688900"], ["updated_at", "2020-10-07 21:58:16.688900"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mUser Load (0.8ms)[0m  [1m[34mSELECT "users".* FROM "users" WHERE "users"."username" = $1 LIMIT $2[0m  [["username", "demo"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mUser Create (1.4ms)[0m  [1m[32mINSERT INTO "users" ("name", "organization_id", "username", "password_digest", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["name", "Demo"], ["organization_id", 1], ["username", "demo"], ["password_digest", "$2a$12$wNSCX4hP2drgMMqrud4rzOFRN4uBxbsBvJtXv3LSHjdm0AA3uUDxu"], ["created_at", "2020-10-07 21:58:17.030099"], ["updated_at", "2020-10-07 21:58:17.030099"]]
  [1m[36mRole Load (0.5ms)[0m  [1m[34mSELECT "roles".* FROM "roles" INNER JOIN "users_roles" ON "roles"."id" = "users_roles"."role_id" WHERE "users_roles"."user_id" = $1[0m  [["user_id", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mRole Load (0.3ms)[0m  [1m[34mSELECT "roles".* FROM "roles" WHERE "roles"."name" = $1 AND "roles"."resource_type" IS NULL AND "roles"."resource_id" IS NULL ORDER BY "roles"."id" ASC LIMIT $2[0m  [["name", "user"], ["LIMIT", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mRole Create (0.8ms)[0m  [1m[32mINSERT INTO "roles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "user"], ["created_at", "2020-10-07 21:58:17.072853"], ["updated_at", "2020-10-07 21:58:17.072853"]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mRole Exists? (0.4ms)[0m  [1m[34mSELECT 1 AS one FROM "roles" WHERE "roles"."name" = $1 LIMIT $2[0m  [["name", "user"], ["LIMIT", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mUser::HABTM_Roles Create (0.5ms)[0m  [1m[32mINSERT INTO "users_roles" ("user_id", "role_id") VALUES ($1, $2)[0m  [["user_id", 1], ["role_id", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mSource Load (0.5ms)[0m  [1m[34mSELECT "sources".* FROM "sources" WHERE "sources"."name" = $1 LIMIT $2[0m  [["name", "Cloud Asset Inventory"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Create (0.5ms)[0m  [1m[32mINSERT INTO "sources" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Cloud Asset Inventory"], ["created_at", "2020-10-07 21:58:17.104458"], ["updated_at", "2020-10-07 21:58:17.104458"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Update (0.3ms)[0m  [1m[33mUPDATE "sources" SET "location" = $1, "status" = $2, "updated_at" = $3 WHERE "sources"."id" = $4[0m  [["location", "gcs://bucket-acme-8765/cai"], ["status", 1], ["updated_at", "2020-10-07 21:58:17.110488"], ["id", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mSource Load (0.4ms)[0m  [1m[34mSELECT "sources".* FROM "sources" WHERE "sources"."name" = $1 LIMIT $2[0m  [["name", "Kubernetes Sync Inventory"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Create (0.3ms)[0m  [1m[32mINSERT INTO "sources" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Kubernetes Sync Inventory"], ["created_at", "2020-10-07 21:58:17.117864"], ["updated_at", "2020-10-07 21:58:17.117864"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Update (0.3ms)[0m  [1m[33mUPDATE "sources" SET "location" = $1, "status" = $2, "updated_at" = $3 WHERE "sources"."id" = $4[0m  [["location", "gcs://bucket-acme-8765/k8s"], ["status", 0], ["updated_at", "2020-10-07 21:58:17.123340"], ["id", 2]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mSource Load (0.4ms)[0m  [1m[34mSELECT "sources".* FROM "sources" WHERE "sources"."name" = $1 LIMIT $2[0m  [["name", "Demo Kubernetes Inventory"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Create (0.3ms)[0m  [1m[32mINSERT INTO "sources" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Demo Kubernetes Inventory"], ["created_at", "2020-10-07 21:58:17.132731"], ["updated_at", "2020-10-07 21:58:17.132731"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Update (0.4ms)[0m  [1m[33mUPDATE "sources" SET "location" = $1, "status" = $2, "updated_at" = $3 WHERE "sources"."id" = $4[0m  [["location", "file://200924_cai.json"], ["status", 0], ["updated_at", "2020-10-07 21:58:17.138106"], ["id", 3]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.3ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Darkbit Best Practices"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.7ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Darkbit Best Practices"], ["created_at", "2020-10-07 21:58:17.157160"], ["updated_at", "2020-10-07 21:58:17.157160"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.4ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"db-bp-1\",\"gcp\"]"], ["updated_at", "2020-10-07 21:58:17.166828"], ["id", 1]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Google Cloud CIS 1.1"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.5ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Google Cloud CIS 1.1"], ["created_at", "2020-10-07 21:58:17.194471"], ["updated_at", "2020-10-07 21:58:17.194471"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.3ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"cis-1.1\",\"pci-3.4\",\"k8s-critical\"]"], ["updated_at", "2020-10-07 21:58:17.201700"], ["id", 2]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.2ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "GKE CIS 1.1"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.4ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "GKE CIS 1.1"], ["created_at", "2020-10-07 21:58:17.209442"], ["updated_at", "2020-10-07 21:58:17.209442"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.4ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Kubernetes"], ["tags", "[\"cis-1.1\",\"gke\",\"hipaa-6.2\",\"hipaa-7.5\"]"], ["updated_at", "2020-10-07 21:58:17.216004"], ["id", 3]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.2ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "PCI DSS"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.2ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "PCI DSS"], ["created_at", "2020-10-07 21:58:17.222869"], ["updated_at", "2020-10-07 21:58:17.222869"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (1.0ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"pci\",\"gcp\",\"gke\"]"], ["updated_at", "2020-10-07 21:58:17.230154"], ["id", 4]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.3ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "AWS Well Architected"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.3ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "AWS Well Architected"], ["created_at", "2020-10-07 21:58:17.240497"], ["updated_at", "2020-10-07 21:58:17.240497"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.4ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "AWS"], ["tags", "[\"well-architected\",\"aws-bp\"]"], ["updated_at", "2020-10-07 21:58:17.245390"], ["id", 5]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.3ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Public Resources - AWS"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.4ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Public Resources - AWS"], ["created_at", "2020-10-07 21:58:17.253250"], ["updated_at", "2020-10-07 21:58:17.253250"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.5ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "AWS"], ["tags", "[\"public-resources\",\"db-bp-2\"]"], ["updated_at", "2020-10-07 21:58:17.259641"], ["id", 6]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.5ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Public Resources - GCP"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.5ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Public Resources - GCP"], ["created_at", "2020-10-07 21:58:17.271684"], ["updated_at", "2020-10-07 21:58:17.271684"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.4ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"public-resources\",\"db-bg-3\",\"k8s-service-mesh\"]"], ["updated_at", "2020-10-07 21:58:17.279811"], ["id", 7]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.2ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "GKE Critical"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.2ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "GKE Critical"], ["created_at", "2020-10-07 21:58:17.286836"], ["updated_at", "2020-10-07 21:58:17.286836"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (1.0ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"gke-critical\"]"], ["updated_at", "2020-10-07 21:58:17.291747"], ["id", 8]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.5ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "K8s Visibility"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.4ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "K8s Visibility"], ["created_at", "2020-10-07 21:58:17.303725"], ["updated_at", "2020-10-07 21:58:17.303725"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.3ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Kubernetes"], ["tags", "[\"k8s-logging\"]"], ["updated_at", "2020-10-07 21:58:17.309461"], ["id", 9]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "77fe366c-b65a-5051-b211-a4ca2ec23662"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "77fe366c-b65a-5051-b211-a4ca2ec23662"], ["created_at", "2020-10-07 21:58:17.356387"], ["updated_at", "2020-10-07 21:58:17.356387"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 1]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTag Create (0.4ms)[0m  [1m[32mINSERT INTO "tags" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "dbc"], ["created_at", "2020-10-07 21:58:17.385436"], ["updated_at", "2020-10-07 21:58:17.385436"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 1], ["created_at", "2020-10-07 21:58:17.399633"], ["updated_at", "2020-10-07 21:58:17.399633"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-2"], ["title", "Centralized Secrets Management not in use"], ["description", "As infrastructure-as-code automation becomes widely used in an environment, it becomes possible to consistently separate out secret material from applications and code in a standard way. Once this happens, patterns in the code will emerge where the same secrets are stored and used in multiple places in the infrastructure.  Using a centralized, secure system for storing and accessing them that is able to operate in a cloud-native environment provides a means for centralized provisioning, auditing, rotation, and revocation of all secrets in the organization.  The damage due to credential theft and time available to an attacker with automatically rotated credentials is significantly decreased, and the likelihood for sensitive secret material to be exposed to additional persons or systems than are required is also diminished."], ["platform", "global"], ["impact", 5], ["validation", "\nReview all source control repositories, artifact creation processes, and deployment pipelines for the presence of static secrets in configuration files and ensure those values are not \"hardcoded\".  Ensure all new developers are trained on secure handling of secrets, and add secrets handling checks to all pull request/code reviews."], ["remediation", "\nConsider deploying a centralized system such as Hashicorp Vault or GCP Secrets Manager and working through all aspects of the infrastructure to remove statically defined secrets in favor of fetching them dynamically from a centrals secret store."], ["refs", "[{\"text\":\"Hashicorp Vault\",\"url\":\"https://www.hashicorp.com/products/vault/\",\"ref\":\"link\"},{\"text\":\"GCP Secrets Manager\",\"url\":\"https://cloud.google.com/secret-manager/docs\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.404533"], ["id", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f0258634-29df-5872-9cec-4a329d66f4ca"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f0258634-29df-5872-9cec-4a329d66f4ca"], ["created_at", "2020-10-07 21:58:17.411416"], ["updated_at", "2020-10-07 21:58:17.411416"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 2]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 2], ["created_at", "2020-10-07 21:58:17.420616"], ["updated_at", "2020-10-07 21:58:17.420616"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.1ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-3"], ["title", "Centralized Logging and Monitoring should be off-node and off-cluster"], ["description", "Without all systems, OS applications, Kubernetes components, and container applications logging and sending metrics to a centralized point outside of the primary cluster, the operations team will not be in a position to observe, triage, and accurately troubleshoot issues as they occur.  As a Security Analysis SaaS offering, system availability and reliable ingestion pipelines are vital to the value of the service.  Without a deep understanding of all critical aspects and logging tendencies of all applications and system components, a strong understanding of what falls inside the \"norm\" versus what is broken is difficult to diagnose when one component is not operating correctly."], ["platform", "global"], ["impact", 9], ["validation", "\nEnsure that all virtual machine instances and Kubernetes clusters are configured to ship logs and metrics to an appropriate, separate destination.  When new resources are being created, validate their logs and metrics are being correctly received."], ["remediation", "\nAll platform logs should be centrally collected, analyzed, and leveraged to understand system errors when they occur and how they affect operations.  All metrics should be centrally collected, charted, and leveraged to understand load, usage, and resource consumption as it relates to ingestion rates.  For example, all CPU/RAM/Network/Disk metrics should be collected for VMs and containers in addition to application-specific metrics such as logs per second, average log size, log processing time per \"hop\", etc.  Both performance metrics and log event metrics should be gathered outside the cluster they are originating from into a central point to be able to understand what \"healthy\" means for each and every system, Kubernetes component, and containerized deployment.  In GCP, the main point of log and metrics aggregation for all GKE clusters, GKE pods, GKE nodes, GCE instances, Firewall logs, VPC flow logs, and more is Stackdriver.  However, the log filtering and metrics visualization capabilities may not be as full-featured as commercial offerings, and this is a common point of third-party integration for GCP organizations."], ["refs", "[{\"text\":\"GCP Stackdriver\",\"url\":\"https://cloud.google.com/stackdriver#documentation\",\"ref\":\"link\"},{\"text\":\"Grafana Stackdriver Integration\",\"url\":\"https://grafana.com/docs/grafana/latest/features/datasources/stackdriver/\",\"ref\":\"link\"},{\"text\":\"Datadog\",\"url\":\"https://www.datadoghq.com/\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-2\",\"DE.AE-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.426579"], ["id", 2]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "a8e1c332-1fa8-5ea4-92df-56622a3b973c"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "a8e1c332-1fa8-5ea4-92df-56622a3b973c"], ["created_at", "2020-10-07 21:58:17.438012"], ["updated_at", "2020-10-07 21:58:17.438012"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 3]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 3], ["created_at", "2020-10-07 21:58:17.448879"], ["updated_at", "2020-10-07 21:58:17.448879"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.3ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-9"], ["title", "Project Lifecycle should be automated"], ["description", "When creating GCP projects, there are several steps that should be followed to ensure consistency and standardization of the base configuration of all projects.  Using automation with infrastructure-as-code tools like Terraform to manage the creation and management of all GCP projects greatly improves the ease of administration and enforces security best practices."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud projects list` and review projects for consistent application of initial project settings and following of conventions using `gcloud compute networks list`, `gcloud compute firewall-rules list`, and `gcloud iam service-accounts list/get-iam-policy`."], ["remediation", "\nUsing Terraform code stored in source control repositories, define and create all GCP projects using code.  Ensure that projects do not include the default networks and firewall rules, the default compute service account is not bound to \"Project Editor\", and incorporate any other standard settings for all projects to have.  The Cloud Foundation Toolkit from Google offers a pre-made Terraform module to make this easier."], ["refs", "[{\"text\":\"Terraform\",\"url\":\"https://www.terraform.io/\",\"ref\":\"link\"},{\"text\":\"Google Project Factory\",\"url\":\"https://github.com/terraform-google-modules/terraform-google-project-factory\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-2\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.454234"], ["id", 3]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2607af8b-07eb-5f45-8105-c8f0a68247c8"], ["LIMIT", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2607af8b-07eb-5f45-8105-c8f0a68247c8"], ["created_at", "2020-10-07 21:58:17.461776"], ["updated_at", "2020-10-07 21:58:17.461776"]]
  [1m[35m (6.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 4]]
  [1m[36mTag Load (2.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 4], ["created_at", "2020-10-07 21:58:17.504006"], ["updated_at", "2020-10-07 21:58:17.504006"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-10"], ["title", "Security Policies should be enforced using Organization Policies"], ["description", "GCP IAM grants users the ability to create or modify resources, but GCP Organization Policies help control how those resources are defined.  For example, a user might be able to create a GCE instance, but a \"constraint\" has been placed by an Organization Policy that prevents the instance from having an external IP address attached.  Organization Policies can be applied at the Org node, a GCP Folder, or at a GCP Project level, and they offer a way for GCP Administrators to delegate control over resources so long as they follow the desired constraints."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud beta resource-manager org-policies list --organization=ORGID` or `--folder=FOLDERID` or `--project=PROJECTID` to validate the organization policies are in the correct place in the hierarchy."], ["remediation", "\nThe following policies are recommended:\n\n* Prevent Instances from having external IPs\n* Skip Default Network creation during project creation\n* Trusted GCE Images enforcement\n* Serial Port Access\n* Service Account Key creation of user-managed keys\n\nUsing GCP Folders directly under the Organization node, apply the above constraints to a Folder.  For approved exemptions, places those resources inside Projects under a sibling Folder under the Organization node and apply the modified Organization Policy to that Folder.  It's recommended that proper testing be performed in a dedicated folder containing only test projects and resources to understand the behavior."], ["refs", "[{\"text\":\"GCP Organization Policies\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/overview\",\"ref\":\"link\"},{\"text\":\"Understanding Organization Policies\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/understanding-constraints\",\"ref\":\"link\"},{\"ids\":[\"ID.GV-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.510490"], ["id", 4]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f4a5c64d-5db9-57e3-aa23-569e995cdb54"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f4a5c64d-5db9-57e3-aa23-569e995cdb54"], ["created_at", "2020-10-07 21:58:17.519359"], ["updated_at", "2020-10-07 21:58:17.519359"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 5]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 5], ["created_at", "2020-10-07 21:58:17.531785"], ["updated_at", "2020-10-07 21:58:17.531785"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-11"], ["title", "Project names should follow a consistent naming convention"], ["description", "GCP Project names are visible in many places in the UI, the CLI, and in logs.  Consistently naming projects can help ease administration as the purpose of the project can be encoded in the name with some upfront planning."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud projects list` and look for projects that do not follow the defined naming convention as potential points of project creation that do not follow automated processes."], ["remediation", "\nCreate all GCP project IDs using a scheme such as: <org abbrev>-<environment>-<application or stack name> and also use the same string for the project name.  e.g. acme-dev-frontend or acme-prod-backendcluster.  Do not include sensitive information in project IDs.  Project IDs can have 4-30 lowercase letters, digits, or hyphens, must start with a lowercase letter, and must end with a letter or number."], ["refs", "[{\"text\":\"GCP Projects\",\"url\":\"https://cloud.google.com/resource-manager/docs/creating-managing-projects\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.538122"], ["id", 5]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5be7cee6-ee00-56ec-b271-4b2b6a6a3b34"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5be7cee6-ee00-56ec-b271-4b2b6a6a3b34"], ["created_at", "2020-10-07 21:58:17.545282"], ["updated_at", "2020-10-07 21:58:17.545282"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 6]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 6], ["created_at", "2020-10-07 21:58:17.554759"], ["updated_at", "2020-10-07 21:58:17.554759"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.9ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-12"], ["title", "Resource Structure does not follow the proper hierarchy aligned with environment separation goals"], ["description", "Folders and Projects should be implemented in a hierarchical pattern aligned with the ownership of teams and applications.  Projects should contain a single set of directly related resources and separated into different projects for each environment type (dev/stage/prod).\n\nAny change to the network, virtual machines, operating system, Kubernetes components, and applications running inside Kubernetes requires proper testing to ensure that change operates as desired.  Managing the risk of each change is best handled by creating dedicated environments using identical infrastructure-as-code techniques.  Without a \"dev\" or \"test\" environment, every change in the sole production cluster is inherently untested and a potential point for causing an outage."], ["platform", "gcp"], ["impact", 9], ["validation", "\nUse the GCP UI to view the folder and project structure.  Ensure the hierarchy and naming align with environment types and resources inside each project correspond to that environment only."], ["remediation", "\nUsing infrastructure-as-code tools such as Terraform, create identical environments for development, test/staging to complement the production environment.  Test all changes, upgrades, and fixes in the development environment, and perform those changes cleanly on the test/staging environment.  With a solid understanding of the changes and effects, planning and deploying to production becomes much less risky.  As a side effect of building environments with code, it provides confidence of full-environment reproducibility.\n\nUnder the organization node, create one or more folders that represents each service offering or \"stack\". e.g. \"SaaS\".  Under the \"SaaS\" folder, create folders for \"Dev\", \"Stage\", and \"Prod\".  Under each of those folders, create one or more projects to hold those resources that align with the environment.  By using folders, IAM permissions can be granted on the parent folder and they are inherited by the projects under them.  In addition, Stackdriver audit log sinks (exports) can be configured on a folder and apply to all logs from all projects underneath.\n\nMoving from one environment to 3 requires some changes to the centralized administrative access and monitoring/logging systems, so consider the Shared VPC approach VPC peering to help isolate identical copies of environments yet still manage and monitor them consistently."], ["refs", "[{\"text\":\"GCP Shared VPCs\",\"url\":\"https://cloud.google.com/vpc/docs/shared-vpc\",\"ref\":\"link\"},{\"text\":\"Terraform\",\"url\":\"https://www.terraform.io/\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.AM-3\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.563929"], ["id", 6]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e895db93-5bf2-55a0-9adc-17731c080bd8"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e895db93-5bf2-55a0-9adc-17731c080bd8"], ["created_at", "2020-10-07 21:58:17.582093"], ["updated_at", "2020-10-07 21:58:17.582093"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 7]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 7], ["created_at", "2020-10-07 21:58:17.591983"], ["updated_at", "2020-10-07 21:58:17.591983"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-14"], ["title", "IAM ServiceAccountUser granted at the project level"], ["description", "When creating a GCP resources that attaches a GCP service account, the calling user or service account must have the permission to \"use\" that service account. Otherwise, the ability to create a GCE instance with any service account attached would be a direct path to privilege escalation if at least one other service account in the project had higher permissions. This permission can be granted on a specific service account or at the project level.  Granting the permission directly on the service account resource permits \"use\" of just that service account.  Granting the permission at the project level permits the \"use\" of any service account in the project.  Even if the project does not currently have a highly privileged service account today, it might in the future, and that would inadvertently increase the power of this binding."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud beta projects get-iam-policy PROJECTID --flatten='bindings[]' --filter=bindings.role:iam.serviceAccountUser --format=\"csv[no-heading](bindings.members[])\"` for each project and ensure no results are displayed."], ["remediation", "\nRemove the permission at the project level and instead assign \"iam.serviceAccountUser\" on the small number of service accounts in the project that are necessary."], ["refs", "[{\"text\":\"Granting IAM Roles to Service Accounts\",\"url\":\"https://cloud.google.com/iam/docs/granting-roles-to-service-accounts\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\",\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.600750"], ["id", 7]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5a21d6de-3854-514c-a2ec-23f35fcd161f"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5a21d6de-3854-514c-a2ec-23f35fcd161f"], ["created_at", "2020-10-07 21:58:17.607755"], ["updated_at", "2020-10-07 21:58:17.607755"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 8]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 8], ["created_at", "2020-10-07 21:58:17.619165"], ["updated_at", "2020-10-07 21:58:17.619165"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTag Create (0.5ms)[0m  [1m[32mINSERT INTO "tags" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "k8s-logging"], ["created_at", "2020-10-07 21:58:17.629446"], ["updated_at", "2020-10-07 21:58:17.629446"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 8], ["created_at", "2020-10-07 21:58:17.637840"], ["updated_at", "2020-10-07 21:58:17.637840"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-15"], ["title", "Overuse of Primitive IAM Roles"], ["description", "GCP \"Primitive\" Roles of \"Project Owner\", \"Project Editor\", and \"Project Viewer\" are broad groupings of permissions that cross nearly every API in a project.  Assigning \"Project Owner\" is granting full control over that project.  Assigning \"Project Editor\" is granting read/write to nearly every resource in a project with exceptions for IAM management.  Assigning \"Project Viewer\" allows for reading nearly every resource in the project.  By their nature, they do not conform to the principle of least privilege.  Instead, binding predefined IAM Roles or creating custom IAM Roles is preferred."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud organizations get-iam-policy ORGIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/owner\" or .role==\"roles/editor\" or .role==\"roles/viewer\") | \"($role): (.members[])\"'` for the organization level.  For each folder, run `gcloud resource-manager folders get-iam-policy FOLDERIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/owner\" or .role==\"roles/editor\" or .role==\"roles/viewer\") | \"($role): (.members[])\"'`.  For each project, run `gcloud projects get-iam-policy PROJECTID --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/owner\" or .role==\"roles/editor\" or .role==\"roles/viewer\") | \"($role): (.members[])\"'` and validate that the minimum assignments necessary are present."], ["remediation", "\nUse the IAM Role recommendation information to gauge how many permissions are granted versus how many are in actual use over the past 90 days.  Consider implementing the predefined roles or custom roles it suggests and revoking the primitive role.  Considerations: At least one member of the project must have the Owner role (roles/owner). If the Owner role is revoked from all members, it might remove the ability to manage the project.  When using access controls that are separate from Cloud IAM, such as Cloud Storage access control lists (ACLs) or Kubernetes role-based access control (RBAC), make sure those access controls will work correctly after the primitive role is revoked."], ["refs", "[{\"text\":\"IAM Recommender Overview\",\"url\":\"https://cloud.google.com/iam/docs/recommender-overview\",\"ref\":\"link\"},{\"text\":\"Managing IAM Recommender\",\"url\":\"https://cloud.google.com/iam/docs/recommender-managing\",\"ref\":\"link\"},{\"text\":\"Using IAM Securely\",\"url\":\"https://cloud.google.com/iam/docs/using-iam-securely\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.643544"], ["id", 8]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7d7ec1dc-fdfb-5edd-91dd-cf09a6a8d987"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7d7ec1dc-fdfb-5edd-91dd-cf09a6a8d987"], ["created_at", "2020-10-07 21:58:17.651620"], ["updated_at", "2020-10-07 21:58:17.651620"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 9]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 9], ["created_at", "2020-10-07 21:58:17.663250"], ["updated_at", "2020-10-07 21:58:17.663250"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-18"], ["title", "Overlapping IAM Role Permissions"], ["description", "A project was found to have IAM Role assignments that fully overlap.  That is, one or more IAM Roles are assigned that have permissions fully covered by another IAM Role assigned.  This is a minor misconfiguration that should be resolved to clarify the explicit intent and aid in auditing permissions in the future."], ["platform", "gcp"], ["impact", 1], ["validation", "\nReview the permissions at the organization, folder, and project level, and look for combinations of primitive IAM Roles such as \"Project Owner\" or \"Project Editor\" assigned in combination with other custom or predefined IAM roles."], ["remediation", "\nReview the configuration of IAM permissions and consider consolidating the permissions down to the single IAM Role that encapsulates the permissions necessary to do the job role.  The most expeditious solution is to simply remove the smaller IAM Role.  A common example is a predefined role such as \"Compute Admin\" being fully encapsulated in a primitive role such as \"Project Owner\"."], ["refs", "[{\"text\":\"Using IAM Securely\",\"url\":\"https://cloud.google.com/iam/docs/using-iam-securely\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.672397"], ["id", 9]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e6504c23-cf7f-52aa-92a3-49e54ca7f332"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e6504c23-cf7f-52aa-92a3-49e54ca7f332"], ["created_at", "2020-10-07 21:58:17.681251"], ["updated_at", "2020-10-07 21:58:17.681251"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 10]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 10], ["created_at", "2020-10-07 21:58:17.691268"], ["updated_at", "2020-10-07 21:58:17.691268"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-19"], ["title", "Organization Admin assigned at the Folder or Project level"], ["description", "The predefined Organization Administrator IAM Role is meant to be assigned at the Organization level, not the Folder or Project level.  This is likely a misconfiguration.  However, it offers the `resourcemanager.projects.setIamPolicy` permission which allows modification of permissions on that Project including adding oneself or others as \"Project Owner\" and gaining full access to the Project and all resources contained inside it."], ["platform", "gcp"], ["impact", 3], ["validation", "\nFor each folder, run `gcloud resource-manager folders get-iam-policy FOLDERIDNUMBER --format=json `| jq -r 'select(.bindings) | .bindings[] | select(.role==\"roles/resourcemanager.organizationAdmin\") | .members[]'.  For each project, run `gcloud projects get-iam-policy PROJECTID --format=json | jq -r 'select(.bindings) | .bindings[] | select(.role==\"roles/resourcemanager.organizationAdmin\") | .members[]'` and validate that no entries are present."], ["remediation", "\nReview the need for Organization Administrator to be assigned at the Folder or Project level and instead grant the desired IAM Roles for those users."], ["refs", "[{\"text\":\"Organization Access Control\",\"url\":\"https://cloud.google.com/resource-manager/docs/access-control-org\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.699903"], ["id", 10]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "288c5376-739a-5da8-927d-b72a185f8439"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "288c5376-739a-5da8-927d-b72a185f8439"], ["created_at", "2020-10-07 21:58:17.708087"], ["updated_at", "2020-10-07 21:58:17.708087"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 11]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 11], ["created_at", "2020-10-07 21:58:17.718324"], ["updated_at", "2020-10-07 21:58:17.718324"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-20"], ["title", "Default Firewall Rules are present"], ["description", "The default firewalls in the default VPC permit inbound access to SSH, RDP, and ICMP from 0.0.0.0/0 and between all instances on the local subnet.  By default, GCE instances and GKE workers are created in the default subnet of the default VPC in a project and inherit this access for ease of use, but this means they are exposed via SSH or RDP to the entire Internet."], ["platform", "gcp"], ["impact", 8], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.name | test(\"^default-allow-\")) | .name' | grep -v 'default-allow-internal'` and ensure entries named `default-allow-icmp`, `default-allow-rdp`, and `default-allow-ssh` are not listed."], ["remediation", "\nDelete the default firewall rules in all projects and create new firewall rules explicitly with the principle of least privilege/access in mind."], ["refs", "[{\"text\":\"Default Firewall Rules\",\"url\":\"https://cloud.google.com/vpc/docs/firewalls#more_rules_default_vpc\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.724550"], ["id", 11]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3d56976e-3673-5c48-a501-33e0a2975038"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3d56976e-3673-5c48-a501-33e0a2975038"], ["created_at", "2020-10-07 21:58:17.733906"], ["updated_at", "2020-10-07 21:58:17.733906"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 12]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 12], ["created_at", "2020-10-07 21:58:17.744975"], ["updated_at", "2020-10-07 21:58:17.744975"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.3ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-21"], ["title", "Firewall logging should be enabled on all rules"], ["description", "Firewall rules do not enable logging of connections by default.  In regulated environments, firewall logging is a requirement in almost every situation to be able to understand when systems are accessed on certain ports or for evidence of which systems were accessed in the event of a security incident."], ["platform", "gcp"], ["impact", 9], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.logConfig.enable==false) | \"(.name)\"'` and ensure no entries are present."], ["remediation", "\nFor all TCP and UDP firewall rules, enable firewall logging on each rule.  Logs are sent automatically to Stackdriver for review for the default retention period of 30 days."], ["refs", "[{\"text\":\"Firewall Rules Logging\",\"url\":\"https://cloud.google.com/vpc/docs/firewall-rules-logging\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.CM-7\",\"DE.CM-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.750655"], ["id", 12]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8d492ba7-166e-5e64-8645-210040600af1"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8d492ba7-166e-5e64-8645-210040600af1"], ["created_at", "2020-10-07 21:58:17.757578"], ["updated_at", "2020-10-07 21:58:17.757578"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 13]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.1ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 13], ["created_at", "2020-10-07 21:58:17.770179"], ["updated_at", "2020-10-07 21:58:17.770179"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-22"], ["title", "VPC Flow logging should be enabled on all VPC Subnets"], ["description", "VPC flow logs record metadata about all traffic flowing in and out of a VPC. These logs are vital for auditing and review after security incidents to be able to create an accurate timeline of network events to go with application and Cloud API Audit logs."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute networks subnets list --format=json | jq -r '.[] | select(.logConfig.enable | not) | \"(.name) (.region)\"'` and ensure no entries are present."], ["remediation", "\nEnable VPC Flow logging on all VPCs with a 100% sample rate for production environments or those that hold sensitive data.  When directing to a GCS bucket, enable bucket versioning and optionally configure an object lifecycle policy to retain the data for the desired period only."], ["refs", "[{\"text\":\"Using VPC Flow Logs\",\"url\":\"https://cloud.google.com/vpc/docs/using-flow-logs\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.CM-7\",\"DE.CM-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.791323"], ["id", 13]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "09ca0a00-f921-54bf-ab6e-80690f9dd06d"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "09ca0a00-f921-54bf-ab6e-80690f9dd06d"], ["created_at", "2020-10-07 21:58:17.801914"], ["updated_at", "2020-10-07 21:58:17.801914"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 14]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 14], ["created_at", "2020-10-07 21:58:17.811739"], ["updated_at", "2020-10-07 21:58:17.811739"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-23"], ["title", "Firewall rules allows access to SSH TCP/22 from all hosts"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to administrative ports via SSH (TCP/22) should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 8], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"'` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `22`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires SSH access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets or to the bastion host(s) in the environment."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.818124"], ["id", 14]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39bd81b4-4925-5701-a5be-a2ee38b67166"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39bd81b4-4925-5701-a5be-a2ee38b67166"], ["created_at", "2020-10-07 21:58:17.825247"], ["updated_at", "2020-10-07 21:58:17.825247"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 15]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 15], ["created_at", "2020-10-07 21:58:17.838188"], ["updated_at", "2020-10-07 21:58:17.838188"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 15], ["created_at", "2020-10-07 21:58:17.845710"], ["updated_at", "2020-10-07 21:58:17.845710"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-24"], ["title", "Default deny egress rules should be configured"], ["description", "There are no egress firewall rules in place, so the implicit egress \"allow all\" firewall policy is in effect.  This allows any GCP resource to connect to any external destination on any port or protocol.  While this default configuration provides ease of use, it offers no protection for exfiltration of data, lateral movement, or network pivoting in the event of a compromise."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.destinationRanges) | select(.denied) | select(.direction==\"EGRESS\") | select(.destinationRanges[] | contains(\"0.0.0.0/0\")) | select(.denied[].IPProtocol==\"all\") | \"(.name)\"'` and ensure that an entry is present."], ["remediation", "\nConfigure an explicit deny egress firewall rule in each VPC of priority 65535, and configure explicit egress firewall rules that allow external access on the specific ports to specific destinations as needed.  When combined with firewall logging, this has the added benefit of detecting when applications are misconfigured or when potentially malicious activity is attempting to use non-approved ports."], ["refs", "[{\"text\":\"Default GCP Firewall Rules\",\"url\":\"https://cloud.google.com/vpc/docs/firewalls#default_firewall_rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.DS-5\",\"DE.AE-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.851623"], ["id", 15]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "27d34b2a-4b21-5a95-9707-30c32ade1045"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "27d34b2a-4b21-5a95-9707-30c32ade1045"], ["created_at", "2020-10-07 21:58:17.859680"], ["updated_at", "2020-10-07 21:58:17.859680"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 16]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 16], ["created_at", "2020-10-07 21:58:17.871480"], ["updated_at", "2020-10-07 21:58:17.871480"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-25"], ["title", "GCE Instances have public IPs"], ["description", "GCE Instances should not have public IP addresses assigned directly to them, and should be administered using their private IP and services running on them exposed only via load balancers.  This reduces the scope of attacks against vulnerable services and affords additional protection against denial-of-service."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud compute instances list --format=json | jq -r '.[] | . as $instance | .networkInterfaces[] | select(.accessConfigs) | .accessConfigs[] | select(.type==\"ONE_TO_ONE_NAT\") | \"($instance.name): (.natIP)\"'` and ensure that no entries with public IPs exist."], ["remediation", "\nConfigure all GCE Instances to not have public IP addresses assigned.  In GKE, enable private nodes.  For services running on these systems that should be exposed externally, configure a load balancer.  For remote administration, consider using the Identity-Aware Proxy service to create an SSH or RDP-over-TLS tunnel directly to the private IP of the instance."], ["refs", "[{\"text\":\"IAP Proxy for GCE\",\"url\":\"https://cloud.google.com/iap/docs/enabling-compute-howto\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.878109"], ["id", 16]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9352728c-93c6-55ee-a072-8c3132241cf9"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9352728c-93c6-55ee-a072-8c3132241cf9"], ["created_at", "2020-10-07 21:58:17.886096"], ["updated_at", "2020-10-07 21:58:17.886096"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 17]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 17], ["created_at", "2020-10-07 21:58:17.898513"], ["updated_at", "2020-10-07 21:58:17.898513"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-26"], ["title", "Default networks are present"], ["description", "Each project contains a default VPC/Network with default subnets in every region for ease of use, but the IP ranges used are likely not desired and may overlap between different projects.  This may cause issues in the future if VPC Peering is desired as the subnets will conflict and prevent routing."], ["platform", "gcp"], ["impact", 2], ["validation", "\nIn each project, run `gcloud compute networks list --format=json | jq -r 'select(.[]) | .[] | select(.name==\"default\") | .name'` and ensure no entries are listed."], ["remediation", "\nDelete the default VPC/Network and subnets in each project and instead create a new VPC and subnets according to the networking and IP address management needs of the organization to avoid overlap.  To ensure all projects created do not have the default VPC/Network and subnets created automatically, configure the constraints/compute.skipDefaultNetworkCreation organization policy at the organization node."], ["refs", "[{\"text\":\"Default VPC Network\",\"url\":\"https://cloud.google.com/vpc/docs/vpc#default-network\",\"ref\":\"link\"},{\"text\":\"Organization Policies\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/org-policy-constraints\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-3\",\"PR.AC-5\",\"PR.DS-7\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.905381"], ["id", 17]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1cc2e0e7-6dc9-5c4f-959e-3e60addad801"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1cc2e0e7-6dc9-5c4f-959e-3e60addad801"], ["created_at", "2020-10-07 21:58:17.913387"], ["updated_at", "2020-10-07 21:58:17.913387"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 18]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 18], ["created_at", "2020-10-07 21:58:17.922912"], ["updated_at", "2020-10-07 21:58:17.922912"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-27"], ["title", "User-managed GCP Service Account Keys older than 90 days"], ["description", "GCP Service Account Keys that are created by an administrator are known as \"user-managed\" keys.  Unless rotated by the user, they are static for their lifetime.  They should be rotated on a frequent basis to limit their active lifetime in the event the key material is compromised."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=ORGIDNUMBER --format=\"value(projectId)\"); do for sa in $(gcloud iam service-accounts list --format=\"value(email)\" --project=$project); do gcloud iam service-accounts keys list --iam-account $sa --project=$project --format=json | jq -r '.[] | select(.keyType==\"USER_MANAGED\") | \"(.name): (.validAfterTime) (.validBeforeTime)\"'; done; done` and review the validAfterTime and validBeforeTime values for each key to ensure they are not valid for longer than 90 days."], ["remediation", "\nGCP Service Accounts have native, dynamic key integrations to services like GCE, GKE, AppEngine, Cloud Functions, and more such that exporting a static key is only necessary for integrations from non-GCP services like Splunk, Sumologic, Datadog, etc that need access to GCP resources from outside the organization.  This removes the need for exporting keys for all but a small number of clearly defined use cases for those types of integrations.  Refactor GCP applications using static, exported service account keys to use the native integration.  For keys used by external services, rotate them every 90 days."], ["refs", "[{\"text\":\"Managing Service Account Keys\",\"url\":\"https://cloud.google.com/iam/docs/creating-managing-service-account-keys\",\"ref\":\"link\"},{\"text\":\"Security Health Analytics\",\"url\":\"https://cloud.google.com/security-command-center/docs/how-to-manage-security-health-analytics\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-3\",\"PR.AC-6\",\"PR.AC-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.928373"], ["id", 18]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.8ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f657ccb7-f778-5c52-9d83-a691e190e289"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f657ccb7-f778-5c52-9d83-a691e190e289"], ["created_at", "2020-10-07 21:58:17.952935"], ["updated_at", "2020-10-07 21:58:17.952935"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 19]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 19], ["created_at", "2020-10-07 21:58:17.973501"], ["updated_at", "2020-10-07 21:58:17.973501"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 19], ["created_at", "2020-10-07 21:58:17.987014"], ["updated_at", "2020-10-07 21:58:17.987014"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-28"], ["title", "GCP Projects should enable data access logging"], ["description", "GCP Audit logs automatically capture administrative activity logs for any creation or modification of resources via the GCP API.  e.g. \"create GCE instance\" or \"delete GCS bucket\".  By default, read requests to get/list resources and read/write requests that access user-provided data are not logged.  e.g. \"get or delete an object in a GCS bucket\".  These logs can and should be enabled on non-development projects to enable full capture of API activity necessary to support incident analysis and for meeting certain regulatory compliance requirements."], ["platform", "gcp"], ["impact", 8], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=ORGIDNUMBER --format=\"value(projectId)\"); do gcloud projects get-iam-policy $project --format=json | jq -r 'select(.auditConfigs)'; done` and ensure that it returns the following: `[\n      {\n        \"service\": \"allServices\",\n        \"auditLogConfigs\": [\n          { \"logType\": \"ADMIN_READ\" },\n          { \"logType\": \"DATA_READ\"  },\n          { \"logType\": \"DATA_WRITE\" },\n        ]\n      },\n    ]`."], ["remediation", "\nEnable \"Admin READ\" and \"Data READ and WRITE\" access logging for \"allServices\" at the organization level so that it applies to all downstream folders and projects.  Configure Stackdriver to export audit logs to a storage medium such as a GCS bucket and configure a lifecycle and retention policy to automatically move data to cheaper storage and to prune old data.  Caveat: Audit logs are often verbose and generate large volumes of log entries, and storing these in GCS buckets incurs an additional cost.  Use the exemption configuration to remove GCP internal service audit logs if necessary."], ["refs", "[{\"text\":\"Project Audit Logs\",\"url\":\"https://cloud.google.com/logging/docs/audit/understanding-audit-logs\",\"ref\":\"link\"},{\"text\":\"Configuring Data Access Logs\",\"url\":\"https://cloud.google.com/logging/docs/audit/configure-data-access\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:17.994392"], ["id", 19]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d2a48599-29d1-5e8a-a9e4-fb1fb35cfa75"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d2a48599-29d1-5e8a-a9e4-fb1fb35cfa75"], ["created_at", "2020-10-07 21:58:18.011991"], ["updated_at", "2020-10-07 21:58:18.011991"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 20]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (3.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 20], ["created_at", "2020-10-07 21:58:18.032657"], ["updated_at", "2020-10-07 21:58:18.032657"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-29"], ["title", "Cloud Security Command Center should be enabled"], ["description", "Security Command Center helps security teams gather data, identify threats, and act on them before they result in business damage or loss. It offers deep insight into application and data risk so that organizations can quickly mitigate threats to your their resources across and evaluate overall health. Security Command Center provides a single, centralized dashboard to:  - View and monitor an inventory of your cloud assets. - Scan storage systems for sensitive data. - Detect common web vulnerabilities and anomalous behavior. - Review access rights to your critical resources in your organization. - Apply recommended remediations to resolve vulnerabilities."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=ORGIDNUMBER --format=\"value(projectId)\"); do gcloud services list --project=$project | grep securitycenter; done` and ensure at least one entry is returned."], ["remediation", "\nLogged into GCP with roles/resourcemanager.organizationAdmin and roles/securitycenter.admin permissions, navigate to Security > Security Command Center in the UI and follow the prompts for enabling the service for all current and future projects.  Also, click on \"Security Health Analytics\" in the Dashboard and enable it.  Finally, navigate to Security > Threat Detection and enable Event Threat Detection to be able to receive events in Cloud Security Command Center."], ["refs", "[{\"text\":\"Cloud Security Command Center Quickstart\",\"url\":\"https://cloud.google.com/security-command-center/docs/quickstart-scc-setup\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.AM-5\",\"ID.GV-1\",\"ID.RA-1\",\"ID.RA-2\",\"ID.RA-3\",\"ID.RA-4\",\"ID.RA-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.043007"], ["id", 20]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5344a9bb-7f90-5b64-a466-111c6c59f09d"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5344a9bb-7f90-5b64-a466-111c6c59f09d"], ["created_at", "2020-10-07 21:58:18.053337"], ["updated_at", "2020-10-07 21:58:18.053337"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 21]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 21], ["created_at", "2020-10-07 21:58:18.066816"], ["updated_at", "2020-10-07 21:58:18.066816"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-30"], ["title", "CloudSQL Instances should have a private IP address"], ["description", "By default, CloudSQL instances are assigned a public IPv4 address, and the access list allows any source IP address to attempt to connect and authenticate to the database.  This facilitates development and ease of connectivity for troubleshooting, but it means an attacker can access the potentially sensitive data in the database without restriction if they obtain valid credentials."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.ipConfiguration.ipv4Enabled==true) | \"(.name) Public IP: (.settings.ipConfiguration.ipv4Enabled)\"'` and ensure no entries are listed."], ["remediation", "\nTo reduce the likelihood of an attacker to access the database service directly or to use stolen credentials from any source IP, the instance should be configured with a private IP address only. This should be configured during creation of the instance and a VPC peering relationship should be configured between the CloudSQL VPC and the VPCs where applications accessing the database reside."], ["refs", "[{\"text\":\"CloudSQL MySQL Private IP\",\"url\":\"https://cloud.google.com/sql/docs/mysql/configure-private-services-access\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Private IP\",\"url\":\"https://cloud.google.com/sql/docs/postgres/configure-private-services-access\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Private IP\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/configure-private-services-access\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-3\",\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.073853"], ["id", 21]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f033a7cd-69ce-53d9-8ca7-74579eb07a70"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f033a7cd-69ce-53d9-8ca7-74579eb07a70"], ["created_at", "2020-10-07 21:58:18.084803"], ["updated_at", "2020-10-07 21:58:18.084803"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (2.0ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 22]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 22], ["created_at", "2020-10-07 21:58:18.101576"], ["updated_at", "2020-10-07 21:58:18.101576"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-31"], ["title", "CloudSQL Instances should require SSL/TLS"], ["description", "By default, CloudSQL instances will accept both SSL/TLS and plaintext database connections.  As CloudSQL instances are provisioned inside a separate VPC within GCP that the user does not control, this means that database traffic will traverse a VPC peering connection without in-transit encryption.  Requiring SSL/TLS connections ensures that all connections are encrypted over the wire."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.ipConfiguration.requireSsl==null) | \"(.name) SSL: (.settings.ipConfiguration.requireSsl)\"'` and ensure no entries are listed."], ["remediation", "\nConfigure the instance during creation or while running to `require-ssl`.  For example, `gcloud sql instances patch [INSTANCE_NAME] --require-ssl`.  To allow applications to connect securely without changing application code, the cloudsql-proxy can be used.  It can handle setting up a localhost SSL proxy/tunnel and applications can be configured to connect to the database via that tunnel."], ["refs", "[{\"text\":\"CloudSQL MySQL Require SSL/TLS\",\"url\":\"https://cloud.google.com/sql/docs/mysql/configure-ssl-instance\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Require SSL/TLS\",\"url\":\"https://cloud.google.com/sql/docs/postgres/configure-ssl-instance\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Require SSL/TLS\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/configure-ssl-instance\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-7\",\"PR.DS-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.126653"], ["id", 22]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "6581aa85-27d2-5f66-95f5-b4f1f6b8a68f"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "6581aa85-27d2-5f66-95f5-b4f1f6b8a68f"], ["created_at", "2020-10-07 21:58:18.138657"], ["updated_at", "2020-10-07 21:58:18.138657"]]
  [1m[35m (2.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 23]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 23], ["created_at", "2020-10-07 21:58:18.155831"], ["updated_at", "2020-10-07 21:58:18.155831"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-32"], ["title", "Firewalls ingress to TCP/3306 from 0.0.0.0/0"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to database ports via TCP/3306 should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `3306`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires Database access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets where the applications and administrative systems reside."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.163951"], ["id", 23]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "647dfcff-8bf4-5215-94e1-765d9da48454"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "647dfcff-8bf4-5215-94e1-765d9da48454"], ["created_at", "2020-10-07 21:58:18.179193"], ["updated_at", "2020-10-07 21:58:18.179193"]]
  [1m[35m (2.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 24]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 24], ["created_at", "2020-10-07 21:58:18.193100"], ["updated_at", "2020-10-07 21:58:18.193100"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-33"], ["title", "Firewalls ingress to TCP/5432 from 0.0.0.0/0"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to database ports via TCP/5432 should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `5432`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires Database access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets where the applications and administrative systems reside."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.202168"], ["id", 24]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1dd1167e-7787-53b9-b32b-aa3cbfc49a11"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1dd1167e-7787-53b9-b32b-aa3cbfc49a11"], ["created_at", "2020-10-07 21:58:18.211430"], ["updated_at", "2020-10-07 21:58:18.211430"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 25]]
  [1m[36mTag Load (0.9ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 25], ["created_at", "2020-10-07 21:58:18.225717"], ["updated_at", "2020-10-07 21:58:18.225717"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-34"], ["title", "Firewalls ingress to TCP/3389 from 0.0.0.0/0"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to database ports via RDP (TCP/3389) should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `3389`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires Remote Desktop access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets or to the bastion host(s) in the environment."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.240938"], ["id", 25]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e738902b-746f-579b-981c-d36a054bf19f"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e738902b-746f-579b-981c-d36a054bf19f"], ["created_at", "2020-10-07 21:58:18.257232"], ["updated_at", "2020-10-07 21:58:18.257232"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 26]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.0ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 26], ["created_at", "2020-10-07 21:58:18.272324"], ["updated_at", "2020-10-07 21:58:18.272324"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-36"], ["title", "GCP usage within 30% of project quota limit"], ["description", "The GCP service enforces several quotas on all GCP projects to protect both service availability and the customer.  Without quotas, a compromised account would offer \"unlimited\" resources to mine bitcoin, or a single customer could attempt to exhaust all available resources of a given service type.  Quotas on Instance counts, Virtual CPUs, and Persistent Disks are commonly known, but there are several quotas that can easily catch users by surprise when attempting even modest scale-up activities.  As the process for increasing quota limits can take 1-3 days, it's best to request these increases well ahead of the need to prevent self-inflicted capacity based outages."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=1071234196403 --format=\"value(projectId)\"); do gcloud compute project-info describe --project $project --format=json | jq -r '.quotas[] | \"(.metric): (.usage) (.limit)\"'; done` and `gcloud compute regions list --format=json | jq -r '.[] | .name as $name | .quotas[] | \"($name) (.metric): (.usage) (.limit)\"'`.  Ensure that usage does not exceed 70% of the limit value for all quotas."], ["remediation", "\nReview the project-level and per-region quotas for all critical GCP projects on a routine basis.  For quotas that are within 30-50% of total capacity, evaluate the need for increasing those limits and use the GCP console to request them as needed."], ["refs", "[{\"text\":\"Managing GCP Quotas\",\"url\":\"https://cloud.google.com/compute/quotas\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"ID.AM-5\",\"ID.RA-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.287197"], ["id", 26]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7befc99c-0695-574a-b10a-af5c538a2171"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7befc99c-0695-574a-b10a-af5c538a2171"], ["created_at", "2020-10-07 21:58:18.296167"], ["updated_at", "2020-10-07 21:58:18.296167"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 27]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 27], ["created_at", "2020-10-07 21:58:18.310408"], ["updated_at", "2020-10-07 21:58:18.310408"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-39"], ["title", "Exported GCP Service Account Keys in use inside GCP/GKE resources"], ["description", "When application code needs to interact with the GCP APIs, it needs an identity and credentials.  The creation of a GCP Service Account represents the identity, and a GCP-managed keypair associated with that Service Account serves as the credentials used to generate session tokens needed during API interaction.  For applications that reside outside GCP, users can generate and export up to ten new Service Account Keys for a single Service Account.  These exported keys are then \"user-managed\" in that they don't expire or require any additional information to be used to authenticate as that Service Account using GCP APIs.  Until recently, it was common practice to manually export a Service Account Key in a JSON-file format and store that inside a GKE/Kubernetes Secret to support Pods having GCP API access.  However, these keys require manual rotation and replacement, and this makes automatic key rotation for compliance reasons or following a security incident extremely difficult."], ["platform", "gcp"], ["impact", 5], ["validation", "\nReview the presence of, age, and expiration of all user-managed/exported Service Account Keys in the account.  Ensure the description of the Service Account and/or Key provides an indication of where it is being used.  If GCP Organization Policies are enforcing, ensure the `iam.disableServiceAccountKeyCreation` control is applied to all but a small approved list of Folders and Projects."], ["remediation", "\nPeriodically review all Service Account Keys associated with Service Accounts, and ensure their usage is only in limited situations where there is no other option.  For GCE, attaching the Service Account to the instance is the preferred method as the credentials are short-lived and automatically rotated every hour.  For Pods in GKE, use the Workload Identity feature to map GKE/Kubernetes Service Accounts to GCP Service Accounts via IAM mapping and get similar behavior to the GCE instance metadata approach.  To prevent keys from being generated, consider enforcing the `iam.disableServiceAccountKeyCreation` GCP Organization Policy on all Folders/Projects that do not hold IAM responsibilities for external application authentication."], ["refs", "[{\"text\":\"GCP Service Accounts\",\"url\":\"https://cloud.google.com/iam/docs/understanding-service-accounts\",\"ref\":\"link\"},{\"text\":\"GCP Service Account Keys\",\"url\":\"https://cloud.google.com/iam/docs/creating-managing-service-account-keys\",\"ref\":\"link\"},{\"text\":\"GCP Organization Policy\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/restricting-service-accounts#disable_service_account_key_creation\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.318518"], ["id", 27]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9a58ed98-e24a-5f2a-a420-0b445ddb376d"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9a58ed98-e24a-5f2a-a420-0b445ddb376d"], ["created_at", "2020-10-07 21:58:18.331945"], ["updated_at", "2020-10-07 21:58:18.331945"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 28]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 28], ["created_at", "2020-10-07 21:58:18.343383"], ["updated_at", "2020-10-07 21:58:18.343383"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-40"], ["title", "Shared VPC projects contain non VPC related resources"], ["description", "GCP Projects that contain VPCs to be \"shared\" with other GCP Projects are also known as \"Host\" Projects, and the GCP Projects that are associated with the Host Projects are known as \"Resource\" Projects.  This approach maintains the networking configuration centrally with dedicated IAM permissions, and the ability to \"use\" the network is granted to each Service Project which is typically owned by other teams in the organization who own the instances and clusters.  Where possible, the Shared VPC project should retain its single purpose configuration and not hold resources unrelated to the VPC networking, routing, and firewall settings.  Resources outside of those purposes should be held in one or more Service Projects instead to maintain cleaner ownership and permissions isolation."], ["platform", "gcp"], ["impact", 3], ["validation", "\nReview all Host Projects and validate that no GCE instances, GKE clusters, GCS buckets, etc exist and that IAM permissions for the Project are only network-focused."], ["remediation", "\nIf resources exist in the Shared VPC project that are not networking related, they should be migrated to a dedicated Service Project.  Permissions to manage the VPC resources in the Shared VPC Project should be carefully reviewed to ensure they only grant access to perform network configuration tasks."], ["refs", "[{\"text\":\"GCP Shared VPCs\",\"url\":\"https://cloud.google.com/vpc/docs/shared-vpc\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.PT-4\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.349705"], ["id", 28]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "cb1f71c5-e10d-5e0e-9057-4b794d1cd588"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "cb1f71c5-e10d-5e0e-9057-4b794d1cd588"], ["created_at", "2020-10-07 21:58:18.358424"], ["updated_at", "2020-10-07 21:58:18.358424"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 29]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 29], ["created_at", "2020-10-07 21:58:18.373959"], ["updated_at", "2020-10-07 21:58:18.373959"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.9ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-41"], ["title", "Load Balancers should use a MODERN or RESTRICTED SSL policy"], ["description", "By default, Load Balancers use an SSL/TLS policy equivalent to the COMPATIBLE profile which supports a wide range of ciphers and TLS versions of varying security.  In nearly all use cases, the more stringent profiles should be used to ensure client connections only negotiate with strong ciphers and recent TLS versions.  For compliance-focused environments, the RESTRICTED policy should be used."], ["platform", "gcp"], ["impact", 3], ["validation", "\nRun `gcloud compute target-https-proxies list --format=json | jq -r '.[] | select(.sslPolicy | not) | \"(.name) (.selfLink)\"'` and `gcloud compute target-ssl-proxies list --format=json | jq -r '.[] | select(.sslPolicy | not) | \"(.name) (.selfLink)\"'` and ensure they do not return any entries."], ["remediation", "\nConfigure all Load Balancers to leverage the MODERN or RESTRICTED SSL policy or a CUSTOM SSL policy with equivalent enforcement of secure ciphers and TLS versions."], ["refs", "[{\"text\":\"GCP SSL Policies\",\"url\":\"https://cloud.google.com/load-balancing/docs/ssl-policies-concepts\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-2\",\"PR.PT-4\",\"PR.AC-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.381955"], ["id", 29]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0089ced9-0d18-552a-88de-b5d77c179e2d"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0089ced9-0d18-552a-88de-b5d77c179e2d"], ["created_at", "2020-10-07 21:58:18.391810"], ["updated_at", "2020-10-07 21:58:18.391810"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 30]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 30], ["created_at", "2020-10-07 21:58:18.407080"], ["updated_at", "2020-10-07 21:58:18.407080"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-42"], ["title", "Firewall rules allows all ports from all hosts"], ["description", "Firewall rules that allow all ports from any CIDR range are effectively disabling firewall protection to the attached service or system."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"'` and ensure no entries that permit `IPProtocol` of `all`."], ["remediation", "\nFor each firewall rule, review the application needs for protocols and ports, and reconfigure the firewall rule(s) to only grant access to those."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.413635"], ["id", 30]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2f3f76ca-7048-5b40-97a1-350869c51f0c"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2f3f76ca-7048-5b40-97a1-350869c51f0c"], ["created_at", "2020-10-07 21:58:18.426131"], ["updated_at", "2020-10-07 21:58:18.426131"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 31]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 31], ["created_at", "2020-10-07 21:58:18.439206"], ["updated_at", "2020-10-07 21:58:18.439206"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-43"], ["title", "GCS Bucket Logging should be enabled"], ["description", "GCS bucket logging helps maintain an audit trail of access that can be used in the event of a security incident.  Bucket logging is disabled by default, so any unauthorized access will go untraced unless this is explicitly enabled."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `for bucket in $(gsutil ls); do gsutil logging get $bucket; done | grep \"has no logging\"` and validate that no entries are present."], ["remediation", "\nEnable data access audit logs on all storage buckets that store data that requires auditable logging."], ["refs", "[{\"text\":\"GCS Audit Logs\",\"url\":\"https://cloud.google.com/storage/docs/audit-logs\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.446063"], ["id", 31]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9082de43-725d-5562-90a9-8204a5aba5c4"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9082de43-725d-5562-90a9-8204a5aba5c4"], ["created_at", "2020-10-07 21:58:18.453601"], ["updated_at", "2020-10-07 21:58:18.453601"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 32]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 32], ["created_at", "2020-10-07 21:58:18.479170"], ["updated_at", "2020-10-07 21:58:18.479170"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-44"], ["title", "GCS Buckets without object versioning enabled"], ["description", "GCS Buckets that store sensitive data should have object versioning enabled to help protect against the overwriting of objects or data loss in the event of a compromise.  A concrete example is a bucket that receives audit/access logs from other services.  Without object versioning, an attacker might be able to delete evidence of their activities.  With object versioning enabled, they won't be able to remove the original version of the log data."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `for bucket in $(gsutil ls); do gsutil versioning get $bucket; done | grep \"Suspended\"` and validate that no entries are present."], ["remediation", "\nEnable object versioning on all storage buckets that store data that requires integrity protection."], ["refs", "[{\"text\":\"GCS Object Versioning\",\"url\":\"https://cloud.google.com/storage/docs/object-versioning\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.484728"], ["id", 32]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8f62fb14-a782-5888-b0cb-3d5ee30b4bdd"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8f62fb14-a782-5888-b0cb-3d5ee30b4bdd"], ["created_at", "2020-10-07 21:58:18.496581"], ["updated_at", "2020-10-07 21:58:18.496581"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 33]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 33], ["created_at", "2020-10-07 21:58:18.509601"], ["updated_at", "2020-10-07 21:58:18.509601"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-45"], ["title", "Predefined GKE IAM Roles should be avoided"], ["description", "Access to the GKE Cluster API Server resources is controlled by a combination of IAM and in-cluster RBAC permissions.  If either grants access to the resource, access is allowed.  When using IAM permissions, access is granted to the permitted resources in all namespaces.  Using RBAC policies allows for granting more granular access to resources on a cluster-wide or per-namespace level and follows the principle of least privilege.  In this case, only IAM permissions are being used for allowing access via the \"Project Owner\" IAM Role, and this effectively grants full access to all resources in the cluster and \"root\" access to all GKE worker nodes."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud organizations get-iam-policy ORGIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/container.admin\" or .role==\"roles/container.developer\" or .role==\"roles/container.viewer\") | \"($role): (.members[])\"'` for the organization level.  For each folder, run `gcloud resource-manager folders get-iam-policy FOLDERIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/container.admin\" or .role==\"roles/container.developer\" or .role==\"roles/container.viewer\") | \"($role): (.members[])\"'`.  For each project, run `gcloud projects get-iam-policy PROJECTID --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/container.admin\" or .role==\"roles/container.developer\" or .role==\"roles/container.viewer\") | \"($role): (.members[])\"'` and validate that the minimum assignments necessary are present."], ["remediation", "\nThe recommended approach is to avoid using IAM permissions to grant access to GKE clusters with one exception: a custom IAM Role that only permits cluster users with the ability to download a kubeconfig file via the \"gcloud container clusters get-credentials\" API call.  All Kubernetes access should be granted inside the cluster using RBAC ClusterRoleBindings or per-namespace RoleBindings.  Create a custom IAM Role call \"Kubernetes API Access\" with the following permissions: - container.apiServices.get - container.apiServices.list - container.clusters.get - container.clusters.getCredentials  Create a security group with all members that need cluster access, and bind the \"Kubernetes API Access\" IAM Role to that group at the project where the cluster lives.  For each administrator, create a ClusterRoleBinding that grants that user the \"Cluster Admin\" ClusterRole.  For each developer/CI system, create a RoleBinding that grants that user the Role they need in the namespace(s) they need access to that are not kube-system.  This is commonly the \"admin\" ClusterRole bound to the namespace to delegate them full control over that namespace."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control\",\"ref\":\"Kubernetes RBAC\"},{\"text\":\"GKE Multi-tenancy\",\"url\":\"https://speakerdeck.com/alp/multi-tenancy-best-practices-for-google-kubernetes-engine?slide=3\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.516183"], ["id", 33]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "50399e71-32dc-569b-bcd1-d63fa0a39a85"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "50399e71-32dc-569b-bcd1-d63fa0a39a85"], ["created_at", "2020-10-07 21:58:18.523979"], ["updated_at", "2020-10-07 21:58:18.523979"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.1ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 34]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 34], ["created_at", "2020-10-07 21:58:18.536384"], ["updated_at", "2020-10-07 21:58:18.536384"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 34], ["created_at", "2020-10-07 21:58:18.543822"], ["updated_at", "2020-10-07 21:58:18.543822"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-46"], ["title", "GKE Network Policy support should be installed"], ["description", "By default in Kubernetes, all Pods can communicate with each other by IP and egress to any subnet (including the Internet) unless routing or firewalls are added to prevent that traffic.  This presents ample opportunity for lateral movement from the perspective of a compromised workload. One of the best ways to reduce the scope of that movement is to deploy NetworkPolicy resources that define firewall rules for pod-to-pod traffic.  In GKE, the Network Policy add-on must be enabled to allow for the cluster to enforce firewall policies on Pods."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.networkPolicy.enabled==true and .networkPolicy.provider==\"CALICO\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the cluster to enabled Network Policy support to allow for in-cluster support for NetworkPolicy (firewall rules) resources."], ["refs", "[{\"text\":\"Kubernetes Network Policy\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#restrict_with_network_policy\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.549006"], ["id", 34]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9eb1bf9e-1214-510e-9675-397a7ffd52fb"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9eb1bf9e-1214-510e-9675-397a7ffd52fb"], ["created_at", "2020-10-07 21:58:18.556368"], ["updated_at", "2020-10-07 21:58:18.556368"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 35]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 35], ["created_at", "2020-10-07 21:58:18.567406"], ["updated_at", "2020-10-07 21:58:18.567406"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-47"], ["title", "GKE Control Plane IPs should be restricted to a known set of IP ranges"], ["description", "The Kubernetes API Server systems (Control Plane) expose the Kubernetes API Server TLS port publicly without an IP restrictions or limitations.  This provides convenient remote administrative access, but it affords only a single layer of defense in front of the Kubernetes cluster and all applications and data inside.  A pre-authentication or denial-of-service vulnerability could compromise or disrupt the cluster completely.  Several pre-authentication denial-of-service vulnerabilities have been discovered and fixed in recent Kubernetes releases."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.masterAuthorizedNetworksConfig.enabled==true) | select(.masterAuthorizedNetworksConfig.cidrBlocks[].cidrBlock!=\"0.0.0.0/0\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the master authorized networks on the GKE cluster to be restricted to a known set of IP ranges for API Server access.  In environments with bastion hosts or VPNs, their internal subnet range or security groups are commonly used."], ["refs", "[{\"text\":\"Billion Laughs Attack\",\"url\":\"https://www.stackrox.com/post/2019/09/protecting-kubernetes-api-against-cve-2019-11253-billion-laughs-attack/\",\"ref\":\"link\"},{\"text\":\"Billion Laughs PoC\",\"url\":\"https://gist.github.com/bgeesaman/0e0349e94cd22c48bf14d8a9b7d6b8f2\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.PT-3\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.573954"], ["id", 35]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "6506294c-7084-5b9a-a0c5-a94b5fca6082"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "6506294c-7084-5b9a-a0c5-a94b5fca6082"], ["created_at", "2020-10-07 21:58:18.581699"], ["updated_at", "2020-10-07 21:58:18.581699"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 36]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 36], ["created_at", "2020-10-07 21:58:18.591582"], ["updated_at", "2020-10-07 21:58:18.591582"]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-48"], ["title", "GKE Workload Identity should be enabled and enforcing metadata protection on all NodePools"], ["description", "Currently, all pods have the ability to reach the Instance Metadata API corresponding to the underlying node.  By extension, those pods can access the APIs and data used to bootstrap the Kubernetes worker node.  The credentials used to bootstrap a Kubernetes worker node are very commonly sufficient to be used to privilege escalate to \"cluster-admin\".  Also by extension, this means that every container image ever run in this cluster in the non-\"prod\" namespace has had the ability to reach and export these credentials.  Therefore, it's very important for a cluster's security posture to prevent pods from being able to reach the Instance Metadata API to fetch those bootstrapping credentials."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.workloadIdentityConfig.workloadPool | test(\"svc.id.goog\")) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure Workload Identity on the cluster and every node pool in the cluster with the GKE_METADATA setting enabled.  Alternatively, deploy an egress NetworkPolicy blocking egress to 169.254.169.254 for all non-kube-system namespaces."], ["refs", "[{\"text\":\"GKE Workload Identity\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity\",\"ref\":\"link\"},{\"text\":\"Hardening GKE\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#workload_identity\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\",\"PR.AC-5\",\"PR.AC-6\",\"PR.AC-7\",\"PR.DS-2\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.598752"], ["id", 36]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "896263b0-7ac0-54db-a3c3-620c97edfd50"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "896263b0-7ac0-54db-a3c3-620c97edfd50"], ["created_at", "2020-10-07 21:58:18.606875"], ["updated_at", "2020-10-07 21:58:18.606875"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 37]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 37], ["created_at", "2020-10-07 21:58:18.615603"], ["updated_at", "2020-10-07 21:58:18.615603"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 37], ["created_at", "2020-10-07 21:58:18.622262"], ["updated_at", "2020-10-07 21:58:18.622262"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-49"], ["title", "GKE Node pools should use dedicated GCP ServiceAccounts"], ["description", "By default, GKE associates the \"default\" compute service account to GKE worker nodes, and it is automatically granted the \"Project Editor\" IAM Role.  To avoid using an inherently shared service account with over-provisioned permissions, create a dedicated service account for each GKE cluster in each project and grant it only the minimal IAM permissions needed."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.serviceAccount | test(\"-compute@developer.gserviceaccount.com\") | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nCreate a dedicated GCP service account for each cluster in each project. Create a custom IAM Role with the \"monitoring.viewer\", \"monitoring.metricWriter\", and \"logging.logWriter\" permissions, and associate that with the dedicated GCP service account.  Ensure the OAuth Scopes attached to the nodes are:\n\n* https://www.googleapis.com/auth/devstorage.read_only\n* https://www.googleapis.com/auth/logging.write\n* https://www.googleapis.com/auth/monitoring\n* https://www.googleapis.com/auth/servicecontrol\n* https://www.googleapis.com/auth/service.management.readonly\n* https://www.googleapis.com/auth/trace.append\n\nConsideration: Changing the service account or the OAuth Scopes will result in a rolling redeployment of the Node Pool."], ["refs", "[{\"text\":\"GKE NodePool OAuth Scopes\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#use_least_privilege_sa\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-6\",\"PR.IP-1\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.628518"], ["id", 37]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c0247bd6-3f66-5a6a-b867-817bff7dc370"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c0247bd6-3f66-5a6a-b867-817bff7dc370"], ["created_at", "2020-10-07 21:58:18.637011"], ["updated_at", "2020-10-07 21:58:18.637011"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 38]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 38], ["created_at", "2020-10-07 21:58:18.646153"], ["updated_at", "2020-10-07 21:58:18.646153"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-50"], ["title", "GKE Node pools should use Shielded GKE Nodes"], ["description", "Starting in GKE 1.13.6 and later, GKE Worker nodes can be provisioned with a Virtual Trusted Platform Module (vTPM) that can be used to cryptographically verify the integrity of the boot process and to securely distribute the bootstrapping credentials used by the Kubelet to attach the node to the cluster on first boot.  Without this feature, the Kubelet's bootstrapping credentials are available via the GCE Metadata API, and that can be accessed by any Pod unless additional protections are put in place.  These credentials can be leveraged to escalate to cluster-admin in most situations."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.shieldedInstanceConfig.enableIntegrityMonitoring==true and .nodePools[].config.shieldedInstanceConfig.enableSecureBoot==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nModify the cluster node pool configuration to enable shielded nodes (--enable-shielded-nodes) and secure boot (--shielded-secure-boot).  This will remove the sensitive bootstrapping credentials from the GCE Metadata API and enable additional verification checks to ensure the worker nodes have not been compromised at a fundamental level.  Considerations: The nodes must be running the COS or COS_CONTAINERD operating system, and enabling this change will require a node pool rolling redeployment performed at the next maintenance window."], ["refs", "[{\"text\":\"GKE Hardening\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#shielded_nodes\",\"ref\":\"link\"},{\"text\":\"GKE Shielded Nodes\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/shielded-gke-node\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-6\",\"PR.DS-8\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.651646"], ["id", 38]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1b62d4fd-a5c1-5624-9067-e45c3261c24c"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1b62d4fd-a5c1-5624-9067-e45c3261c24c"], ["created_at", "2020-10-07 21:58:18.662173"], ["updated_at", "2020-10-07 21:58:18.662173"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 39]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 39], ["created_at", "2020-10-07 21:58:18.672441"], ["updated_at", "2020-10-07 21:58:18.672441"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 39], ["created_at", "2020-10-07 21:58:18.680565"], ["updated_at", "2020-10-07 21:58:18.680565"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-51"], ["title", "Production GKE Clusters should have a highly-available control plane"], ["description", "By default, GKE creates a \"zonal\" cluster.  That is, a cluster where the single control plane GCE instance is deployed in one GCP availability zone.  GKE clusters can also be configured as \"regional\" clusters in which three control plane GCE instances can be deployed evenly across three availability zones at no direct, additional cost.  Having three control plane instances insulates from a single control plane instance failure and allows for zero-downtime API server upgrades."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.location | test(\"^[a-z]+-[a-z0-9]+$\")) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nFor all production GKE clusters, configure the \"location\" as the region name instead of the zone name.  This requires rebuilding the cluster if it is already deployed as a zonal cluster."], ["refs", "[{\"text\":\"GKE Regional Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/regional-clusters\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.686372"], ["id", 39]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "03cf095b-e748-59e1-b596-777da1ba23c3"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.1ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "03cf095b-e748-59e1-b596-777da1ba23c3"], ["created_at", "2020-10-07 21:58:18.694077"], ["updated_at", "2020-10-07 21:58:18.694077"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 40]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 40], ["created_at", "2020-10-07 21:58:18.706493"], ["updated_at", "2020-10-07 21:58:18.706493"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-52"], ["title", "GKE Clusters should use a Private Cluster Endpoint/IP"], ["description", "By default, GKE creates clusters with a public IP address on the control plane without any network restriction on source IP ranges that can access it.  Even though the access controls protecting the API server require authentication and authorization, the API server is open to denial-of-service attacks, being probed by bots/scanners inflating Stackdriver logs, and direct exploitation should a Kubernetes API Server vulnerability be discovered."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.privateClusterConfig.enablePrivateEndpoint==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConsider rebuilding GKE clusters with the \"private master endpoint\" configuration to ensure the API server is not assigned a routable public IP address.  Additional considerations:\n\n* Converting a public to a private GKE cluster requires rebuilding it.\n* Use a dedicated /28 subnet for the control plane IP space that does not overlap anywhere and is not part of 172.17.0.0/16.\n* Private control planes leverage VPC peering and count toward VPC peering quota.\n* Modifications to the VPC peering or firewall rules from the control plane to the worker nodes can break the cluster."], ["refs", "[{\"text\":\"GKE Private Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.PT-3\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.711463"], ["id", 40]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0e680f8d-95d8-5fcb-937e-9891dd11fe2e"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0e680f8d-95d8-5fcb-937e-9891dd11fe2e"], ["created_at", "2020-10-07 21:58:18.735442"], ["updated_at", "2020-10-07 21:58:18.735442"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 41]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 41], ["created_at", "2020-10-07 21:58:18.747287"], ["updated_at", "2020-10-07 21:58:18.747287"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-53"], ["title", "Production GKE Cluster NodePools should be spread across multiple availability zones"], ["description", "By default, GKE creates a \"zonal\" cluster.  That is, a cluster where the single control plane GCE instance is deployed in one GCP availability zone and the worker GCE instances are deployed as a node pool in that same availability zone.  This optimizes for cost and simplicity at the expense of redundancy and protection against a zone outage.  If the control plane is set to \"regional\", then the worker GCE instances are deployed evenly across the three availability zones with instance groups per zone.  Setting the node pool instance count to \"1\" on a regional cluster will create one GCE instance in each of the three zones for a total of three worker nodes."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.locations | length >= 3) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nFor all production GKE clusters, configure the \"location\" as the region name instead of the zone name.  This requires rebuilding the cluster if it is already deployed as a zonal cluster.  The worker nodes will automatically be spread evenly across all three availability zones.\n\nConsideration: as traffic goes from node to node over zone boundaries, additional network costs will be incurred."], ["refs", "[{\"text\":\"GKE Regional Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/regional-clusters\",\"ref\":\"link\"},{\"text\":\"GKE Network Pricing\",\"url\":\"https://cloud.google.com/compute/network-pricing\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.752722"], ["id", 41]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "ed4eb845-f04a-5774-986b-112d4a468704"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "ed4eb845-f04a-5774-986b-112d4a468704"], ["created_at", "2020-10-07 21:58:18.760824"], ["updated_at", "2020-10-07 21:58:18.760824"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 42]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 42], ["created_at", "2020-10-07 21:58:18.773594"], ["updated_at", "2020-10-07 21:58:18.773594"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.3ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-54"], ["title", "GKE Maintenance Window should be explicitly set"], ["description", "The GKE service performs maintenance functions on the cluster control plane and workers automatically, and the default configuration is for the time to be chosen by the service.  However, an organization will often want to configure that time window to fall during hours when traffic levels are lowest, batch processing is not occurring, or when operations teams are available to troubleshoot application issues."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.maintenancePolicy.window | null | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure either a \"simple\" maintenance window of 4 hours (UTC) per day or a more complex maintenance window with rules to define a more granular schedule.  Consideration: The policy must allow at least 24 hours of maintenance availability in a 14-day rolling window. Only contiguous availability windows of at least four hours are considered."], ["refs", "[{\"text\":\"GKE Maintenance Windows\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/maintenance-windows-and-exclusions\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\",\"ID.RA-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.778684"], ["id", 42]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "54c8a422-1076-5507-afbc-1baf12e5bafc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "54c8a422-1076-5507-afbc-1baf12e5bafc"], ["created_at", "2020-10-07 21:58:18.786479"], ["updated_at", "2020-10-07 21:58:18.786479"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 43]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 43], ["created_at", "2020-10-07 21:58:18.798655"], ["updated_at", "2020-10-07 21:58:18.798655"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-55"], ["title", "GKE Intranode Visibility should be enabled"], ["description", "When enabling VPC Flow Logs on a VPC where GKE clusters are running, traffic that does not exit the node is not captured.  That is, traffic between two pods on the same node do not exit the host's network and therefore are omitted from VPC Flow Logging.  Enabling Intranode Visibility allows this traffic to be recorded in the VPC Flow Logs for analysis and diagnosis."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.networkConfig.enableIntraNodeVisibility==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure Intranode Visibility on GKE Clusters running in VPCs with Flow logging enabled.  Considerations: VPC Flow logs may increase in size and contribute to additional cost."], ["refs", "[{\"text\":\"GKE Intranode Visibility\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/intranode-visibility\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-3\",\"DE.CM-1\",\"DE.CM-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.804463"], ["id", 43]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "be0d8437-d539-53fc-b017-0c5e92b00050"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "be0d8437-d539-53fc-b017-0c5e92b00050"], ["created_at", "2020-10-07 21:58:18.811693"], ["updated_at", "2020-10-07 21:58:18.811693"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 44]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 44], ["created_at", "2020-10-07 21:58:18.821296"], ["updated_at", "2020-10-07 21:58:18.821296"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-56"], ["title", "GKE Logs should be sent to Stackdriver"], ["description", "By default, GKE enables a Stackdriver log export managed add-on capability that ships all Host OS, Kubernetes components, and container logs to the Stackdriver endpoint in the current project.  This provides a detailed record of nearly all activities in the cluster and nodes to support troubleshooting and auditing functions.  Even if a third party logging solution is implemented to capture and ship logs, it's recommended that this add-on is enabled to ensure all Host OS and Kubernetes component logs are captured off-cluster."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.loggingService==\"logging.googleapis.com/kubernetes\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the Kubernetes Engine Monitoring for \"System and workload logging and monitoring\" via the console or by way of the `--enable-stackdriver-kubernetes` option to gcloud on all GKE clusters. Existing clusters can have this feature enabled in-place with no downtime."], ["refs", "[{\"text\":\"Kubernetes Engine Monitoring\",\"url\":\"https://cloud.google.com/monitoring/kubernetes-engine/installing\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.828022"], ["id", 44]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39990107-d55c-5487-b87f-bbfe4d19bfd2"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39990107-d55c-5487-b87f-bbfe4d19bfd2"], ["created_at", "2020-10-07 21:58:18.836685"], ["updated_at", "2020-10-07 21:58:18.836685"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 45]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 45], ["created_at", "2020-10-07 21:58:18.846407"], ["updated_at", "2020-10-07 21:58:18.846407"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-57"], ["title", "GKE Metrics should be sent to Stackdriver"], ["description", "By default, GKE enables a Stackdriver metrics export managed add-on capability that ships all Host OS, Kubernetes components, and container metrics to the Stackdriver metrics endpoint in the current project.  This provides a detailed record of nearly all performance metrics in the cluster and nodes to support troubleshooting and auditing functions.  Even if a third party metrics solution is implemented, it's recommended that this add-on is enabled to ensure all Host OS and Kubernetes component metrics are captured off-cluster."], ["platform", "gcp"], ["impact", 6], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.monitoringService==\"monitoring.googleapis.com/kubernetes\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the Kubernetes Engine Monitoring for \"System and workload logging and monitoring\" via the console or by way of the `--enable-stackdriver-kubernetes` option to gcloud on all GKE clusters. Existing clusters can have this feature enabled in-place with no downtime."], ["refs", "[{\"text\":\"Kubernetes Engine Monitoring\",\"url\":\"https://cloud.google.com/monitoring/kubernetes-engine/installing\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.852590"], ["id", 45]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "15d42207-9457-5b63-acf8-186414fa05bb"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "15d42207-9457-5b63-acf8-186414fa05bb"], ["created_at", "2020-10-07 21:58:18.860754"], ["updated_at", "2020-10-07 21:58:18.860754"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 46]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 46], ["created_at", "2020-10-07 21:58:18.872165"], ["updated_at", "2020-10-07 21:58:18.872165"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.3ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-58"], ["title", "GKE Node Pools should use the COS or COS_CONTAINERD Operating System"], ["description", "GKE Nodes can leverage either Container-Optimized OS or Ubuntu-based operating system images.  Unless there is a very specific use-case that a Container-Optimized OS image cannot support such as installed certain drivers and/or kernel modules, Ubuntu nodes are not recommended.  Container-Optimized OS is a fully hardened operating system designed specifically to run containerized workloads with a high degree of security, and it receives automatic updates from Google.  The track record for security issues that affect Ubuntu nodes in GKE that did not affect COS nodes is also important to consider."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.imageType | test(\"^COS\")) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure your GKE Node Pools to leverage either the COS or COS_CONTAINERD image type.  The COS image leverages Docker, and the COS_CONTAINERD image implements only containerd and does not use the commonly known Docker socket at `/var/run/docker.sock` which allows applications that can access that socket to effectively be \"root\" on the host.  If your workloads do not require the ability to mount the docker socket for activities such as image building in-cluster or certain security features, COS_CONTAINERD offers an even smaller attack surface than COS.  Considerations: changing the image type recreates the nodes in the node pool."], ["refs", "[{\"text\":\"GKE Node Images\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/node-images\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.877327"], ["id", 46]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0208f5cf-e54b-5a4b-a90a-18f3db82d37e"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0208f5cf-e54b-5a4b-a90a-18f3db82d37e"], ["created_at", "2020-10-07 21:58:18.885098"], ["updated_at", "2020-10-07 21:58:18.885098"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 47]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 47], ["created_at", "2020-10-07 21:58:18.896376"], ["updated_at", "2020-10-07 21:58:18.896376"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-59"], ["title", "GCP Projects should have only one GKE Cluster"], ["description", "GCP Projects are typically the most granular point for IAM permissions to be declared, and the way GKE clusters expect to leverage the project's resources makes isolating multiple clusters in the same project very difficult.  Assignment of IAM Roles related to instance and cluster administration is typically only available at the Project level, so permissions apply to all clusters.  In addition, logs and metrics sent from GKE clusters go to the Project's shared Stackdriver location, and IAM Roles for logging and monitoring grant access for all logs and metrics for all clusters and applications--making it extremely difficult to prevent users of one cluster from seeing all logs from all applications and all namespaces.  Finally, in some cases of misconfiguration, a compromise of a GKE cluster can lead to compromise of all clusters in the same Project."], ["platform", "gcp"], ["impact", 2], ["validation", "\nFor each GCP Project, run `gcloud container clusters list` and ensure only one cluster is listed per project."], ["remediation", "\nOrganize GCP Projects such that each GKE Cluster has a designated Project with no other resources co-located unless they directly support the cluster.  Understand that certain IAM Roles such as \"Compute Admin\" equate to \"Kubernetes Engine Administrator\" because access to the GCE Instances that make up the GKE worker nodes as \"root\" means those users can also access all data, secrets, and applications inside Kubernetes.  Therefore, also review the IAM permissions in the Project to ensure unintended permission \"cross-over\" is minimized."], ["refs", "[{\"text\":\"IAM Concepts\",\"url\":\"https://cloud.google.com/iam/docs/concepts\",\"ref\":\"link\"},{\"text\":\"GCP Enterprise Best Practices\",\"url\":\"https://cloud.google.com/docs/enterprise/best-practices-for-enterprise-organizations\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.903023"], ["id", 47]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3f80d3c0-7172-5d22-9dc2-a46b12dc6919"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3f80d3c0-7172-5d22-9dc2-a46b12dc6919"], ["created_at", "2020-10-07 21:58:18.911007"], ["updated_at", "2020-10-07 21:58:18.911007"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 48]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 48], ["created_at", "2020-10-07 21:58:18.931004"], ["updated_at", "2020-10-07 21:58:18.931004"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-60"], ["title", "GKE Node pools should AutoRepair"], ["description", "GKE Nodes have several health checks that continuously run to validate that the worker node is running and capable of handling workloads.  If an issue occurs that the system cannot auto-resolve, the automatic repair feature will handle evicting workloads from the node and reprovisioning the underlying GCE instance for you.  This is highly recommended for reducing administrator load and maintaining healthy clusters."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].management.autoRepair==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the node pools to enable AutoRepair during node pool creation or to existing clusters with the `--enable-autorepair` feature set."], ["refs", "[{\"text\":\"GKE Node Auto Repair\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.938706"], ["id", 48]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2a0af119-6735-501b-964a-30efbcd4a153"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2a0af119-6735-501b-964a-30efbcd4a153"], ["created_at", "2020-10-07 21:58:18.947617"], ["updated_at", "2020-10-07 21:58:18.947617"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 49]]
  [1m[36mTag Load (0.9ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 49], ["created_at", "2020-10-07 21:58:18.966403"], ["updated_at", "2020-10-07 21:58:18.966403"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-61"], ["title", "GKE Node pools should AutoUpgrade"], ["description", "The GKE service will automatically maintain the version and patch release of the control plane nodes, but the Node Pools are left to the user to keep upgraded by default.  This can result in situations where security issues are patched on the control plane but not on the nodes, and performing node upgrades is an activity that can consume a large amount of administrative time if performed manually across many clusters and node pools.  If your workloads are properly configured to withstand a single node failure, these maintenance activities can be performed during upgrade windows without manual intervention or downtime."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].management.autoUpgrade==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the node pools to enable AutoUpgrade during node pool creation or to existing clusters with the `--enable-autoupgrade` feature set.  It's strongly recommended to validate that all workloads can handle the upgrade process smoothly in a development cluster before enabling this setting in production."], ["refs", "[{\"text\":\"GKE Node Auto Upgrade\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-upgrades\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:18.979353"], ["id", 49]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "4cef5a03-d6db-5fd8-92fe-453b24cdb3db"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "4cef5a03-d6db-5fd8-92fe-453b24cdb3db"], ["created_at", "2020-10-07 21:58:18.988826"], ["updated_at", "2020-10-07 21:58:18.988826"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 50]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (2.0ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 50], ["created_at", "2020-10-07 21:58:19.003914"], ["updated_at", "2020-10-07 21:58:19.003914"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (4.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 50], ["created_at", "2020-10-07 21:58:19.045539"], ["updated_at", "2020-10-07 21:58:19.045539"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-62"], ["title", "GKE Node pools should use the minimum OAuth Scopes"], ["description", "GKE Nodes are fundamentally GCE instances, and GCE instances with a Service Account attached have the permissions of the IAM Roles attached.  However, those permissions can be restricted even further by defining OAuth Scopes that explicitly list the APIs the OAuth Token generated for that Service Account are valid for.  For example, a GCE instance with an attached Service Account that is assigned the IAM Role of \"Project Owner\" but has only the \"https://www.googleapis.com/auth/devstorage\" OAuth Scope will only be able to interact with GCS Buckets.  However, if that OAuth Scope was set to \"https://www.googleapis.com/auth/cloud-platform\" (equivalent to \"any/all APIs\"), that instance would have the full privileges provided by \"Project Owner\".  By default, GKE Node Pools should only specify the following OAuth Scopes that provide the minimum access needed:\n\n* https://www.googleapis.com/auth/devstorage.read_only\n* https://www.googleapis.com/auth/logging.write\n* https://www.googleapis.com/auth/monitoring\n* https://www.googleapis.com/auth/service.management.readonly\n* https://www.googleapis.com/auth/servicecontrol\n* https://www.googleapis.com/auth/trace.append"], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.oauthScopes[] | test(\"cloud-platform\") | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure GKE Node Pools to explicitly set only the minimum OAuth Scopes.  For pods/applications that were running on these nodes and leveraging the node's Service Account for access to GCP APIs, understand that access is shared by all pods unless Workload Identity is deployed.  To map GCP Service Accounts to individual Pods/Workloads, create GCP Service Accounts in the Project with the necessary permissions and leverage Workload Identity to attach those credentials directly."], ["refs", "[{\"text\":\"GKE NodePool OAuth Scopes\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#use_least_privilege_sa\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-1\",\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.057735"], ["id", 50]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (1.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1dc51c31-05b3-5fe8-9b79-9d09c7a9db93"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.2ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1dc51c31-05b3-5fe8-9b79-9d09c7a9db93"], ["created_at", "2020-10-07 21:58:19.076864"], ["updated_at", "2020-10-07 21:58:19.076864"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.1ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 51]]
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (1.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 51], ["created_at", "2020-10-07 21:58:19.104666"], ["updated_at", "2020-10-07 21:58:19.104666"]]
  [1m[35m (1.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-63"], ["title", "GKE Subnet Alias ranges should be configured"], ["description", "In order to support private GKE Clusters, Alias IP ranges on the VPC Subnets is required.  In addition to private clusters, Alias IP ranges simplify the route tables in the VPC, reduce the number of \"hops\" traffic takes from load balancers to Pods, and allows the GCE network interfaces to perform anti-spoofing checks as IP forwarding is not required on the instance.  Finally, the separation of VM IPs from Container IPs allows for native firewall rules to be configured for pod traffic separately from VM traffic."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.ipAllocationPolicy.useIpAliases==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nDuring cluster creation, specify a VPC Subnet that supports Alias IP ranges and secondary ranges for Pods and Services.  This can only be done at cluster creation time."], ["refs", "[{\"text\":\"VPC Alias IPs\",\"url\":\"https://cloud.google.com/vpc/docs/alias-ip\",\"ref\":\"link\"},{\"text\":\"VPC-Native GKE Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/alias-ips\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.PT-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.116360"], ["id", 51]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8aced34e-ed35-50d8-aaab-3bd7271bb6f7"], ["LIMIT", 1]]
  [1m[35m (0.9ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8aced34e-ed35-50d8-aaab-3bd7271bb6f7"], ["created_at", "2020-10-07 21:58:19.126012"], ["updated_at", "2020-10-07 21:58:19.126012"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 52]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 52], ["created_at", "2020-10-07 21:58:19.108105"], ["updated_at", "2020-10-07 21:58:19.108105"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 52], ["created_at", "2020-10-07 21:58:19.117728"], ["updated_at", "2020-10-07 21:58:19.117728"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-64"], ["title", "Legacy ABAC authorization in GKE"], ["description", "Role-Based Access Control has been the default authorization mechanism in Kubernetes since version 1.6.  GKE still provides a legacy capability that supports ABAC, but it should not be used.  It essentially provides \"cluster admin\" access for any authenticated credential to the cluster and has no method for changing this policy.  This is an extremely permissive setting that allows for full cluster compromise should an attacker gain access to a single pod with a mounted Kubernetes service account or a valid cluster credential."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.legacyAbac.enabled | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the cluster without the `--enable-legacy-authorization` flag set.  If migrating an existing cluster from ABAC to RBAC by modifying this setting in-place, ensure that all the required RBAC RoleBindings and ClusterRoleBindings are present first.  This should be performed in a development environment before applying this process to production clusters."], ["refs", "[{\"text\":\"GKE Cluster Hardening\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.124038"], ["id", 52]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "055adcff-8a12-503a-8056-fe418d714bbf"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "055adcff-8a12-503a-8056-fe418d714bbf"], ["created_at", "2020-10-07 21:58:19.135201"], ["updated_at", "2020-10-07 21:58:19.135201"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 53]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 53], ["created_at", "2020-10-07 21:58:19.153558"], ["updated_at", "2020-10-07 21:58:19.153558"]]
  [1m[35m (1.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-65"], ["title", "CloudSQL Instances High-Availability"], ["description", "By default, CloudSQL instances are deployed as a single instance, and this means an instance failure or availability-zone outage would take the database offline.  Production applications should be relying on access to data stores that can withstand these failure conditions where possible, and the CloudSQL service offering provides a high-availability instance type that runs in multiple availability-zones in the same region for this purpose."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.availabilityType==\"ZONAL\") | \"(.name) Type: (.settings.availabilityType)\"'` and ensure no entries are listed as \"ZONAL\"."], ["remediation", "\nCreate or update the CloudSQL instances used in production with the \"REGIONAL\" availability type instead of the default of \"ZONAL\". Existing instances can be modified to have these settings take effect, but it requires the instance to be restarted."], ["refs", "[{\"text\":\"CloudSQL MySQL High Availability\",\"url\":\"https://cloud.google.com/sql/docs/mysql/high-availability\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL High Availability\",\"url\":\"https://cloud.google.com/sql/docs/postgres/high-availability\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver High Availability\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/high-availability\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.164607"], ["id", 53]]
  [1m[35m (2.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "323aca0a-eab5-5ecc-8e58-ea66f6cb8103"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "323aca0a-eab5-5ecc-8e58-ea66f6cb8103"], ["created_at", "2020-10-07 21:58:19.183630"], ["updated_at", "2020-10-07 21:58:19.183630"]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 54]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (1.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 54], ["created_at", "2020-10-07 21:58:19.207491"], ["updated_at", "2020-10-07 21:58:19.207491"]]
  [1m[35m (2.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-66"], ["title", "CloudSQL Instances maintenance windows"], ["description", "The CloudSQL service performs maintenance functions on the instances automatically, and the default configuration is for the time to be chosen by the service.  However, an organization will often want to configure that time window to fall during hours when traffic levels are lowest, batch processing is not occurring, or when operations teams are available to troubleshoot application issues."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.maintenanceWindow.day==0 and .settings.maintenanceWindow.hour==0) | \"(.name) Type: (.settings.maintenanceWindow.day) (.settings.maintenanceWindow.hour)\"'` and ensure no entries are listed as \"0 0\"."], ["remediation", "\nConfigure the maintenance preferences on the CloudSQL instance to a preferred window that has the days and hours when updates should occur, and select the order of update to be \"Any\", \"Earlier\", or \"Later\" to correspond to the timing of when the rolling updates should include this instance.  Typically, development instances should be set to \"Earlier\" and production instances set to \"Later\" to help validate upgrades and patches on less critical databases first.  Also, opt-in to email notifications for maintenance on the communications page at `https://console.cloud.google.com/user-preferences/communication`."], ["refs", "[{\"text\":\"CloudSQL MySQL Maintenance Windows\",\"url\":\"https://cloud.google.com/sql/docs/mysql/maintenance\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Maintenance Windows\",\"url\":\"https://cloud.google.com/sql/docs/postgres/maintenance\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Maintenance Windows\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/maintenance\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.222471"], ["id", 54]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e8f23fba-c1ab-5c39-8a2b-faf957ded12c"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e8f23fba-c1ab-5c39-8a2b-faf957ded12c"], ["created_at", "2020-10-07 21:58:19.234020"], ["updated_at", "2020-10-07 21:58:19.234020"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 55]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 55], ["created_at", "2020-10-07 21:58:19.245791"], ["updated_at", "2020-10-07 21:58:19.245791"]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-67"], ["title", "CloudSQL Instance automatic backups with point-in-time recovery"], ["description", "By default, CloudSQL instances have automatic backups with point-in-time recovery enabled.  It's important that these settings are not disabled to ensure that all databases can be restored to a known-good state should a security incident occur.  For example, a SQL injection attack that results in the deletion or modification of tables in the database."], ["platform", "gcp"], ["impact", 9], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.backupConfiguration.enabled==false) | \"(.name) Backups on: (.settings.backupConfiguration.enabled) and PITR on: (.settings.backupConfiguration.binaryLogEnabled)\"'` and ensure no entries are listed."], ["remediation", "\nEnsure all CloudSQL instances are configured with automatic backups during a desired window and point-in-time recovery is enabled.  Existing instances can be modified to have these settings take effect, but it requires the instance to be restarted."], ["refs", "[{\"text\":\"CloudSQL MySQL Backups\",\"url\":\"https://cloud.google.com/sql/docs/mysql/backup-recovery/backups\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Backups\",\"url\":\"https://cloud.google.com/sql/docs/postgres/backup-recovery/backups\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Backups\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/backup-recovery/backups\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-4\",\"PR.PT-5\",\"PR.IP-10\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.256191"], ["id", 55]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9bde9d05-e5e0-545e-bcea-a722d5e0d511"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9bde9d05-e5e0-545e-bcea-a722d5e0d511"], ["created_at", "2020-10-07 21:58:19.269091"], ["updated_at", "2020-10-07 21:58:19.269091"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.0ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 56]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 56], ["created_at", "2020-10-07 21:58:19.294819"], ["updated_at", "2020-10-07 21:58:19.294819"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-68"], ["title", "Public nodes via SSH"], ["description", "The Kubernetes Worker nodes are exposed publicly via SSH.  This provides convenient remote administrative access, but it affords only a single layer of defense in front of the Kubernetes cluster and all applications and data inside. Having \"root\" access to one Kubernetes cluster node is very often sufficient to become \"cluster-admin\" in the cluster which grants full control of the cluster and the underlying nodes."], ["platform", "k8s"], ["impact", 5], ["validation", "\nEnsure that all Kubernetes worker nodes are not available on TCP/22 from any IP address using a simple port probe. e.g. `nc -vz ip.of.the.worker 22`."], ["remediation", "\nConfigure the firewall rules on the Kubernetes worker systems to be restricted to a known set of IP ranges for SSH access.  In environments with bastion hosts or VPNs, their internal subnet range or security groups are commonly used."], ["refs", "[{\"text\":\"Kubernetes Security Best Practices\",\"url\":\"https://kubernetes.io/blog/2016/08/security-best-practices-kubernetes-deployment/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.MA-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.305869"], ["id", 56]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "68066452-dd6e-5468-a50d-f70ef5bb4adc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "68066452-dd6e-5468-a50d-f70ef5bb4adc"], ["created_at", "2020-10-07 21:58:19.331860"], ["updated_at", "2020-10-07 21:58:19.331860"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (2.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 57]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 57], ["created_at", "2020-10-07 21:58:19.357809"], ["updated_at", "2020-10-07 21:58:19.357809"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-69"], ["title", "Secrets in ConfigMaps"], ["description", "Kubernetes ConfigMaps can be used to store configuration key/value pairs and files to be dynamically mounted into pods at runtime, and those can often contain sensitive data like API keys and other credentials.  However, this exposes them to users and other workloads that interact with the API server who have the RBAC permission \"get configmaps\" in the cluster which is commonly a much wider audience than desired."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get configmaps --all-namespaces -o yaml > cfgmaps.yml` and use a tool like TruffleHog to review the data for potentially sensitive items."], ["remediation", "\nEnsure that no secret material is directly defined in ConfigMaps.  Instead, store them in a Secret and use the secretKeyRef mechanism to mount them in as files inside the container at runtime."], ["refs", "[{\"text\":\"Kubernetes ConfigMaps\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/\",\"ref\":\"link\"},{\"text\":\"TruffleHog\",\"url\":\"https://github.com/dxa4481/truffleHog\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.367601"], ["id", 57]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0b473d00-130f-5be6-a6ff-3ef74e8ee55e"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0b473d00-130f-5be6-a6ff-3ef74e8ee55e"], ["created_at", "2020-10-07 21:58:19.380134"], ["updated_at", "2020-10-07 21:58:19.380134"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 58]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 58], ["created_at", "2020-10-07 21:58:19.398557"], ["updated_at", "2020-10-07 21:58:19.398557"]]
  [1m[35m (2.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.9ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-70"], ["title", "Ensure resource specification enforcement is installed"], ["description", "By default in Kubernetes, the ability to create resources is only controlled via RBAC authorization.  If a user has the ability to create or modify a Pod, they are able to create or modify any setting during its creation.  This can include settings that allow it to run as root/privileged, mount the host filesystem, to add Linux system capabilities, to attach to the host's network and process namespace, and more.  All of these settings are potential pathways for escaping to the underlying nodes and compromising the entire cluster.  To prevent users from creating resources with undesired configurations, an administrator can deploy an \"Admission Controller\" such as PodSecurityPolicy or a \"Dynamic Admission Control Webhook\" to ask a service like Gatekeeper.  If either determines the workload to not meet policy, it can prevent the workload from running."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get psps --all-namespaces` to identify `PodSecurityPolicy` resources in place, or run `kubectl get deployments --all-namespaces` and look for `gatekeeper` or `k-rail` deployments to be present."], ["remediation", "\nWhile PodSecurityPolicy is a native admission controller that can protect clusters from users running insecure pod workloads, it is still in Kubernetes beta, and it is limited only to Pod resources.  The Gatekeeper project, which uses Open Policy Agent as its policy engine, can be deployed more easily, can review any resource in the cluster if desired, and allows for full customization of what to look for.  Deploying either OPA/Gatekeeper or K-Rail is therefore the recommended solution for those that do not already have PodSecurityPolicy implemented."], ["refs", "[{\"text\":\"Kubernetes PodSecurityPolicy\",\"url\":\"https://kubernetes.io/docs/concepts/policy/pod-security-policy/\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"text\":\"K-rail\",\"url\":\"https://github.com/cruise-automation/k-rail\",\"ref\":\"link\"},{\"text\":\"GKE PodSecurityPolicy\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/pod-security-policies\",\"ref\":\"link\"},{\"text\":\"EKS PodSecurityPolicy\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/pod-security-policy.html\",\"ref\":\"link\"},{\"text\":\"AKS PodSecurityPolicy\",\"url\":\"https://docs.microsoft.com/en-us/azure/aks/use-pod-security-policies\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.414712"], ["id", 58]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "261a1a40-e362-5bbc-ad48-cc59419ac436"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "261a1a40-e362-5bbc-ad48-cc59419ac436"], ["created_at", "2020-10-07 21:58:19.429972"], ["updated_at", "2020-10-07 21:58:19.429972"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 59]]
  [1m[36mTag Load (3.1ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (2.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 59], ["created_at", "2020-10-07 21:58:19.464685"], ["updated_at", "2020-10-07 21:58:19.464685"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 59], ["created_at", "2020-10-07 21:58:19.512053"], ["updated_at", "2020-10-07 21:58:19.512053"]]
  [1m[35m (1.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-71"], ["title", "Validate NetworkPolicies are defined in each namespace"], ["description", "By default in Kubernetes, all Pods can communicate with each other by IP and egress to any subnet (including the Internet) unless routing or firewalls are added to prevent that traffic.  This presents ample opportunity for lateral movement from the perspective of a compromised workload. One of the best ways to reduce the scope of that movement is to deploy NetworkPolicy resources that define firewall rules for pod-to-pod traffic.  All pod-to-pod and egress traffic is allowed, and this means that pods that handle customer data can talk directly to core Kubernetes system pods, the Internet, and other systems inside the VPC if the security groups allow."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get networkpolicies --all-namespaces` and ensure each namespace has the desired policies defined."], ["remediation", "\nImplement NetworkPolicy rules on the kube-system namespace to prevent all inbound traffic from non-kube-system namespaces to all workloads in the kube-system namespace with the exception of UDP/TCP 53 for DNS lookups.  Next, identify the network traffic patterns of externally exposed workloads and implement NetworkPolicies that restrict their traffic to the \"next hop\" service or ranges.  Finally, perform the same pattern to all internal workloads.  Considerations: Implementing NetworkPolicies should be performed in a development environment to fully understand implications and to avoid introducing an outage in production."], ["refs", "[{\"text\":\"Kubernetes Network Policies\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/network-policies/\",\"ref\":\"link\"},{\"text\":\"NetworkPolicy Recipes\",\"url\":\"https://github.com/ahmetb/kubernetes-network-policy-recipes\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.525604"], ["id", 59]]
  [1m[35m (2.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (1.9ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1666b935-62e1-5594-a7a6-ab0395b90ed4"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1666b935-62e1-5594-a7a6-ab0395b90ed4"], ["created_at", "2020-10-07 21:58:19.541944"], ["updated_at", "2020-10-07 21:58:19.541944"]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 60]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 60], ["created_at", "2020-10-07 21:58:19.556420"], ["updated_at", "2020-10-07 21:58:19.556420"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-72"], ["title", "ServiceAccount mounted unnecessarily"], ["description", "By default, the \"default\" Service Account in each namespace will be mounted inside every container in every Pod unless explicitly configured to use another Service Account or to not be mounted.  The Service Account token that is mounted for convenience inside the pod in case the container workload needs a valid credential to communicate with the Kubernetes API.  However, most workloads do not require this access, and so they should be explicitly configured not to mount it to minimize exposure to these credentials."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace +\"/\"+ .metadata.name +\": \"+ .spec.serviceAccount'` and review the listing for pods that mount service accounts where API access is not required.  Typically, workloads that mount the \"default\" service account are likely candidates as pods should be mounting dedicated service accounts if needed."], ["remediation", "\nFor every non-kube-system namespace, modify all Service Accounts to opt out of automounting API credentials by setting automountServiceAccountToken: false.  Ensure RBAC bindings to all \"default\" Service Accounts are removed, and use dedicated Service Accounts for each workload that needs API Access with dedicated RBAC Role/ClusterRoleBindings."], ["refs", "[{\"text\":\"Kubernetes ServiceAccounts\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.564657"], ["id", 60]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9feaff35-13bb-5856-aac9-7cd93cae3beb"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9feaff35-13bb-5856-aac9-7cd93cae3beb"], ["created_at", "2020-10-07 21:58:19.575879"], ["updated_at", "2020-10-07 21:58:19.575879"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 61]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 61], ["created_at", "2020-10-07 21:58:19.587626"], ["updated_at", "2020-10-07 21:58:19.587626"]]
  [1m[35m (1.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-73"], ["title", "Orphaned Persistent Volume Claims found"], ["description", "Multiple persistent disk volume claims were found to be in the \"Released\" state, and they indicate a potential misconfiguration in a deployment or statefulset leaving them behind."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pvc --all-namespaces` and look for items in the \"Released\" state.  Ideally, all should be in use."], ["remediation", "\nEnsure the workloads that created and abandoned the affected persistent volume claims correctly clean up after themselves and delete the persistent volume claims if they are no longer needed."], ["refs", "[{\"text\":\"Kubernetes Persistent Volumes\",\"url\":\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.597650"], ["id", 61]]
  [1m[35m (1.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "329030a1-3e54-50be-99c1-ff580fce5595"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.1ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "329030a1-3e54-50be-99c1-ff580fce5595"], ["created_at", "2020-10-07 21:58:19.610007"], ["updated_at", "2020-10-07 21:58:19.610007"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 62]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 62], ["created_at", "2020-10-07 21:58:19.626626"], ["updated_at", "2020-10-07 21:58:19.626626"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-74"], ["title", "Inconsistent use of CPU/RAM requests/limits"], ["description", "By default in Kubernetes, workloads that do not specify how many resources they expect to use and/or a limit to their resources receive the default settings.  The default settings depend on a LimitRange resource in the namespace, and the default is to request 1/10th of a CPU core (100 millicores or \"100m\"), no request for RAM, and no CPU or RAM limits.  This means that every pod is able to burst up to the total physical resources of the node, and the scheduler will tightly pack pods on a node.  This configuration is typically no problem at low or average load, so it might take a while to surface and cause resource constraint problems.  But when those resources are exhausted, the node becomes \"Unready\" and all workloads are evicted.  When they land on the other nodes that are already heavily loaded, it overloads them until they evict all pods.  This can cause a cascading resource failure outage."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace as $ns | .metadata.name as $name| .spec.containers[] | $ns +\"/\"+ $name +\"[\"+ .name +\"]: \"+ .resources.requests.cpu +\",\"+ .resources.limits.cpu +\",\"+ .resources.requests.memory +\",\"+ .resources.limits.memory'` to get a comma separated listing of \"CPU Req, CPU Limits, Memory Reqs, Memory Limits\" for each container in every pod.  All containers should specify all four values explicitly."], ["remediation", "\nFor every deployment in the cluster, ensure it has the proper settings for CPU and Memory \"Requests\" and CPU and Memory \"Limits\".  The \"Requests\" settings are vital for the scheduler to correctly place workloads on nodes without going over actual capacity.  The \"Limits\" settings are vital for the node to ensure the workload does not consume all physical resources on the node.  \"Requests\" should be set at 10% above average consumption and \"Limits\" should be 10-20% higher than maximum consumption.  Use \"kubectl top node\" and \"kubectl top pods --all-namespaces\" to see actual usage for running workloads."], ["refs", "[{\"text\":\"Kubernetes Resourcing\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/\",\"ref\":\"link\"},{\"text\":\"Kubectl Cheat Sheet\",\"url\":\"https://kubernetes.io/docs/reference/kubectl/cheatsheet/#interacting-with-running-pods\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.635514"], ["id", 62]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d8276fe4-4044-5077-be5c-d95fc59f6e14"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d8276fe4-4044-5077-be5c-d95fc59f6e14"], ["created_at", "2020-10-07 21:58:19.643579"], ["updated_at", "2020-10-07 21:58:19.643579"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 63]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 63], ["created_at", "2020-10-07 21:58:19.653767"], ["updated_at", "2020-10-07 21:58:19.653767"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-75"], ["title", "Ensure all pods reference container images from known sources"], ["description", "By default, Kubernetes allows users with the ability to create pods to reference any container image path, including public registries like DockerHub.  This allows developers to share and use pre-made container images easily, but it enables unvalidated and untrusted code to run inside your cluster with potential access to mounted secrets and service account tokens.  Container images should be verified to be conformant to security standards before being run, and the first step to this is to validate that all container images are being pulled from a known set of registries.  This helps development teams and security teams work from the same base location for running and validating images."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get po -A -ojsonpath='{..image}' | kubectl get pods --all-namespaces -o jsonpath='{..image}' |tr -s '[[:space:]]' '\n' | sort | uniq -c ` and ensure all images are sourced from the official Kubernetes or cloud provider registries and your own internal container registries."], ["remediation", "\nReview all deployments and pod specifications, and find any that reference non-approved container registries.  Create a dedicated container registry in your environment, validate those container images meet your security policies, and store/mirror them to that dedicated container registry/registries.  Consider enforcing image sources early with a validation step in the CI/CD pipeline and enforcing the policy with OPA/Gatekeeper or other policy-based admission controller inside the cluster."], ["refs", "[{\"text\":\"Kubectl List Images\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/list-all-running-container-images/\",\"ref\":\"link\"},{\"text\":\"DockerHub Library\",\"url\":\"https://hub.docker.com/u/library\",\"ref\":\"link\"},{\"text\":\"Google Container Registry\",\"url\":\"https://cloud.google.com/container-registry\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.659790"], ["id", 63]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "51a10d61-4108-5f95-9db4-c172cc4d03a7"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "51a10d61-4108-5f95-9db4-c172cc4d03a7"], ["created_at", "2020-10-07 21:58:19.671054"], ["updated_at", "2020-10-07 21:58:19.671054"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 64]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 64], ["created_at", "2020-10-07 21:58:19.680640"], ["updated_at", "2020-10-07 21:58:19.680640"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-76"], ["title", "Containers are not built using centralized, automated CI pipeline"], ["description", "Currently, the custom containers are built manually from an administrator's workstation and not via a centralized, automated process.  The key concern is reproducibility.  Without centralizing the source code and the code and configuration to build images, only one person with a specific laptop can build and change container images confidently."], ["platform", "k8s"], ["impact", 9], ["validation", "\nFor each running container image, ensure that there is a source control repository where it holds the instructions for how to build the image and that it leverages a CI or automated build system to generate a new image artifact.  Review the build history to ensure there are recent passing builds."], ["remediation", "\nImplement a CI system or leverage native container build services within the cloud provider to build newly tagged container images and push them to a private registry.  This ensures repeatability of the process by any member of the team as well as a shared history for build success and failures are present."], ["refs", "[{\"text\":\"GCP Cloud Build\",\"url\":\"https://cloud.google.com/cloud-build/docs/\",\"ref\":\"link\"},{\"text\":\"Google Container Registry\",\"url\":\"https://cloud.google.com/container-registry/docs/\",\"ref\":\"link\"},{\"ids\":[\"ID.SC-4\",\"ID.SC-2\",\"PR.IP-2\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.686068"], ["id", 64]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "df3d2443-7fdc-5024-a970-135a7e32d438"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "df3d2443-7fdc-5024-a970-135a7e32d438"], ["created_at", "2020-10-07 21:58:19.695005"], ["updated_at", "2020-10-07 21:58:19.695005"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 65]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 65], ["created_at", "2020-10-07 21:58:19.707049"], ["updated_at", "2020-10-07 21:58:19.707049"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-77"], ["title", "Ensure continuous container scanning and redeployment"], ["description", "When deploying container images into a Kubernetes cluster, they should first be reviewed to meet an acceptable risk profile.  This is typically done using automated container vulnerability scans at build time.  However, container deployments with infrequent needs for changes will mean that they can exist for long periods without being rebuilt in order to receive security fixes.  As the number of deployments grows, this process must be automated or it will be quickly beyond a human's ability to manage."], ["platform", "k8s"], ["impact", 9], ["validation", "\nEnsure a solution is implemented, validate that it is deployed in all clusters if needed, and verify that all container registries and images are being scanned daily (or more frequently) for new vulnerabilities.  If possible, validate that a policy is in place to alert administrators of severe vulnerabilities and even block them from being deployed."], ["remediation", "\nDeploy either a cloud provider solution or leverage a third party tool that continuously scans images in use against all current vulnerabilities.  Configure a security policy such that all high/critical vulnerabilities alert the appropriate teams.  If possible, configure the tooling to automatically trigger a new container build."], ["refs", "[{\"text\":\"Kritis\",\"url\":\"https://github.com/grafeas/kritis\",\"ref\":\"link\"},{\"text\":\"Grafeas\",\"url\":\"https://github.com/grafeas/kritis/blob/master/docs/tutorial.md\",\"ref\":\"link\"},{\"text\":\"Sysdig\",\"url\":\"https://sysdig.com\",\"ref\":\"link\"},{\"text\":\"Twistlock\",\"url\":\"https://twistlock.com\",\"ref\":\"link\"},{\"text\":\"Aqua Security\",\"url\":\"https://aquasec.com\",\"ref\":\"link\"},{\"text\":\"GKE Binary Authorization\",\"url\":\"https://cloud.google.com/binary-authorization/docs/setting-up\",\"ref\":\"link\"},{\"text\":\"GCP Container Analysis\",\"url\":\"https://cloud.google.com/container-registry/docs/container-analysis\",\"ref\":\"link\"},{\"ids\":[\"ID.SC-4\",\"ID.SC-2\",\"PR.DS-6\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.713833"], ["id", 65]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "86d03ac3-702b-567a-9407-7bd74e633bc3"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "86d03ac3-702b-567a-9407-7bd74e633bc3"], ["created_at", "2020-10-07 21:58:19.721450"], ["updated_at", "2020-10-07 21:58:19.721450"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 66]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 66], ["created_at", "2020-10-07 21:58:19.732641"], ["updated_at", "2020-10-07 21:58:19.732641"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-78"], ["title", "Cluster workloads mount the Docker socket directly"], ["description", "In Kubernetes clusters running on nodes that leverage Docker for running containers, providing access to the /var/run/docker.sock is equivalent to granting that container 'root' on the underlying host as it allows for running containers on the node with any permission.  It should not be mounted inside a container as it bridges two layers in the infrastructure that should be kept independent from each other.  With the socket mounted, cluster users do not have to have 'cluster admin' to be able to get 'root' on the nodes.  Instead, they only need the 'exec pod' permission in this namespace to be able to exec commands inside this container to become 'root' on the nodes and compromise the cluster.  In addition, many Kubernetes distributions are moving to ContainerD which does not have a listening Docker socket and therefore a smaller attack surface.  In GKE, this workload cannot operate on the newer 'COS_CONTAINERD' image types."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace as $ns | .metadata.name as $name| .spec.volumes[] |select(.hostPath.path|tostring|test(\".sock\")) | $ns +\"/\"+ $name +\"[\"+ .name +\"]: \"+ .hostPath.path'` and validate that no pods are returned that mount \"/var/run/docker.sock\" or similar."], ["remediation", "\nConsider modifying the workload or choosing another workload that does similar functionality but does not mount the Docker socket.  This will remove the attack surface added by this workload and also enable the migration to the COS_CONTAINERD image type when it becomes the default."], ["refs", "[{\"text\":\"GKE Containerd\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/using-containerd\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.738408"], ["id", 66]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7ff475ce-ef30-5d68-b04a-e96be923090a"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7ff475ce-ef30-5d68-b04a-e96be923090a"], ["created_at", "2020-10-07 21:58:19.745827"], ["updated_at", "2020-10-07 21:58:19.745827"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 67]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 67], ["created_at", "2020-10-07 21:58:19.755807"], ["updated_at", "2020-10-07 21:58:19.755807"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-79"], ["title", "Ensure privileged containers are only in system namespaces"], ["description", "Container run in Kubernetes that require deep access to the underlying worker nodes are often run in a `privileged` security context.  Common examples are daemonsets that implement functionality for container and host logging or metrics export, driver installation, and container and host security detection.  Privileged containers are essentially \"root\" on the underlying node, and they should therefore be kept in \"system\" namespaces to allow for proper RBAC and admission control policies to be created to protect them.  If they are in namespaces with other normal application workloads, it becomes difficult to ensure proper separation and prevent host escapes."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | \"(.metadata.namespace)/(.metadata.name): (.spec.containers[].securityContext.privileged)\"' | grep -v \"null$\"` and validate that all privileged pods are in namespaces named and dedicated for system workloads."], ["remediation", "\nEither leverage the `kube-system` namespace or deploy privileged daemonsets to dedicated namespaces only used for these purposes.  Restrict RBAC permissions and admission control policies to only permit the required admins access to operate and exec into them for troubleshooting."], ["refs", "[{\"text\":\"Kubernetes port-forward\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\",\"PR.PT-3\",\"PR.AT-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.761223"], ["id", 67]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3957d9b0-4a99-5b41-9520-2b7228e9d343"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3957d9b0-4a99-5b41-9520-2b7228e9d343"], ["created_at", "2020-10-07 21:58:19.770944"], ["updated_at", "2020-10-07 21:58:19.770944"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 68]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 68], ["created_at", "2020-10-07 21:58:19.780817"], ["updated_at", "2020-10-07 21:58:19.780817"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-80"], ["title", "Container images do not refer to the exact tag or commit"], ["description", "When referring to a container image stored in a registry, it's common practice for the owner of the image to tag the most recent image with a semver tag and also the `latest` tag when uploading it.  This is a convenenience for users wanting to work with the most up-to-date image, but it presents an opportunity for inconsistencies inside Kubernetes.  If a deployment with more than one replica references an image with the tag `latest`, the underlying node will pull and run that image at that time.  If the image in the registry is updated with a new `latest` image and the deployment scales the number of replicas such that a new worker node is to run it, that node will potentially pull the newer `latest` image. This could result in multiple pods in a single deployment running a different image with different functionality or even cause a difficult to trace outage.  During the image build process, it's common practice to tag the image with shortened hash from the git commit that triggered the image build to help with tracing an image directly back to the code and process that created it and to satisfy certain auditing requirements."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get po -A -ojsonpath='{..image}' | kubectl get pods --all-namespaces -o jsonpath='{..image}' |tr -s '[[:space:]]' '\n' | sort | uniq -c | grep latest` and ensure no images reference the `latest` tag."], ["remediation", "\nReview all deployments and pod specifications, and modify any that reference the `latest` tag to use a specific version tag or even the `sha256` hash.  Consider enforcing this practice early with a validation step in the CI/CD pipeline and enforcing the policy with OPA/Gatekeeper or other policy-based admission controller inside the cluster."], ["refs", "[{\"text\":\"Container Image Tagging\",\"url\":\"https://docs.docker.com/engine/reference/commandline/build/#tag-an-image--t\",\"ref\":\"link\"},{\"text\":\"Kubectl List Images\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/list-all-running-container-images/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Configuration Best Practices\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/overview/#container-images\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.786572"], ["id", 68]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "640b3852-f894-5537-b656-6bb5501f9602"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "640b3852-f894-5537-b656-6bb5501f9602"], ["created_at", "2020-10-07 21:58:19.810706"], ["updated_at", "2020-10-07 21:58:19.810706"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 69]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 69], ["created_at", "2020-10-07 21:58:19.821434"], ["updated_at", "2020-10-07 21:58:19.821434"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-81"], ["title", "Inconsistent use of Liveness and Readiness probes on pods listening on a port"], ["description", "By default, pods that listen on ports do not have Liveness and Readiness probes configured.  These are both required for pods to be able to support zero-downtime deployment upgrades for services that handle continuous traffic.  Readiness probes are network or command checks that have to succeed before the pod goes to the 'Ready' state.  This means traffic routed to them by a Service will not occur until they are 'ready' to handle that traffic successfully.  Liveness probes are network or command checks that have to succeed on a routine basis for the pod to remain in the 'Ready' state.  If the checks fail, the pod will be removed from the 'Ready' state, and the service will know not to route traffic to that pod."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace as $ns | .metadata.name as $name| .spec.containers[] | select(.ports) | $ns +\"/\"+ $name + \"[\"+ .name +\"]: \"+ (.readinessProbe.successThreshold|tostring) +\" \"+ (.livenessProbe.successThreshold|tostring)'` and ensure every container that exposes ports also has non-zero numbers representing the readiness and liveness probes."], ["remediation", "\nAll pods that listen on ports behind services should have Liveness and Readiness probes configured in their pod specification to behave properly and reduce network-related errors."], ["refs", "[{\"text\":\"Liveness and Readiness Probes\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.828405"], ["id", 69]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39a7bf62-d40d-5b79-93e3-3abc0512d3a3"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39a7bf62-d40d-5b79-93e3-3abc0512d3a3"], ["created_at", "2020-10-07 21:58:19.837515"], ["updated_at", "2020-10-07 21:58:19.837515"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 70]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 70], ["created_at", "2020-10-07 21:58:19.847181"], ["updated_at", "2020-10-07 21:58:19.847181"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-82"], ["title", "AppArmor profiles are not implemented"], ["description", "AppArmor is a Linux kernel security module that supplements the standard Linux user and group based permissions to confine programs to a limited set of resources. AppArmor can be configured for any application to reduce its potential attack surface and provide greater in-depth defense. It is configured through profiles tuned to whitelist the access needed by a specific program or container, such as Linux capabilities, network access, file permissions, etc.  AppArmor can help you to run a more secure deployment by restricting what containers are allowed to do, and/or provide better auditing through system logs. It is important to keep in mind that AppArmor is not a full exploit prevention mechanism, but it can reduce the abilities of a process inside a container that can limit further damage.  GKE nodes running Ubuntu and COS or COS_CONTAINERD have AppArmor support automatically enabled, but Kubernetes deployments must opt-in to be able to use AppArmor pods when they are run."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[].metadata | \"(.namespace)/(.name): (.annotations)\"' | grep -v apparmor` to find the pods that do not specify an apparmor profile in their annotations."], ["remediation", "\nFor all non-kube-system deployments/statefulsets, annotate the pod specification with \"container.apparmor.security.beta.kubernetes.io/<container_name>: \"runtime/default\" for each container in the pod specification.  This will enable the default AppArmor profile if the container is not running as a \"privileged\" container and afford protection against sensitive endpoints in /proc and /sys."], ["refs", "[{\"text\":\"Kubernetes AppArmor\",\"url\":\"https://kubernetes.io/docs/tutorials/clusters/apparmor/\",\"ref\":\"link\"},{\"text\":\"Docker AppArmor\",\"url\":\"https://docs.docker.com/engine/security/apparmor/\",\"ref\":\"link\"},{\"text\":\"Default AppArmor Profile\",\"url\":\"https://github.com/moby/moby/blob/master/profiles/apparmor/template.go\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-3\",\"DE.CM-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.853637"], ["id", 70]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d363bc20-2c74-582a-9bfd-8ac5bc228dbd"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d363bc20-2c74-582a-9bfd-8ac5bc228dbd"], ["created_at", "2020-10-07 21:58:19.861557"], ["updated_at", "2020-10-07 21:58:19.861557"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 71]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 71], ["created_at", "2020-10-07 21:58:19.875582"], ["updated_at", "2020-10-07 21:58:19.875582"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-83"], ["title", "Seccomp profiles are not implemented"], ["description", "Seccomp profiles define which system calls should be allowed or blocked, and the container runtime will apply then at container start time so the kernel can enforce it. Once applied, you are effectively decreasing your attack surface and limiting the container processes from making privileged syscalls in the event of a container compromise."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[].metadata | \"(.namespace)/(.name): (.annotations)\"' | grep -v seccomp` to find the pods that do not specify a seccomp profile in their annotations."], ["remediation", "\nFor all non-kube-system deployments/statefulsets, annotate the pod specification with \"container.seccomp.security.alpha.kubernetes.io/<container_name>: \"runtime/default\" for each container in the pod specification.  This will enable the default Seccomp profile if the container is not running as a \"privileged\" container and afford protection against dangerous syscalls."], ["refs", "[{\"text\":\"Kubernetes SecurityContext\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Seccomp\",\"url\":\"https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp\",\"ref\":\"link\"},{\"text\":\"Seccomp Examples\",\"url\":\"https://github.com/kubernetes/kubernetes/blob/release-1.4/docs/design/seccomp.md#examples\",\"ref\":\"link\"},{\"text\":\"Getting Started with Seccomp and Kubernetes\",\"url\":\"https://itnext.io/seccomp-in-kubernetes-part-i-7-things-you-should-know-before-you-even-start-97502ad6b6d6\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-3\",\"DE.CM-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.881557"], ["id", 71]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5ad73b30-7bdd-51a2-8f89-0354a88a0878"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5ad73b30-7bdd-51a2-8f89-0354a88a0878"], ["created_at", "2020-10-07 21:58:19.889948"], ["updated_at", "2020-10-07 21:58:19.889948"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 72]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 72], ["created_at", "2020-10-07 21:58:19.901972"], ["updated_at", "2020-10-07 21:58:19.901972"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-84"], ["title", "Namespaces do not have ResourceQuotas defined"], ["description", "ResourceQuotas can be applied to a Kubernetes namespace to ensure the resources contained inside the namespace do not exceed a desired quota.  Setting appropriate limits on each namespace can ensure workloads to not exhaust all available resources and cause an outage."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get resourcequotas --all-namespaces` and ensure each namespace has a ResourceQuota resource configured."], ["remediation", "\nIn each non-kube-system namespace, define a ResourceQuota that places limits on the maximum number of pods, CPU, and memory that can be used.  Ensure that every workload running in the namespace specifies a valid CPU and RAM requests and limits setting."], ["refs", "[{\"text\":\"Kubernetes Resource Quotas\",\"url\":\"https://kubernetes.io/docs/concepts/policy/resource-quotas/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.908085"], ["id", 72]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "870ac85c-d995-5c86-9a4f-f3b85491144b"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "870ac85c-d995-5c86-9a4f-f3b85491144b"], ["created_at", "2020-10-07 21:58:19.915099"], ["updated_at", "2020-10-07 21:58:19.915099"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 73]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.2ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 73], ["created_at", "2020-10-07 21:58:19.924617"], ["updated_at", "2020-10-07 21:58:19.924617"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-85"], ["title", "Namespaces do not have LimitRanges defined"], ["description", "LimitRanges can be applied to a Kubernetes namespace to ensure that all pods that fail to set a CPU and RAM requests and limits setting get an appropriate setting.  This ensures that pods are more accurately indicating to the Kubernetes scheduler how many actual resources they require, and that translates to nodes with more balanced workloads and avoids oversubscription situations that can cause outages."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get limitranges --all-namespaces` and ensure each namespace has a LimitRange resource configured."], ["remediation", "\nIn each non-kube-system namespace, define a LimitRange that places a minimum setting for CPU and RAM requests/limits on all workloads that fail to define their own setting."], ["refs", "[{\"text\":\"Kubernetes LimitRanges\",\"url\":\"https://kubernetes.io/docs/concepts/policy/limit-range/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.933578"], ["id", 73]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "ca95e423-1cd2-5349-b256-e66fcc5570b8"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "ca95e423-1cd2-5349-b256-e66fcc5570b8"], ["created_at", "2020-10-07 21:58:19.942869"], ["updated_at", "2020-10-07 21:58:19.942869"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 74]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 74], ["created_at", "2020-10-07 21:58:19.954153"], ["updated_at", "2020-10-07 21:58:19.954153"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-86"], ["title", "Malformed RBAC RoleBindings"], ["description", "A review of the ClusterRoleBindings and RoleBindings determined that there were incorrectly formed entries that are not enforcing a desired policy."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get clusterrolebinding -o yaml` and `kubectl get rolebinding --all-namespaces -o yaml` and review the output to ensure each has a `roleRef` and a `subjects` block with one or more entries each."], ["remediation", "\nReview each ClusterRoleBinding and Rolebinding for correctness and ensure that each one has valid `roleRef` and `subjects` blocks defined."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.965258"], ["id", 74]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "16aab1d2-3514-5377-b886-f9ff87be9f63"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "16aab1d2-3514-5377-b886-f9ff87be9f63"], ["created_at", "2020-10-07 21:58:19.979495"], ["updated_at", "2020-10-07 21:58:19.979495"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 75]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 75], ["created_at", "2020-10-07 21:58:19.992139"], ["updated_at", "2020-10-07 21:58:19.992139"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-87"], ["title", "Application-level encryption of secrets in etcd is not implemented"], ["description", "The Kubernetes API Server has the ability to leverage an external KMS provider for encryption and decryption of secrets stored inside etcd.  This provides additional protection in the event of unauthorized access to the disk or datastore where etcd maintains the cluster state.  It also ensures that the most sensitive data in etcd backups are not directly readable if stored in cloud storage buckets."], ["platform", "k8s"], ["impact", 2], ["validation", "\nFollow the instructions for your specific cloud provider's Kubernetes offering to verify that application level encryption of Kubernetes Secrets with KMS keys is configured."], ["remediation", "\nFollow the instructions for your specific cloud provider's Kubernetes offering to enable application level encryption of Kubernetes Secrets with KMS keys."], ["refs", "[{\"text\":\"Kubernetes KMS Provider\",\"url\":\"https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/\",\"ref\":\"link\"},{\"text\":\"GKE Application Secrets Encryption\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/encrypting-secrets\",\"ref\":\"link\"},{\"text\":\"EKS Application Secrets Encryption\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-1\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:19.999773"], ["id", 75]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "128b1a5e-3506-549b-a527-31a2527c976c"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "128b1a5e-3506-549b-a527-31a2527c976c"], ["created_at", "2020-10-07 21:58:20.009821"], ["updated_at", "2020-10-07 21:58:20.009821"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 76]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 76], ["created_at", "2020-10-07 21:58:20.020574"], ["updated_at", "2020-10-07 21:58:20.020574"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-88"], ["title", "Pod Disruption Budgets are not used for all critical deployments"], ["description", "Deployments with more than one replica require two critical elements to be able to handle a node failure or upgrade gracefully: Node anti-affinity to keep pods from being scheduled on the same node, and PodDisruptionBudgets (PDBs) which prevent the cluster from evicting pods unless enough other pods in that same deployment are healthy.  Without a PDB in place, a single node failure can temporarily evict too many pods and cause a service outage."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get pdb --all-namespaces` and ensure that a PDB exists for each `deployment` and `statefulset`."], ["remediation", "\nFor each workload, determine if it requires high availability for the overall service to function.  If so, configure the deployment to have at least two replicas, have node anti-affinity to tell the Kubernetes scheduler to place them on separate nodes, use a service in front of the deployments for a discoverable name to reach, and configure a PodDisruptionBudget (PDB) to ensure that either a certain percentage of replicas are available or a certain number are not unavailable."], ["refs", "[{\"text\":\"Kubernetes PodDisruptionBudgets\",\"url\":\"https://kubernetes.io/docs/tasks/run-application/configure-pdb/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.028144"], ["id", 76]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "cb315c62-1b51-5a5f-b447-73a4fa73e305"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "cb315c62-1b51-5a5f-b447-73a4fa73e305"], ["created_at", "2020-10-07 21:58:20.037455"], ["updated_at", "2020-10-07 21:58:20.037455"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 77]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 77], ["created_at", "2020-10-07 21:58:20.047462"], ["updated_at", "2020-10-07 21:58:20.047462"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-89"], ["title", "Container level malicious activity prevention/detection is not installed"], ["description", "In production Kubernetes clusters handling sensitive data, visibility into potentially malicious activity inside the containers is vital for maintaining positive control of the environment.  When a pod is compromised and actively being used to gain further access into other applications or data, it's important to be alerted immediately to be able to take defensive action to kill the pod, identify the vulnerability, fix the container, and redeploy as quickly as possible."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get daemonsets --all-namespaces -o wide` and ensure that each node has a healthy instance of the per-node agent running."], ["remediation", "\nConsider deploying a container security monitoring solution like Falco, Twistlock, or Aqua Security to monitor all nodes for container behavior that has high confidence of being malicious.  Configure it to alert to the primary on-call person for triage, and perform tuning to ensure it is not over-alerting with false positives."], ["refs", "[{\"text\":\"Sysdig\",\"url\":\"https://sysdig.com\",\"ref\":\"link\"},{\"text\":\"Falco\",\"url\":\"https://falco.org\",\"ref\":\"link\"},{\"text\":\"Palo Alto/Twistlock\",\"url\":\"https://twistlock.com\",\"ref\":\"link\"},{\"text\":\"Aqua Security\",\"url\":\"https://aquasecurity.com\",\"ref\":\"link\"},{\"ids\":[\"DE.CM-1\",\"DE.CM-4\",\"DE.CM-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.053379"], ["id", 77]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5f994da4-66b3-5b4b-a187-c67970bc112b"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5f994da4-66b3-5b4b-a187-c67970bc112b"], ["created_at", "2020-10-07 21:58:20.061359"], ["updated_at", "2020-10-07 21:58:20.061359"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 78]]
  [1m[36mTag Load (3.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 78], ["created_at", "2020-10-07 21:58:20.088887"], ["updated_at", "2020-10-07 21:58:20.088887"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-90"], ["title", "Automated Kubernetes resource backups are not configured"], ["description", "Backing up the contents of etcd is essential for backing up the desired state of the Kubernetes cluster, and it could be vital as part of a disaster recovery or security incident response plan to regain successful operation."], ["platform", "k8s"], ["impact", 9], ["validation", "\nManually validate that the backup location is being populated on the schedule desired with backup files clearly marked with the timestamp.  Ensure that the latest backup file is readable and contains the necessary data."], ["remediation", "\nInstall and configure the latest version of VMWare's Velero (formerly Heptio Ark) to export automated backups of all resources in etcd to a cloud storage bucket."], ["refs", "[{\"text\":\"VMWare Velero\",\"url\":\"https://github.com/vmware-tanzu/velero\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-4\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.094912"], ["id", 78]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3bc617f8-f8c7-5073-9d3d-ebf8cb55477a"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3bc617f8-f8c7-5073-9d3d-ebf8cb55477a"], ["created_at", "2020-10-07 21:58:20.105766"], ["updated_at", "2020-10-07 21:58:20.105766"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 79]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 79], ["created_at", "2020-10-07 21:58:20.116119"], ["updated_at", "2020-10-07 21:58:20.116119"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-91"], ["title", "Kubernetes resource backup/restore processes not exercised."], ["description", "A key step for recovering a breached cluster is having a full backup of etcd, but backups are not useful unless properly validated on a routine basis.  There are any number of misconfigurations that could result in the backup having incorrect or partial coverage, for example."], ["platform", "k8s"], ["impact", 9], ["validation", "\nEnsure the date/time of the last tested backup is within a desired timeframe (e.g. < 90 days)."], ["remediation", "\nPerform validation of the backups by testing the full restoration process on a routine basis, and configure alerts if the backup processes fail."], ["refs", "[{\"text\":\"VMWare Velero\",\"url\":\"https://github.com/vmware-tanzu/velero\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-10\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.122875"], ["id", 79]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (1.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "ed41f165-65e0-57e9-b43d-9aedd95d911a"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "ed41f165-65e0-57e9-b43d-9aedd95d911a"], ["created_at", "2020-10-07 21:58:20.134127"], ["updated_at", "2020-10-07 21:58:20.134127"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 80]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 80], ["created_at", "2020-10-07 21:58:20.149541"], ["updated_at", "2020-10-07 21:58:20.149541"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-92"], ["title", "Full operating system base images in use"], ["description", "When building container images, choosing a base image that is based on a \"full\" operating system has several downsides:\n\n* They are typically larger in size, and this increases bandwidth for pushing/pulling the image layers, storage costs, and image pull times during container startup.\n* They often contain a large number of libraries and packages that may not be used by the container application, and this can exponentially increase the effort spent tracking and patching vulnerabilities in the container.\n* They often include more administrative utilities by default such as `curl`, `wget`, and `nc` that an attacker can leverage if they get access to a running container.\n\nUsing a minimal base distribution with a small number of base packages can lead to smaller images with less vulnerabilities to patch.  Another approach is to use \"distroless\" images where the container is a \"scratch\" image with just a single compiled binary to be run."], ["platform", "k8s"], ["impact", 5], ["validation", "\nPerform a vulnerability scan of the last three minor releases of several base image types that your application could potentially use (e.g. `ubuntu` and `alpine`), and then scan the final images after your application is loaded.  Evaluate the results to find the balance between security, ease of maintenance, and application functionality."], ["remediation", "\nEnsure all container image build pipelines are configured to leverage a known set of approved base images that have minimal base packages and a track record for low vulnerability counts in the base layers.  Another approach to consider is \"Docker-Slim\" for minifying your final images based on profiling a running container and automatically stripping out unneeded components."], ["refs", "[{\"text\":\"Snyk Analysis of top base images\",\"url\":\"https://snyk.io/blog/the-top-two-most-popular-docker-base-images-each-have-over-500-vulnerabilities/\",\"ref\":\"link\"},{\"text\":\"Docker-Slim\",\"url\":\"https://github.com/docker-slim/docker-slim\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-12\",\"DE.CM-8\",\"PR.PT-3\",\"PR.IP-1\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.156733"], ["id", 80]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "cf0d95ac-b646-518d-aa8e-f216e45d7dab"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "cf0d95ac-b646-518d-aa8e-f216e45d7dab"], ["created_at", "2020-10-07 21:58:20.166485"], ["updated_at", "2020-10-07 21:58:20.166485"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 81]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 81], ["created_at", "2020-10-07 21:58:20.176894"], ["updated_at", "2020-10-07 21:58:20.176894"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-93"], ["title", "Large Number of Cluster Admins"], ["description", "The number of groups and/or users that have the RBAC permission \"cluster-admin\" should be limited to a small number of total users.  When the majority of users in a cluster are operating as administrators, it defeats the purpose for separation of duties, increases the chances for an error to cause an outage, and it violates the principle of least privilege."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get clusterrolebinding -o json | jq -r '.items[] | select((.roleRef.name==\"cluster-admin\") and .roleRef.kind==\"ClusterRole\") | .subjects[] | \"(.kind) (.namespace) (.name)\"'` and evaluate the listing to ensure it contains only the required cluster administrators."], ["remediation", "\nReduce the number of users with \"cluster-admin\" privileges to the smallest number feasible while still maintaining operational safety.  This is typically 3-6 users.  To ease administration, create groups and bind the permissions to the group."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\",\"PR.AT-2\",\"PR.IP-1\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.183645"], ["id", 81]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "6728d76f-de9a-50a2-bbee-33f4da917054"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "6728d76f-de9a-50a2-bbee-33f4da917054"], ["created_at", "2020-10-07 21:58:20.195104"], ["updated_at", "2020-10-07 21:58:20.195104"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 82]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 82], ["created_at", "2020-10-07 21:58:20.209103"], ["updated_at", "2020-10-07 21:58:20.209103"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-94"], ["title", "Ensure the Kubernetes Dashboard is not present"], ["description", "While the Kubernetes dashboard is not inherently insecure on its own, it is often coupled with a misconfiguration of RBAC permissions that can unintentionally overgrant access and is not commonly protected with `NetworkPolicies` preventing all pods from being able to reach it.  In increasingly rare circumstances, the Kubernetes dashboard is exposed publicly to the Internet."], ["platform", "k8s"], ["impact", 3], ["validation", "\nRunning `kubectl get pods --all-namespaces -l k8s-app=kubernetes-dashboard` should not return any pods."], ["remediation", "\nInstead of running a workload inside the cluster to display a UI, leverage the cloud provider's UI for listing/managing workloads or consider a tool such as Octant running on local systems.  Run `kubectl get pods --all-namespaces -l k8s-app=kubernetes-dashboard` to find pods part of deployments and use kubectl to delete those deployments."], ["refs", "[{\"text\":\"Kubernetes Dashboard\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.214837"], ["id", 82]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "b80127b9-8df6-5689-9449-18249a4e7c1f"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "b80127b9-8df6-5689-9449-18249a4e7c1f"], ["created_at", "2020-10-07 21:58:20.224780"], ["updated_at", "2020-10-07 21:58:20.224780"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 83]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 83], ["created_at", "2020-10-07 21:58:20.237443"], ["updated_at", "2020-10-07 21:58:20.237443"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-95"], ["title", "Unsupported Kubernetes Versions in use"], ["description", "The Kubernetes project is fast-moving and has historically released a minor version 3-4 times per year, and it maintains release branches for the three most recent minor releases (e.g. 1.18, 1.17, 1.16).  This means that the \"upstream\" Kubernetes project maintains security and bug fixes for a given minor release for about nine months.  When running on managed Kubernetes offerings like AKS, EKS, and GKE, the support policy is slightly different as there is a delay in validating and testing new minor releases before making them available to customers.  While it might be technically possible to be running an unsupported version, it means an upgrade is necessary to be able to get security and bug fixes, and managed providers may not be able to automatically patch your cluster on your behalf."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl version --short | grep \"^Server\"` to identify the version of the control plane."], ["remediation", "\nMaintain awareness of the latest releases relative to the current running versions.  Perform upgrade testing in a development/sandbox environment first to avoid API deprecation issues.  If using a cloud provider's managed offering, consider enabling automatic upgrades in development/sandbox environments to ease administration burden and to identify issues early.  Practice and perform upgrades routinely to ensure the process does not go stale by administrators and application owners."], ["refs", "[{\"text\":\"Kubernetes Version Support\",\"url\":\"https://kubernetes.io/docs/setup/release/version-skew-policy/\",\"ref\":\"link\"},{\"text\":\"GKE Versions\",\"url\":\"https://cloud.google.com/kubernetes-engine/versioning-and-upgrades\",\"ref\":\"link\"},{\"text\":\"EKS Versions\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/kubernetes-versions.html\",\"ref\":\"link\"},{\"text\":\"AKS Versions\",\"url\":\"https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.RA-1\",\"ID.SC-2\",\"PR.IP-1\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.244635"], ["id", 83]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "a40a1f40-0597-5ea5-b72e-005fbeea3ac6"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "a40a1f40-0597-5ea5-b72e-005fbeea3ac6"], ["created_at", "2020-10-07 21:58:20.253066"], ["updated_at", "2020-10-07 21:58:20.253066"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 84]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 84], ["created_at", "2020-10-07 21:58:20.265530"], ["updated_at", "2020-10-07 21:58:20.265530"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-96"], ["title", "Third party images should be validated for policy conformance before use"], ["description", "Container images that are not part of the default Kubernetes system components and are not owned or maintained by the organization are considered third-party images.  These images are often introduced via Helm Charts or Operators, and they should be evaluated with the same scrutiny as any base image with regards to packages, vulnerabilities, running as a non-root user, and more."], ["platform", "k8s"], ["impact", 5], ["validation", "\nIdentify images from third-party registries in use, perform vulnerability scans regularly, and validate that they follow your organization's security standards."], ["remediation", "\nIdentify container images that are not controlled by the organization and determine if their posture meets your organization's security baseline.  If they do not and the original Dockerfile and supporting assets are available in public source control, consider maintaining a \"fork\" of that image with the security modifications necessary.  Alternatively, consider submitting patches upstream to that project so that they can be automatically incorporated going forward.  Focus on containers that run as \"root\" and may need privileged access to the host first."], ["refs", "[{\"text\":\"Snyk Analysis of top base images\",\"url\":\"https://snyk.io/blog/the-top-two-most-popular-docker-base-images-each-have-over-500-vulnerabilities/\",\"ref\":\"link\"},{\"text\":\"Docker-Slim\",\"url\":\"https://github.com/docker-slim/docker-slim\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-12\",\"DE.CM-8\",\"PR.PT-3\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.272201"], ["id", 84]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "efb02cbe-f686-5e6c-b9bc-aa1fa5fee143"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "efb02cbe-f686-5e6c-b9bc-aa1fa5fee143"], ["created_at", "2020-10-07 21:58:20.280199"], ["updated_at", "2020-10-07 21:58:20.280199"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 85]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 85], ["created_at", "2020-10-07 21:58:20.290894"], ["updated_at", "2020-10-07 21:58:20.290894"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-97"], ["title", "Namespaces should be used to separate unrelated workloads"], ["description", "By default, user-managed resources will be placed in the `default` namespace.  This makes it difficult to properly define policies for RBAC permissions, service account usage, network policies, and more.  Creating dedicated namespaces and running workloads and supporting resources in each helps support proper API server permissions separation and network microsegmentation."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get all` in the `default`, `kube-public`, and if present, `kube-node-lease` namespaces.  There should only be the `kubernetes` service."], ["remediation", "\nCreate dedicated namespaces for each type of related workload, and migrate those resources into those namespaces.  Ensure that RBAC permissions are not granted at the cluster scope but per namespace for the application owners at each namespace level."], ["refs", "[{\"text\":\"Kubernetes Namespaces\",\"url\":\"https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.AC-5\",\"PR.IP-1\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.298373"], ["id", 85]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c89183b3-b5c8-57ef-af97-1d9df089335b"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c89183b3-b5c8-57ef-af97-1d9df089335b"], ["created_at", "2020-10-07 21:58:20.307505"], ["updated_at", "2020-10-07 21:58:20.307505"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 86]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 86], ["created_at", "2020-10-07 21:58:20.318410"], ["updated_at", "2020-10-07 21:58:20.318410"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 86], ["created_at", "2020-10-07 21:58:20.326119"], ["updated_at", "2020-10-07 21:58:20.326119"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-98"], ["title", "Workloads do not have dedicated Kubernetes Service Accounts"], ["description", "By default, pods that do not specify a service account have the \"default\" service account token for that namespace automatically mounted inside them.  This, by definition, becomes a shared credential that multiple workloads will use.  Similarly, workloads that do specify the same, non-default service account are also sharing credentials.  Multiple workloads sharing a service account credential makes it difficult to properly apply RBAC permissions following least privilege and also more difficult to identify which pod/deployment was responsible for an API call when reviewing audit logs during an incident."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods -o json -A | jq -r '.items[] | select(.spec.serviceAccountName!=null) | \"(.metadata.namespace)/(.metadata.name): (.spec.serviceAccountName)\"'` to help identify which pods are mapping service accounts and to see if any are shared across workloads.  For all workload namespaces, consider disabling the automounting of the \"default\" service account.  Finally, enforce the use of non-default service accounts via dynamic admission control (e.g. OPA/Gatekeeper)."], ["remediation", "\nEnsure all deployments, daemonsets, and statefulsets are only mounting a service account if necessary and ensure it is unique to that workload.  Typically, naming the deployment and the service account with the same prefix helps this process.  Also, consider configuring the namespace to prevent the default service account from being mounted."], ["refs", "[{\"text\":\"Default Mounting of Service Accounts\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\",\"PR.AC-6\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.334171"], ["id", 86]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "26577009-7e3b-5ba7-9c94-e9b8cb293075"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "26577009-7e3b-5ba7-9c94-e9b8cb293075"], ["created_at", "2020-10-07 21:58:20.343077"], ["updated_at", "2020-10-07 21:58:20.343077"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 87]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 87], ["created_at", "2020-10-07 21:58:20.353440"], ["updated_at", "2020-10-07 21:58:20.353440"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-99"], ["title", "Nodepools are not used to separate workloads of different resource profiles"], ["description", "While Kubernetes can manage workloads of different resource profiles on the same physical compute and network capacity, situations can occur where workloads can become \"noisy neighbors\" and compete for the same resources with other Pods on the same node.  Pods that run resource-intensive data processing jobs but are otherwise dormant are a good example.  Specifying inaccurate resource requests and limits can further exacerbate this issue as the scheduler may overcrowd the node."], ["platform", "k8s"], ["impact", 5], ["validation", "\nReview the resource usage of each type of workload and ensure workloads with \"bursty\" resource usage are placed on dedicated nodes.  `kubectl top nodes` and `kubectl top pods` can be helpful for point-in-time usage statistics, but observing workloads over 24-48 hrs is ideal."], ["remediation", "\nWorkloads that have variable resource needs should be physically separated from workloads with steady resource needs in terms of compute and network capacity.  The most common approach is to place a `taint` on a dedicated node pool/group and specify that `toleration` and node selector on the workloads that should only operate on that node pool.  In addition, ensure all workloads have accurate resource requests and limits assigned and that node pools/groups are configured to autoscale up to the total capacity plus 10-20% of headroom of the workloads configured to run on them."], ["refs", "[{\"text\":\"Node Selectors\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\",\"ref\":\"link\"},{\"text\":\"Taints and Tolerations\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.374272"], ["id", 87]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39a35933-b735-52f6-952d-f3903ce75ef6"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39a35933-b735-52f6-952d-f3903ce75ef6"], ["created_at", "2020-10-07 21:58:20.383740"], ["updated_at", "2020-10-07 21:58:20.383740"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 88]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 88], ["created_at", "2020-10-07 21:58:20.394176"], ["updated_at", "2020-10-07 21:58:20.394176"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-100"], ["title", "Secrets in Pod Environment Variables"], ["description", "Kubernetes pods can take statically defined environment variables, and those can often contain sensitive data like API keys and other credentials.  However, this exposes them to users and other workloads that interact with the API server who have the RBAC permission \"get pods\" in the cluster which is commonly a much wider audience than desired."], ["platform", "k8s"], ["impact", 7], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | select(.spec.containers[].env) | \"(.metadata.namespace)/(.metadata.name): (.spec.containers[].env[].value)\"'` and verify that no sensitive data is present."], ["remediation", "\nEnsure that no secret material is directly defined in Pod environment variable specifications.  Instead, store them in a Secret and use the secretKeyRef mechanism to reference them as Environment variables in the container at runtime."], ["refs", "[{\"text\":\"Kubernetes ENV Variables from Secret\",\"url\":\"https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#define-a-container-environment-variable-with-data-from-a-single-secret\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.402446"], ["id", 88]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d0031c18-5bd3-5fa2-9533-07a464e0aa6f"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d0031c18-5bd3-5fa2-9533-07a464e0aa6f"], ["created_at", "2020-10-07 21:58:20.413587"], ["updated_at", "2020-10-07 21:58:20.413587"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 89]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 89], ["created_at", "2020-10-07 21:58:20.424349"], ["updated_at", "2020-10-07 21:58:20.424349"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-101"], ["title", "RBAC Roles/ClusterRoles use Wildcards"], ["description", "When defining `Roles` and `ClusterRoles` in Kubernetes RBAC, it's possible to specify a wildcard using a `*` for both verbs and resources to simplify the policy creation process.  However, the Kubernetes API can change in subtle ways over time, and new resources and/or verbs may be introduced.  If a policy expresses \"all resources\" using a `*` and a new version of Kubernetes exposes a sensitive new resource, it may now match.  The intent of the previous policy will have been altered and potentially to an undesired effect."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get roles --all-namespaces -o json | jq -r '.items[] | . as $role | .rules[] | select(((.resources!=null) and (.resources[] | contains(\"*\")) or ((.nonResourceURLs!=null) and (.nonResourceURLs[] | contains(\"*\")))) or select(.verbs[] | contains(\"*\"))) | $role.metadata.name' | sort -u` to identify all `Roles` that specify a `*` for either resources or verbs.  Run `kubectl get clusterroles -o json | jq -r '.items[] | . as $role | .rules[] | select(((.resources!=null) and (.resources[] | contains(\"*\")) or ((.nonResourceURLs!=null) and (.nonResourceURLs[] | contains(\"*\")))) or select(.verbs[] | contains(\"*\"))) | $role.metadata.name' | sort -u` for ClusterRoles."], ["remediation", "\nReview all `ClusterRoles` and `Roles` and ensure that all resources and verbs do not use the `*` declaration.  If they do, modify that policy to decleare the explicity resources and verbs instead."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.432354"], ["id", 89]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0fb4069a-689c-53e1-a159-95c40cb065e8"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0fb4069a-689c-53e1-a159-95c40cb065e8"], ["created_at", "2020-10-07 21:58:20.442633"], ["updated_at", "2020-10-07 21:58:20.442633"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 90]]
  [1m[36mTag Load (3.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (1.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 90], ["created_at", "2020-10-07 21:58:20.467670"], ["updated_at", "2020-10-07 21:58:20.467670"]]
  [1m[35m (1.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-102"], ["title", "Pods are in an undesired state"], ["description", "Pods were identified with a current status that indicates a failure condition or an incorrect deployment configuration, and they should be corrected or removed."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -o json | jq -r '.items[] | select((.status.phase==\"Failed\") or select(.status.containerStatuses[].restartCount > 4)) | \"(.metadata.namespace)/(.metadata.name) -- Status: (.status.phase), High Restart Count: (.status.containerStatuses[].restartCount > 4)\"'` in each cluster to identify pods in an undesired state.  There should be none listed."], ["remediation", "\nFor each workload, identify the underlying cause of the failure condition.  It may need a correction to the container image, a pod specification adjustment, or the presence of a dependent resource such as a ConfigMap, a Secret, or a Persistent Volume.  Typically, the container logs (`kubectl logs`) and pod events (`kubectl describe pod) will provide the information needed to address the issue."], ["refs", "[{\"text\":\"Kubernetes Application Debugging\",\"url\":\"https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application-introspection/\",\"ref\":\"link\"},{\"text\":\"Kubernets Pod Lifecycle\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-5\",\"PR.PT-5\",\"DE.CM-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.480374"], ["id", 90]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "29b51317-7143-5795-817b-e36d1da89363"], ["LIMIT", 1]]
  [1m[35m (1.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.9ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "29b51317-7143-5795-817b-e36d1da89363"], ["created_at", "2020-10-07 21:58:20.495597"], ["updated_at", "2020-10-07 21:58:20.495597"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 91]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 91], ["created_at", "2020-10-07 21:58:20.511646"], ["updated_at", "2020-10-07 21:58:20.511646"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-103"], ["title", "Replicasets that are not part of Deployments in use"], ["description", "In all but the most custom use cases, ReplicaSets should only be used indirectly via a Deployment that manages it.  \"Bare\" ReplicaSets should be considered for migration to a full Deployment resource to take advantage of useful management features such as rolling update strategies, rollbacks, and garbage collection."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get rs --all-namespaces -o json | jq -r '.items[] | . as $rs | .metadata | select((.ownerReferences==null) or .ownerReferences[].kind!=\"Deployment\") | \"($rs.metadata.namespace)/($rs.metadata.name)\"'` and ensure there are no items listed."], ["remediation", "\nConsider redeploying the ReplicaSet as a Deployment resource."], ["refs", "[{\"text\":\"Kubernetes ReplicaSets\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Deployments\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.520664"], ["id", 91]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7b7f2133-9328-5767-8b43-3d5ac80c9192"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7b7f2133-9328-5767-8b43-3d5ac80c9192"], ["created_at", "2020-10-07 21:58:20.535961"], ["updated_at", "2020-10-07 21:58:20.535961"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 92]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 92], ["created_at", "2020-10-07 21:58:20.555915"], ["updated_at", "2020-10-07 21:58:20.555915"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-105"], ["title", "Deployments should have more than one desired replica"], ["description", "Deployments with only a single desired replica cannot maintain service during upgrades or node failures as there will always be a delay for the system to notice the pod is no longer running and when it can be scheduled on another node.  In conjunction with having a PodDisruptionBudget configured, having multiple replicas allows for continued availability of the workload during scheduled or unscheduled outages."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | select(.status.replicas==1) | \"(.metadata.namespace)/(.metadata.name)\"'` and ensure that all deployments listed can be unavailable for up to 10 minutes without harming the successful operation of the cluster or dependent workloads."], ["remediation", "\nConfigure the Deployment replica count to be 2 or greater, and ensure a PodDisruptionBudget is configured for that deployment that enforces an appropriate `minAvailable` constraint."], ["refs", "[{\"text\":\"Kubernetes PodDisruptionBudgets\",\"url\":\"https://kubernetes.io/docs/tasks/run-application/configure-pdb/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.563079"], ["id", 92]]
  [1m[35m (3.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (1.0ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "99976c03-eeca-5bba-90d4-fadeaa87c106"], ["LIMIT", 1]]
  [1m[35m (0.9ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "99976c03-eeca-5bba-90d4-fadeaa87c106"], ["created_at", "2020-10-07 21:58:20.582142"], ["updated_at", "2020-10-07 21:58:20.582142"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 93]]
  [1m[36mTag Load (2.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 93], ["created_at", "2020-10-07 21:58:20.597623"], ["updated_at", "2020-10-07 21:58:20.597623"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-106"], ["title", "Pods have a large TermintionGracePeriodSeconds set"], ["description", "When a Pod is told to exit, Kubernetes will wait `terminationGracePeriodSeconds` before sending a SIGKILL signal to the container process.  The default is 30 seconds, but it can and should be increased if the Pod requires extra time to finish processing work cleanly or to execute a PreStop Hook.  However, if the timeout is extended too far, this can cause long delays during node upgrades and rolling deployments."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods --all-namespaces -o json | jq -r '.items[] | select(.spec.terminationGracePeriodSeconds>299) | \"(.metadata.namespace)/(.metadata.name): (.spec.terminationGracePeriodSeconds)\"'` and consider the possibilities for reducing that timeout safely."], ["remediation", "\nIdentify workloads that have `terminationGracePeriodSeconds` set to 5 or more minutes and validate that they need that time.  If possible, engineer the workload to handle termination more quickly while still maintaining overall application state."], ["refs", "[{\"text\":\"Termination of Kubernetes Pods\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.605864"], ["id", 93]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "88560633-a807-54c7-ad3a-4719d665468f"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "88560633-a807-54c7-ad3a-4719d665468f"], ["created_at", "2020-10-07 21:58:20.619614"], ["updated_at", "2020-10-07 21:58:20.619614"]]
  [1m[35m (2.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (3.0ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 94]]
  [1m[36mTag Load (0.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.0ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 94], ["created_at", "2020-10-07 21:58:20.659342"], ["updated_at", "2020-10-07 21:58:20.659342"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-107"], ["title", "Critical Workloads do not have Anti-Affinity Rules set"], ["description", "Deployments and Statefulsets that require a certain number of Pods running at all times to maintain service availability should be configured with anti-affinity rules to avoid situations where multiple replicas are scheduled on the same node or in a common failure zone.  Should that node or failure zone experience an outage, an unexpected service disruption could result."], ["platform", "k8s"], ["impact", 8], ["validation", "\nRun `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | select(.spec.template.spec.affinity==null) | \"(.metadata.namespace)/(.metadata.name)\"'` and determine if affinity or anti-affinity rules are necessary to help avoid suboptimal scheduling.  Run `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | select(.spec.template.spec.affinity==null) | \"(.metadata.namespace)/(.metadata.name)\"'` for statefulsets."], ["remediation", "\nReview all Deployments and Statefulsets for criticality and determine if additional guidance should be given to the scheduler in the form of affinity and/or anti-affinity rules.  Most commonly, this is either a \"hard\" or \"soft\" requirement to ensure only one Pod of a Deployment lands on the same node."], ["refs", "[{\"text\":\"Assigning Pods to Nodes\",\"url\":\"https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.675423"], ["id", 94]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2079b140-b95a-5c1a-b1df-a273809e5047"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (4.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2079b140-b95a-5c1a-b1df-a273809e5047"], ["created_at", "2020-10-07 21:58:20.691500"], ["updated_at", "2020-10-07 21:58:20.691500"]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 95]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 95], ["created_at", "2020-10-07 21:58:20.717204"], ["updated_at", "2020-10-07 21:58:20.717204"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-108"], ["title", "Deployments/Statefulsets do not have minimum desired healthy"], ["description", "In a healthy cluster, all running pods should be active, and all Deployments and Statefulsets should have the desired number of active pods.  There are any number of reasons why the number of active replicas in a Deployment or Statefulset is not equal to the desired number, but the result is typically that the services being provided by the workload are degraded or even completely unavailable."], ["platform", "k8s"], ["impact", 8], ["validation", "\nRun `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | . as $wkl | .status.conditions[] | select((.type==\"Available\") and .status!=\"True\") | \"($wkl.metadata.namespace)/($wkl.metadata.name): (.message)\"'` to identify unhealthy workloads and investigate with `kubectl describe pod <podname>` how to alleviate the underlying issue. Run `kubectl get statefulsets --all-namespaces -o json | jq -r '.items[] | . as $wkl | .status.conditions[] | select((.type==\"Available\") and .status!=\"True\") | \"($wkl.metadata.namespace)/($wkl.metadata.name): (.message)\"'` for statefulsets."], ["remediation", "\nThe most common cause of this issue is due to insufficient cluster capacity to be able to successfully run the pod(s).  They will typically appear in the \"Pending\" state, and running `kubectl describe pod` will reveal the reason why the pod can't be scheduled.  That root cause should be addressed to allow the workload to continue operating normally.  For example, if a pod is \"Pending\" because there aren't enough CPU resources to satisfy the pods \"CPU request\", the cluster either needs additional nodes or larger nodes with greater CPU capacity."], ["refs", "[{\"text\":\"Kubernetes Deployments\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.727058"], ["id", 95]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.9ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f89d387b-a421-53a4-b5ea-142f243a4935"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f89d387b-a421-53a4-b5ea-142f243a4935"], ["created_at", "2020-10-07 21:58:20.738767"], ["updated_at", "2020-10-07 21:58:20.738767"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 96]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 96], ["created_at", "2020-10-07 21:58:20.749590"], ["updated_at", "2020-10-07 21:58:20.749590"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-109"], ["title", "Services have fewer than two healthy Endpoints"], ["description", "Cluster services that refer to pods via label selectors and port mappings will results in having `endpoint` resources created.  A healthy `service` should have at least 2 valid endpoints at all times which indicates that multiple pods are alive and actively handling requests.  Having \"none\" is an indication of misconfiguraion or outage, and having just one endpoint indicates a potential for service disruption during upgrades or node failures."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `for ns in $(kubectl get ns -o custom-columns=NAME:.metadata.name); do for svc in $(kubectl get -n $ns svc -o custom-columns=NAME:.metadata.name --no-headers); do EP=\"$(kubectl get endpoints -n $ns $svc -o json 2> /dev/null)\";if [[ \"$?\" -ne 0 ]]; then echo \"$ns/$svc has 0 endpoints\"; else echo \"$EP\" | jq -r 'select((.subsets[].addresses | length) < 2) | \"(.metadata.namespace)/(.metadata.name) has fewer than 2 endpoints\"'; fi; done; done` to identify services with fewer than 2 healthy endpoints."], ["remediation", "\nReview all services in all namespaces for having at least two valid endpoints and address the misconfiguration or number of replicas as needed to ensure the correct number are active."], ["refs", "[{\"text\":\"Debugging Services\",\"url\":\"https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/#does-the-service-have-any-endpoints\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.756102"], ["id", 96]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c5d0ad1c-feaf-5997-9fdf-c5af4dcc7543"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c5d0ad1c-feaf-5997-9fdf-c5af4dcc7543"], ["created_at", "2020-10-07 21:58:20.768314"], ["updated_at", "2020-10-07 21:58:20.768314"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 97]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 97], ["created_at", "2020-10-07 21:58:20.807408"], ["updated_at", "2020-10-07 21:58:20.807408"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.9ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-110"], ["title", "Pods in the kube-system namespace should be configured to avoid eviction"], ["description", "Pods in the `kube-system` namespace should be assigned the \"system-cluster-critical\" or \"system-node-critical\" `priorityClassName` to designate that the cluster should evict other pods not critical to the cluster or node's operation first.  When a worker node runs out of resources, it evicts the lowest priority pods that would remedy the resource exhaustion first.  Setting a `priority` at or above 2 billion (2000000000) indicates that a specific workload is critical to the functionality of the cluster."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods -n kube-system -o json | jq -r '.items[] | select(.spec.priority < 2000000000) | \"(.metadata.namespace)/(.metadata.name): (.spec.priority)\"'` and ensure no items are listed."], ["remediation", "\nReview the specifications for the pods in the `kube-system` namespace and ensure it specifies a `priorityClassName` that has a numeric priority value above 2 billion."], ["refs", "[{\"text\":\"Pod Quality of Service\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/\",\"ref\":\"link\"},{\"text\":\"Out of Resource Handling\",\"url\":\"https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/\",\"ref\":\"link\"},{\"text\":\"Guaranteed Scheduling for Critical Pods\",\"url\":\"https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.813962"], ["id", 97]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "b259e239-3547-5930-9d17-b1dc60f3a2ec"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "b259e239-3547-5930-9d17-b1dc60f3a2ec"], ["created_at", "2020-10-07 21:58:20.824310"], ["updated_at", "2020-10-07 21:58:20.824310"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 98]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 98], ["created_at", "2020-10-07 21:58:20.838668"], ["updated_at", "2020-10-07 21:58:20.838668"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-111"], ["title", "Services specifications do not have the correct naming convention set"], ["description", "For the sake of clarity and current/future support for Istio service mesh, all port names in `service` definitions need to follow a convention to aid in proper protocol identification.  For example, a service exposes TCP port 443, but it's not clear to the service mesh if that is passing plain TCP, HTTP, HTTPS, TLS, or gRPC traffic.  Naming the port `tls` or `tls-foo` makes it clear what protocol is intended to pass through this service."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get svc -A -o json | jq -r '.items[] | . as $svc | .spec.ports[] | select(.name | test(\"^grpc|^http|^mongo|^mysql|^redis|^tcp|^tls|^udp\")|not) | \"($svc.metadata.namespace)/($svc.metadata.name): (.name)\"'` and ensure no items are listed."], ["remediation", "\nReview all the ports exposed by services and ensure they follow the <protocol>[-<suffix>] naming convention."], ["refs", "[{\"text\":\"Istio Service Naming Convention\",\"url\":\"https://istio.io/docs/reference/config/analysis/ist0118/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.846044"], ["id", 98]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "af258b39-ba3c-56cf-ab22-fc0f082f9fb0"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "af258b39-ba3c-56cf-ab22-fc0f082f9fb0"], ["created_at", "2020-10-07 21:58:20.855671"], ["updated_at", "2020-10-07 21:58:20.855671"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 99]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 99], ["created_at", "2020-10-07 21:58:20.870748"], ["updated_at", "2020-10-07 21:58:20.870748"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-112"], ["title", "Containers should have ImagePullPolicy set to Always"], ["description", "Pod specifications should explicitly set the `imagePullPolicy` to `Always` to ensure the correct version of the image is always being used.  This helps avoid issues where container image tags were overwritten in the container registry but the node uses its local cached version instead.  Note that the caching semantics of the underlying image provider make even imagePullPolicy: Always efficient. With Docker, for example, if the image already exists, the pull attempt is fast because all image layers are cached and no image download is needed."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods -A -o json | jq -r '.items[] | . as $pod | .spec.containers[] | select(.imagePullPolicy!=\"Always\") | \"($pod.metadata.namespace)/($pod.metadata.name): (.name) (.imagePullPolicy)\"'` and ensure no items are listed."], ["remediation", "\nReview all containers in pod specifications and ensure the `imagePullPolicy` setting is configured to be `Always`."], ["refs", "[{\"text\":\"Kubernetes Best Practices\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/overview/#container-images\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-5\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.878882"], ["id", 99]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f46f6fd4-1a4b-562d-934b-3ef8b9f07075"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f46f6fd4-1a4b-562d-934b-3ef8b9f07075"], ["created_at", "2020-10-07 21:58:20.887464"], ["updated_at", "2020-10-07 21:58:20.887464"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 100]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 100], ["created_at", "2020-10-07 21:58:20.900743"], ["updated_at", "2020-10-07 21:58:20.900743"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-113"], ["title", "Containers should have no sensitive information in Command or Args specifications"], ["description", "Kubernetes pods can specify the `command` and `args` for a container to use at runtime, and those can often contain sensitive data like API keys and other credentials.  However, this exposes them to users and other workloads that interact with the API server who have the RBAC permission \"get pods\" in the cluster which is commonly a much wider audience than desired."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | . as $pod | .spec.containers[] | select((.command) or .args) | .command as $cmd | .args as $args | \"($pod.metadata.namespace)/($pod.metadata.name)[(.name)]: ($cmd) ($args)\"'` and review the output.  Ensure no secret material is present."], ["remediation", "\nEnsure that no secret material is directly defined in container `command` or `args` specifications.  Instead, store them in a Secret and use the secretKeyRef mechanism to reference them as files in the container at runtime."], ["refs", "[{\"text\":\"Kubernetes Container Command and Arguments\",\"url\":\"https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.908216"], ["id", 100]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d5adf736-690c-53dd-af10-67bc040f2db4"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d5adf736-690c-53dd-af10-67bc040f2db4"], ["created_at", "2020-10-07 21:58:20.918577"], ["updated_at", "2020-10-07 21:58:20.918577"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 101]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 101], ["created_at", "2020-10-07 21:58:20.933033"], ["updated_at", "2020-10-07 21:58:20.933033"]]
  [1m[35m (2.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-114"], ["title", "All resources should have a standard set of labels for ownership and purpose"], ["description", "Kubernetes resources have a standard labeling mechanism that can take arbitrary key/value pairs, and this makes tagging resources with labels for ownership, environment, data sensitivity, and more straightforward.  In addition to being able to quickly understand the intent of a workload or resource, labels can be used in the definition of security policies.  As cluster resources grow, having a standard convention for labeling resources helps keep track of things and maintain flexible policies."], ["platform", "k8s"], ["impact", 3], ["validation", "\nRun `kubectl get all -A -o json | jq -r '.items[] | \"(.kind)/(.metadata.namespace)/(.metadata.name) (.metadata.labels | tostring)\"'` and ensure all resources contain the desired labels."], ["remediation", "\nEnsure that all resources created and updated contain appropriate values for a small number of labels that make sense for the organization.  Suggested labels are `owner`, `env`, `app`, and `data` for the team responsbile, the dev/stage/prod type, the name of the application, and the sensitivity of the data in the workload, respectively.  Enforcement can be done with OPA/Gatekeeper admission control."], ["refs", "[{\"text\":\"Kubernetes Labels\",\"url\":\"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper Sample Policy\",\"url\":\"https://github.com/open-policy-agent/gatekeeper/tree/master/library/general/requiredlabels\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.AM-5\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.946347"], ["id", 101]]
  [1m[35m (2.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8ed3cd97-4415-5024-9d9a-dab55cd0fe53"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8ed3cd97-4415-5024-9d9a-dab55cd0fe53"], ["created_at", "2020-10-07 21:58:20.956853"], ["updated_at", "2020-10-07 21:58:20.956853"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 102]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 102], ["created_at", "2020-10-07 21:58:20.969893"], ["updated_at", "2020-10-07 21:58:20.969893"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-115"], ["title", "Nodeport Services directly exposed"], ["description", "While Kubernetes supports exposing pods via a port on the underlying node from the TCP/30000-32768 range via the `NodePort` service type, it's not typically the desired approach.  Typically, clusters expose a shared set of load balancers and ingress controllers to handle external service exposure via standard APIs that handle path routing, logging, access control lists, and more.  `NodePort` services require opening uncommon TCP ports in the firewall and typicaly require tight coupling of worker node IPs to be used successfully, and that becomes problematic when nodes fail or when a scale event occurs."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get svc -A -o json | jq -r '.items[] | select(.spec.type==\"NodePort\") | \"(.metadata.namespace)/(.metadata.name): (.spec.type):(.spec.ports[].nodePort)\"'` and ensure that no items are listed."], ["remediation", "\nConvert `NodePort` services into type `LoadBalancer` or consider leveraging an ingress controller to expose the service on a specific hostname and port instead."], ["refs", "[{\"text\":\"NodePort Services\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/service/#nodeport\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.DS-5\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:20.976997"], ["id", 102]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "90ce3f57-138b-566e-a61e-77c95a9a243b"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "90ce3f57-138b-566e-a61e-77c95a9a243b"], ["created_at", "2020-10-07 21:58:20.986618"], ["updated_at", "2020-10-07 21:58:20.986618"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 103]]
  [1m[36mTag Load (1.0ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 103], ["created_at", "2020-10-07 21:58:21.000678"], ["updated_at", "2020-10-07 21:58:21.000678"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-116"], ["title", "Services should have ExternalTrafficPolicy set to Local to preserve source IP address"], ["description", "In certain cloud providers, service specifications can be set to the default of 'Cluster' or 'Local'.  Cluster obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading. Local preserves the client source IP and avoids a second hop for `LoadBalancer` and `NodePort` type services, but risks potentially imbalanced traffic spreading.  Preserving the client source IP is critical to being able to perform attribution if an attacker is probing or exploiting an exposed service."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get svc -A -o json | jq -r '.items[] | select(.spec.type!=\"ClusterIP\") | \"(.metadata.namespace)/(.metadata.name): (.spec.externalTrafficPolicy)\"'` and validate that no items are listed."], ["remediation", "\nIn GCP/GKE, ensure IP Aliasing is enabled on the subnet where the cluster is created and the cluster is configured to utilize those ranges.  In AWS, using the \"Network Load Balancer\" instead of the \"Elastic Load Balancer\" in combination with this setting, the source IP can be preserved."], ["refs", "[{\"text\":\"Preserving the Source IP\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-3\",\"PR.AC-3\",\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.009083"], ["id", 103]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "95220b3a-127b-5240-aece-35c61d8bc3f9"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "95220b3a-127b-5240-aece-35c61d8bc3f9"], ["created_at", "2020-10-07 21:58:21.018763"], ["updated_at", "2020-10-07 21:58:21.018763"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 104]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 104], ["created_at", "2020-10-07 21:58:21.032441"], ["updated_at", "2020-10-07 21:58:21.032441"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-117"], ["title", "Ingresses should point to active services with multiple healthy endpoints"], ["description", "Ingress resources describe how to route traffic based on hostname and/or URI path to a desired service, and it's very easy to misconfigure an ingress configuration to point to an invalid service or an \"empty\" service."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `for entry in \"$( kubectl get ingress -A -o json | jq -r '.items[] | . as $svc | .spec | .. | .backend? | select(.!=null) | \"($svc.metadata.namespace) (.serviceName)\"')\"; do ns=\"$(echo $entry | awk '{print $1}')\"; svc=\"$(echo $entry | awk '{print $2}')\"; EP=\"$(kubectl get endpoints -n $ns $svc -o json 2> /dev/null)\"; if [[ \"$?\" -ne 0 ]]; then echo \"$ns/$svc has 0 endpoints\"; else echo \"$EP\" | jq -r 'select(.subsets) // \"(.metadata.namespace)/(.metadata.name) has fewer than 2 endpoints\"'; echo \"$EP\" | jq -r 'select(.subsets) | select((.subsets[].addresses | length) < 2) | \"(.metadata.namespace)/(.metadata.name) has fewer than 2 endpoints\"'; fi; done` and ensure that no services are listed."], ["remediation", "\nReview all ingress resource configurations, and ensure the `backend` configurations that point to a `service` are pointing to a service that exists and one that has healthy endpoints."], ["refs", "[{\"text\":\"Kubernetes Ingress\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/ingress/#the-ingress-resource\",\"ref\":\"link\"},{\"text\":\"Kubernetes Services\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/service/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.039979"], ["id", 104]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "de9455b1-f948-5a70-8645-cd9176125614"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "de9455b1-f948-5a70-8645-cd9176125614"], ["created_at", "2020-10-07 21:58:21.051233"], ["updated_at", "2020-10-07 21:58:21.051233"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 105]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 105], ["created_at", "2020-10-07 21:58:21.063943"], ["updated_at", "2020-10-07 21:58:21.063943"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-118"], ["title", "All Nodes are Ready and Schedulable"], ["description", "Healthy clusters running at optimal efficiency have all nodes in the \"Ready\" state and are actively receiving workloads.  Nodes that are not in the \"Ready\" state or are cordoned/unschedulable are incurring costs but are not contributing to the cluster's capacity."], ["platform", "k8s"], ["impact", 3], ["validation", "\nRun `kubectl get nodes -o json | jq -r '.items[] | . as $node | .status.conditions[] | select((.type==\"Ready\") and .status!=\"True\") | \"($node.metadata.name): (.message)\"'` and ensure no nodes are listed.  Also, run `kubectl get nodes -o json | jq -r '.items[] | . as $node | select(.spec.unschedulable==true) | \"($node.metadata.name): cordoned/unschedulable\"'` and validate no nodes are listed."], ["remediation", "\nRepair all unhealthy nodes, and migrate workloads off of cordoned nodes before removing nodes."], ["refs", "[{\"text\":\"Node Cordoning\",\"url\":\"https://kubernetes.io/docs/concepts/architecture/nodes/#manual-node-administration\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.071966"], ["id", 105]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7230ef0b-0924-509b-9b12-6c245add2d06"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7230ef0b-0924-509b-9b12-6c245add2d06"], ["created_at", "2020-10-07 21:58:21.083866"], ["updated_at", "2020-10-07 21:58:21.083866"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 106]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 106], ["created_at", "2020-10-07 21:58:21.095803"], ["updated_at", "2020-10-07 21:58:21.095803"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-119"], ["title", "All Nodes are running the identical OS, Image, and Version"], ["description", "To ensure consistent and reliable operation of the cluster and its workloads, the worker nodes should be running identical versions of the operating system image, kernel version, kube-proxy version, and kubelet version for each node pool or operating system type."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get nodes -o json | jq -r '.items[] | \"(.status.nodeInfo.containerRuntimeVersion)|(.status.nodeInfo.kernelVersion)|(.status.nodeInfo.kubeProxyVersion)|(.status.nodeInfo.kubeletVersion)|(.status.nodeInfo.osImage)\"' | wc -l` and ensure the output equals \"1\" to indicate that all nodes are identical.  Clusters that have multiple node pools or mixed operating system types should have one line count per nodepool or OS type."], ["remediation", "\nUpgrade all nodes of each node pool to a common version for each underlying component.  Mixed operating system clusters should have identical versions per operating system."], ["refs", "[{\"text\":\"Kubernetes Version Skew Support\",\"url\":\"https://kubernetes.io/docs/setup/release/version-skew-policy/\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\",\"PR.IP-1\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.104999"], ["id", 106]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f0521c23-989d-53f5-bd2f-c235b6b4abe3"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f0521c23-989d-53f5-bd2f-c235b6b4abe3"], ["created_at", "2020-10-07 21:58:21.128692"], ["updated_at", "2020-10-07 21:58:21.128692"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 107]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 107], ["created_at", "2020-10-07 21:58:21.143035"], ["updated_at", "2020-10-07 21:58:21.143035"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-120"], ["title", "All Nodes have > 20% capacity allocatable"], ["description", "Kubernetes can pack workloads tightly onto nodes for excellent resource efficiency, but overutilized nodes are more prone to exhausting available resources. This can cause other colocated applications to run more slowly or even cause the kubelet to become unhealthy and evict workloads.  In addition, clusters should always have at least one node's worth of excess capacity ready to gracefully handle workloads rescheduled due to node maintenance or evictions."], ["platform", "k8s"], ["impact", 7], ["validation", "\nRun `echo \"Node CPU Memory\"; kubectl top nodes --no-headers | awk '{print $1\" \"$3\" \"$5}'` and ensure that CPU and Memory are below 80% for all nodes."], ["remediation", "\nEnsure allocated capacity per node remains below 80%, and ensure that workloads are scheduled evenly across nodes.  Consider scaling the number of nodes up to ensure the total workload doesn't exceed 80% of the total cluster capacity."], ["refs", "[{\"text\":\"Kubernetes Metrics Server\",\"url\":\"https://kubernetes.io/docs/tasks/debug-application-cluster/resource-metrics-pipeline/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.150455"], ["id", 107]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5f226c37-de2c-56a0-8e19-3c94a23a9d7a"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5f226c37-de2c-56a0-8e19-3c94a23a9d7a"], ["created_at", "2020-10-07 21:58:21.159896"], ["updated_at", "2020-10-07 21:58:21.159896"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 108]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 108], ["created_at", "2020-10-07 21:58:21.173010"], ["updated_at", "2020-10-07 21:58:21.173010"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-121"], ["title", "All Nodes are spread evenly across availability zones"], ["description", "When running Kubernetes clusters on cloud providers, production clusters should have their nodes spread as evenly as possible across multiple availability-zones in a given region.  Coupled with anti-affinity rules on critical workloads and multi-zone aware persistent-volumes, it's possible to withstand a single availability-zone outage should one occur."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get nodes -ojson | jq -r '.items[].metadata | select(.annotations.\"failure-domain.beta.kubernetes.io/zone\") | \"(.name): (.annotations.\"failure-domain.beta.kubernetes.io/zone\")\"'` and validate there are multiple availability zones listed and an equal (or near equal) number of nodes in each."], ["remediation", "\nConfigure the node pool/groups to leverage multiple availability zones.  Three zones are recommended in most cases.  Most cloud providers have a configuration option for spreading nodes of the same group across multiple availability zones."], ["refs", "[{\"text\":\"Kubernetes Node Labels\",\"url\":\"https://kubernetes.io/docs/reference/kubernetes-api/labels-annotations-taints/#topologykubernetesiozone\",\"ref\":\"link\"},{\"text\":\"AKS Multiple AZ Node Groups\",\"url\":\"https://docs.microsoft.com/en-us/azure/aks/availability-zones#create-an-aks-cluster-across-availability-zones\",\"ref\":\"link\"},{\"text\":\"EKS Multiple AZ Node Pools\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/create-managed-node-group.html\",\"ref\":\"link\"},{\"text\":\"GKE Multiple AZ Node Pools\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/creating-a-regional-cluster\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.179338"], ["id", 108]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "390bbf33-bc2c-514d-a878-e1d17282157f"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "390bbf33-bc2c-514d-a878-e1d17282157f"], ["created_at", "2020-10-07 21:58:21.187761"], ["updated_at", "2020-10-07 21:58:21.187761"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 109]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 109], ["created_at", "2020-10-07 21:58:21.200693"], ["updated_at", "2020-10-07 21:58:21.200693"]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-122"], ["title", "Local disk PersistentVolumes should not mount sensitive host paths"], ["description", "While pods can be configured to mount a directory of the underlying worker node's filesystem to \"escape\" from the container, another similar pathway is by manually creating a \"Local/HostPath\" persistent volume and mounting it into the pod.  PodSecurityPolicy has native controls for the former approach, but it cannot prevent the latter.  The approach requires RBAC permissions to either create or use a custom storageclass, manually create or use a custom persistent volume, and permissions to create pods, so it is less likely to be available to non-privileged users."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pv -o json | jq -r '.items[] | select(.spec.hostPath) | \"(.metadata.name): (.spec.hostPath.path)\"'` and `kubectl get pv -o json | jq -r '.items[] | select(.spec.local) | \"(.metadata.name): (.spec.local.path)\"'` and verify that no entries are listed."], ["remediation", "\nEnsure that permissions for creating custom storage classes are only granted to cluster admins, and review all storage classes and currently bound persistent volumes do not permit mounting sensitive paths on the underlying nodes in pod specifications.  Consider enforcing with a dynamic admission controller such as OPA/Gatekeeper."], ["refs", "[{\"text\":\"Kubernetes Local Persistent Volumes\",\"url\":\"https://kubernetes.io/docs/concepts/storage/volumes/#local\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.208928"], ["id", 109]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c578b676-324d-51fe-ac5c-2af5a73044d6"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c578b676-324d-51fe-ac5c-2af5a73044d6"], ["created_at", "2020-10-07 21:58:21.217476"], ["updated_at", "2020-10-07 21:58:21.217476"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 110]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 110], ["created_at", "2020-10-07 21:58:21.232902"], ["updated_at", "2020-10-07 21:58:21.232902"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-123"], ["title", "Only approved Mutating/ValidatingWebHookConfigurations in use"], ["description", "Mutating and Validating Webhooks (Webhooks) are powerful extensions to the API server request flow, and they are typically used for adding functionality to resources before they are persisted and for enforcing security policy by way of dynamic admission controllers.  Because they defer authorization to an arbitrary location and get a full copy of the request, they can potentially see sensitive information.  They also can introduce latency in the API requiest flow as the API server needs to get a response or wait for a timeout before allowing the request to proceed.  Therefore, their usage should be limited to the smallest number necessary."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get mutatingwebhookconfiguration -A -oyaml` and `kubectl get validatingwebhookconfiguration -A -oyaml` and ensure the listed entries are desired."], ["remediation", "\nReview the current configuration and ensure only the desired and authorized Webhooks are installed and that they are only watching the specific resourcesneeded."], ["refs", "[{\"text\":\"Dynamic Admission Control\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.240603"], ["id", 110]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "16bf3c73-d5c7-5f71-abc2-e440f81c761b"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "16bf3c73-d5c7-5f71-abc2-e440f81c761b"], ["created_at", "2020-10-07 21:58:21.248800"], ["updated_at", "2020-10-07 21:58:21.248800"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 111]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.0ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 111], ["created_at", "2020-10-07 21:58:21.259456"], ["updated_at", "2020-10-07 21:58:21.259456"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-124"], ["title", "PersistentVolumes should use cross-zone/Regional StorageClasses"], ["description", "Where possible, deployments and statefulsets that mount persistent volumes should be using storageclasses that support being mounted in multiple zones.  By default, cloud provider network attached storage disks are only available in a single zone.  Should a zone experience a failure or outage, that data cannot be remounted by a pod until a healthy node in that zone returns unless that disk is configured as a type that should be replicated automatically."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get storageclass -o json | jq -r '.items[]'` and review the storage classes available inside the cluster and their settings to see if regional support (vs single zone) is configured.  Then run `kubectl get deployments -A -o json | jq -r '.items[] | .spec.template.spec.volumes'` and `kubectl get sts -A -o json | jq -r '.items[] | .spec.template.spec.volumes'` to see which types of storageclass for persistent volumes are in use."], ["remediation", "\nIf supported, configure the storageclass to support multiple zones and ensure that all critical deployments and statefulsets are configured to use them."], ["refs", "[{\"text\":\"Kubernetes Persistent Volumes\",\"url\":\"https://kubernetes.io/docs/concepts/storage/volumes/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Storageclasses\",\"url\":\"https://kubernetes.io/docs/concepts/storage/storage-classes/\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.267865"], ["id", 111]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d62c8685-fcf8-5cec-941a-0c07c7db2eb6"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d62c8685-fcf8-5cec-941a-0c07c7db2eb6"], ["created_at", "2020-10-07 21:58:21.277357"], ["updated_at", "2020-10-07 21:58:21.277357"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 112]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 112], ["created_at", "2020-10-07 21:58:21.290653"], ["updated_at", "2020-10-07 21:58:21.290653"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-125"], ["title", "CronJobs/Jobs should be healthy"], ["description", "Jobs and CronJobs can often become unhealthy over time and may go unnoticed unless manually reviewed.  A common example is that of the VMWare Valero backup job to backup the contents of etcd to an external location like a cloud storage bucket.  Without that backup running successfully at a regular interval, the ability to restore the cluster to a recent state in a failure situation is compromised."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get job -A -ojson | jq -r '.items[] | select(.status.conditions) | select(.status.conditions[].type==\"Failed\" and .status.conditions[].status==\"True\") | \"(.metadata.namespace)/(.metadata.name) failed: (.status.conditions[].message)\"'` and `kubectl get cronjob -A -ojson | jq -r '.items[] | select(.status.conditions) | select(.status.conditions[].type==\"Failed\" and .status.conditions[].status==\"True\") | \"(.metadata.namespace)/(.metadata.name) failed: (.status.conditions[].message)\"'` and ensure no entries are listed."], ["remediation", "\nManually examine all CronJobs and Jobs resources for a successful execution history and resolve any issues identified.  If the Job is no longer needed, remove it."], ["refs", "[{\"text\":\"Kubernetes Jobs\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.298872"], ["id", 112]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0991c5c8-2e42-5237-a66b-c0b7ad84317d"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0991c5c8-2e42-5237-a66b-c0b7ad84317d"], ["created_at", "2020-10-07 21:58:21.308897"], ["updated_at", "2020-10-07 21:58:21.308897"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 113]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 113], ["created_at", "2020-10-07 21:58:21.319593"], ["updated_at", "2020-10-07 21:58:21.319593"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-126"], ["title", "Nodes should have only one valid Certificate Signing Request"], ["description", "Some Kubernetes clusters initially provision their nodes using \"bootstrap\" credentials that are just used to create and issue a certificate signing request via the Kubernetes API for a certificate keypair to be used by that node's kubelet process.  This should be a one-time event, but it may be possible for an attacker that has compromised a worker node to generate a second keypair and impersonate the kubelet.  This process would leave traces by way of the API server having more than one valid CSR entry for that node."], ["platform", "k8s"], ["impact", 3], ["validation", "\nThe output of `kubectl get nodes --no-headers | wc -l` and `kubectl get csr -A -o json | jq -r '.items[] | select(.spec.groups) | select(.spec.groups[] | contains(\"system:nodes\")) | .spec.username' | sort -u | wc -l` should be identical, signaling that only one per node has been created."], ["remediation", "\nPeriodically inspect the certificate signing requests used by bootstrap credentials to ensure that only one has been created.  If more than one is present, validate the details of each one to see if it was potentially created by a malicious user."], ["refs", "[{\"text\":\"Kubernetes Certificate Signing Requests\",\"url\":\"https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/#create-a-certificate-signing-request\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-6\",\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.325919"], ["id", 113]]
  [1m[35m (1.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "da93b32f-bb47-51a9-b6ac-4ce2aa5936c5"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "da93b32f-bb47-51a9-b6ac-4ce2aa5936c5"], ["created_at", "2020-10-07 21:58:21.337860"], ["updated_at", "2020-10-07 21:58:21.337860"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 114]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 114], ["created_at", "2020-10-07 21:58:21.348902"], ["updated_at", "2020-10-07 21:58:21.348902"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-127"], ["title", "RBAC Roles/ClusterRoles should not grant permissions to system:anonymous"], ["description", "The built-in group named `system:anonymous` includes any user, group, or service account without a valid credential to the API server.  In earlier versions of Kubernetes, this \"meta\" group had a small number of permissions related to API discovery, but it is no longer intended for direct use.  This group should not be used to grant permissions to cluster subjects in nearly any legitimate situation, but it can occur by mistake and lead to unnecessary pathways to data leakage and privilege escalation."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get clusterrolebinding -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:anonymous\" and .kind==\"Group\") | $crb.roleRef.name'` and `kubectl get rolebinding -A -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:anonymous\" and .kind==\"Group\") | $crb.roleRef.name'` and validate that no entries are listed that would indicate non-standard permissions were granted."], ["remediation", "\nReview the permissions on the `system:anonymous` group and ensure that it has no granted permissions.  Remove or modify any ClusterRoleBinding that grants additional permissions, and grant permissions directly to authenticated users, groups, or service accounts instead."], ["refs", "[{\"text\":\"Kubernetes API Discovery Roles\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#discovery-roles\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-4\",\"PR.AC-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.354649"], ["id", 114]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7314bdf0-27f6-5102-a381-3bce416deb98"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7314bdf0-27f6-5102-a381-3bce416deb98"], ["created_at", "2020-10-07 21:58:21.365885"], ["updated_at", "2020-10-07 21:58:21.365885"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 115]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 115], ["created_at", "2020-10-07 21:58:21.377420"], ["updated_at", "2020-10-07 21:58:21.377420"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-128"], ["title", "RBAC Permissions for system:authenticated should not be elevated"], ["description", "The built-in group named `system:authenticated` includes any user, group, or service account with a valid credential to the API server.  This \"meta\" group is useful for providing a baseline set of permissions that all cluster users, groups, and service accounts need for API discovery purposes.  This group should not be used to grant additional permissions to cluster subjects beyond the defaults, but it can occur by mistake and lead to unnecessary pathways to data leakage and privilege escalation."], ["platform", "k8s"], ["impact", 8], ["validation", "\nRun `kubectl get clusterrolebinding -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:authenticated\" and .kind==\"Group\") | $crb.roleRef.name' | egrep -v \"system:basic-user|system:discovery|system:public-info-viewer\"` and `kubectl get rolebinding -A -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:authenticated\" and .kind==\"Group\") | $crb.roleRef.name' | egrep -v \"system:basic-user|system:discovery|system:public-info-viewer\"` to ensure no additional ClusterRoles or Roles have been granted to `system:authenticated`.  You can also run `kubectl auth can-i --list --as=system:authenticated` to see the current list of permissions."], ["remediation", "\nReview the permissions on the `system:authenticated` group and ensure that it is only bound to the baseline ClusterRoles: `system:basic-user`, `system:discovery`, and `system:public-info-viewer`.  Remove or modify any ClusterRoleBinding that grants additional permissions beyond these, and grant permissions directly to users, groups, or service accounts instead."], ["refs", "[{\"text\":\"Kubernetes API Discovery Roles\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#discovery-roles\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-4\",\"PR.AC-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.384051"], ["id", 115]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "fa458515-7fca-52fb-b080-bec839be4779"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "fa458515-7fca-52fb-b080-bec839be4779"], ["created_at", "2020-10-07 21:58:21.392445"], ["updated_at", "2020-10-07 21:58:21.392445"]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 116]]
  [1m[36mTag Load (2.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 116], ["created_at", "2020-10-07 21:58:21.418765"], ["updated_at", "2020-10-07 21:58:21.418765"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-129"], ["title", "Tiller (Helm v2) should not be deployed"], ["description", "Helm version 1.x and 2.x rely on an in-cluster deployment named `Tiller` to handle lifecycle management of Kubernetes application bundles called `charts`.  The `Tiller` deployment is commonly granted elevated privileges to be able to carry out creation/deletion of resources contained inside `charts`, and it exposes a gRPC port on TCP/44134 without authentication or authorization, by default.  This combination was common, and it afforded a simple and direct path to escalation to cluster-admin from any pod in the cluster.  Now that Helm v3 no longer relies on an in-cluster component, `Tiller` is a signal that the cluster administrators have not upgraded to the more secure version."], ["platform", "k8s"], ["impact", 10], ["validation", "\nRun `kubectl get pods --all-namespaces -o name | grep tiller` and validate that no pods starting with the name `tiller-deploy-****` exist."], ["remediation", "\nRefer to https://helm.sh/docs/topics/v2_v3_migration/ for guidance on migrating away from `Tiller`.  For new cluster deployments, use Helm v3 and above going forward."], ["refs", "[{\"text\":\"Helm\",\"url\":\"https://helm.sh\",\"ref\":\"link\"},{\"text\":\"Tiller v2\",\"url\":\"https://helm.sh/docs/faq/#removal-of-tiller\",\"ref\":\"link\"},{\"text\":\"Helm Migration from v2 to v3\",\"url\":\"https://helm.sh/docs/topics/v2_v3_migration/\",\"ref\":\"link\"},{\"text\":\"Misusing Tiller\",\"url\":\"https://engineering.bitnami.com/articles/helm-security.html\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.DS-2\",\"PR.IP-1\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:21.426742"], ["id", 116]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE DATABASE "opencspm_development" ENCODING = 'unicode'[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE DATABASE "opencspm_test" ENCODING = 'unicode'[0m
  [1m[35m (0.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35m (0.3ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35m (0.7ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", "environment"]]
  [1m[35mSQL (0.3ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (7.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "campaigns" CASCADE[0m
  [1m[35m (8.5ms)[0m  [1m[35mCREATE TABLE "campaigns" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "user_id" bigint NOT NULL, "filters" jsonb, "control_count" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_name" ON "campaigns"  ("name")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_organization_id" ON "campaigns"  ("organization_id")[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_user_id" ON "campaigns"  ("user_id")[0m
  [1m[35m (2.9ms)[0m  [1m[35mDROP TABLE IF EXISTS "controls" CASCADE[0m
  [1m[35m (4.7ms)[0m  [1m[35mCREATE TABLE "controls" ("id" bigserial primary key, "guid" character varying, "name" character varying, "title" character varying, "description" text, "platform" character varying, "impact" integer, "validation" character varying, "remediation" character varying, "refs" jsonb, "status" integer DEFAULT 0, "resources_failed" integer DEFAULT 0, "resources_total" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_guid" ON "controls"  ("guid")[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_name" ON "controls"  ("name")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_platform" ON "controls"  ("platform")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_title" ON "controls"  ("title")[0m
  [1m[35m (1.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "identities" CASCADE[0m
  [1m[35m (7.1ms)[0m  [1m[35mCREATE TABLE "identities" ("id" bigserial primary key, "user_id" bigint NOT NULL, "provider" character varying, "uid" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_identities_on_user_id" ON "identities"  ("user_id")[0m
  [1m[35m (3.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "issues" CASCADE[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE TABLE "issues" ("id" bigserial primary key, "status" integer, "result_id" bigint NOT NULL, "resource_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_resource_id" ON "issues"  ("resource_id")[0m
  [1m[35m (5.7ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_result_id" ON "issues"  ("result_id")[0m
  [1m[35m (2.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "jobs" CASCADE[0m
  [1m[35m (3.9ms)[0m  [1m[35mCREATE TABLE "jobs" ("id" bigserial primary key, "token" character varying, "status" integer, "issue_count" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_jobs_on_token" ON "jobs"  ("token")[0m
  [1m[35m (1.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "organizations" CASCADE[0m
  [1m[35m (5.9ms)[0m  [1m[35mCREATE TABLE "organizations" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_organizations_on_name" ON "organizations"  ("name")[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "profiles" CASCADE[0m
  [1m[35m (4.6ms)[0m  [1m[35mCREATE TABLE "profiles" ("id" bigserial primary key, "name" character varying, "author" character varying, "platform" character varying, "tags" jsonb, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "resources" CASCADE[0m
  [1m[35m (6.9ms)[0m  [1m[35mCREATE TABLE "resources" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE  INDEX  "index_resources_on_name" ON "resources"  ("name")[0m
  [1m[35m (1.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "results" CASCADE[0m
  [1m[35m (5.0ms)[0m  [1m[35mCREATE TABLE "results" ("id" bigserial primary key, "job_id" bigint NOT NULL, "data" jsonb, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL, "observed_at" timestamp(6))[0m
  [1m[35m (10.2ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_control_id" ON "results"  ("control_id")[0m
  [1m[35m (9.0ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_job_id" ON "results"  ("job_id")[0m
  [1m[35m (7.4ms)[0m  [1m[35mDROP TABLE IF EXISTS "roles" CASCADE[0m
  [1m[35m (7.9ms)[0m  [1m[35mCREATE TABLE "roles" ("id" bigserial primary key, "name" character varying, "resource_type" character varying, "resource_id" bigint, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_name_and_resource_type_and_resource_id" ON "roles"  ("name", "resource_type", "resource_id")[0m
  [1m[35m (3.3ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_resource_type_and_resource_id" ON "roles"  ("resource_type", "resource_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mDROP TABLE IF EXISTS "sources" CASCADE[0m
  [1m[35m (5.3ms)[0m  [1m[35mCREATE TABLE "sources" ("id" bigserial primary key, "name" character varying, "location" character varying, "status" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mDROP TABLE IF EXISTS "taggings" CASCADE[0m
  [1m[35m (3.8ms)[0m  [1m[35mCREATE TABLE "taggings" ("id" bigserial primary key, "tag_id" bigint NOT NULL, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_control_id" ON "taggings"  ("control_id")[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_tag_id" ON "taggings"  ("tag_id")[0m
  [1m[35m (1.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "tags" CASCADE[0m
  [1m[35m (6.3ms)[0m  [1m[35mCREATE TABLE "tags" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (4.0ms)[0m  [1m[35mDROP TABLE IF EXISTS "users" CASCADE[0m
  [1m[35m (4.3ms)[0m  [1m[35mCREATE TABLE "users" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "username" character varying DEFAULT '' NOT NULL, "password_digest" character varying DEFAULT '' NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_users_on_organization_id" ON "users"  ("organization_id")[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE UNIQUE INDEX  "index_users_on_username" ON "users"  ("username")[0m
  [1m[35m (1.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "users_roles" CASCADE[0m
  [1m[35m (3.2ms)[0m  [1m[35mCREATE TABLE "users_roles" ("user_id" bigint, "role_id" bigint)[0m
  [1m[35m (5.6ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_role_id" ON "users_roles"  ("role_id")[0m
  [1m[35m (3.5ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id_and_role_id" ON "users_roles"  ("user_id", "role_id")[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id" ON "users_roles"  ("user_id")[0m
  [1m[35m (3.1ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_a74bb03c49"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (1.6ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_9eb8249bf2"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.7ms)[0m  [1m[35mALTER TABLE "identities" ADD CONSTRAINT "fk_rails_5373344100"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.9ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_41670766b9"
FOREIGN KEY ("resource_id")
  REFERENCES "resources" ("id")
[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_0da50c43eb"
FOREIGN KEY ("result_id")
  REFERENCES "results" ("id")
[0m
  [1m[35m (2.5ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_efb2ffdf17"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_66a308b2c3"
FOREIGN KEY ("job_id")
  REFERENCES "jobs" ("id")
[0m
  [1m[35m (2.1ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_b9f82f696d"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.7ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_9fcd2e236b"
FOREIGN KEY ("tag_id")
  REFERENCES "tags" ("id")
[0m
  [1m[35m (1.8ms)[0m  [1m[35mALTER TABLE "users" ADD CONSTRAINT "fk_rails_d7b9ff90af"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (0.4ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "schema_sha1"], ["LIMIT", 1]]
  [1m[35mSQL (0.4ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (4.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "campaigns" CASCADE[0m
  [1m[35m (5.1ms)[0m  [1m[35mCREATE TABLE "campaigns" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "user_id" bigint NOT NULL, "filters" jsonb, "control_count" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_name" ON "campaigns"  ("name")[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_organization_id" ON "campaigns"  ("organization_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE  INDEX  "index_campaigns_on_user_id" ON "campaigns"  ("user_id")[0m
  [1m[35m (2.7ms)[0m  [1m[35mDROP TABLE IF EXISTS "controls" CASCADE[0m
  [1m[35m (4.4ms)[0m  [1m[35mCREATE TABLE "controls" ("id" bigserial primary key, "guid" character varying, "name" character varying, "title" character varying, "description" text, "platform" character varying, "impact" integer, "validation" character varying, "remediation" character varying, "refs" jsonb, "status" integer DEFAULT 0, "resources_failed" integer DEFAULT 0, "resources_total" integer DEFAULT 0, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_guid" ON "controls"  ("guid")[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_name" ON "controls"  ("name")[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_platform" ON "controls"  ("platform")[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_controls_on_title" ON "controls"  ("title")[0m
  [1m[35m (1.9ms)[0m  [1m[35mDROP TABLE IF EXISTS "identities" CASCADE[0m
  [1m[35m (5.6ms)[0m  [1m[35mCREATE TABLE "identities" ("id" bigserial primary key, "user_id" bigint NOT NULL, "provider" character varying, "uid" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_identities_on_user_id" ON "identities"  ("user_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "issues" CASCADE[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE TABLE "issues" ("id" bigserial primary key, "status" integer, "result_id" bigint NOT NULL, "resource_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_resource_id" ON "issues"  ("resource_id")[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE  INDEX  "index_issues_on_result_id" ON "issues"  ("result_id")[0m
  [1m[35m (1.9ms)[0m  [1m[35mDROP TABLE IF EXISTS "jobs" CASCADE[0m
  [1m[35m (5.6ms)[0m  [1m[35mCREATE TABLE "jobs" ("id" bigserial primary key, "token" character varying, "status" integer, "issue_count" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_jobs_on_token" ON "jobs"  ("token")[0m
  [1m[35m (1.8ms)[0m  [1m[35mDROP TABLE IF EXISTS "organizations" CASCADE[0m
  [1m[35m (4.6ms)[0m  [1m[35mCREATE TABLE "organizations" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.9ms)[0m  [1m[35mCREATE  INDEX  "index_organizations_on_name" ON "organizations"  ("name")[0m
  [1m[35m (1.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "profiles" CASCADE[0m
  [1m[35m (6.3ms)[0m  [1m[35mCREATE TABLE "profiles" ("id" bigserial primary key, "name" character varying, "author" character varying, "platform" character varying, "tags" jsonb, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (1.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "resources" CASCADE[0m
  [1m[35m (4.2ms)[0m  [1m[35mCREATE TABLE "resources" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_resources_on_name" ON "resources"  ("name")[0m
  [1m[35m (1.5ms)[0m  [1m[35mDROP TABLE IF EXISTS "results" CASCADE[0m
  [1m[35m (4.0ms)[0m  [1m[35mCREATE TABLE "results" ("id" bigserial primary key, "job_id" bigint NOT NULL, "data" jsonb, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL, "observed_at" timestamp(6))[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_control_id" ON "results"  ("control_id")[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE  INDEX  "index_results_on_job_id" ON "results"  ("job_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mDROP TABLE IF EXISTS "roles" CASCADE[0m
  [1m[35m (4.6ms)[0m  [1m[35mCREATE TABLE "roles" ("id" bigserial primary key, "name" character varying, "resource_type" character varying, "resource_id" bigint, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_name_and_resource_type_and_resource_id" ON "roles"  ("name", "resource_type", "resource_id")[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_roles_on_resource_type_and_resource_id" ON "roles"  ("resource_type", "resource_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mDROP TABLE IF EXISTS "sources" CASCADE[0m
  [1m[35m (4.7ms)[0m  [1m[35mCREATE TABLE "sources" ("id" bigserial primary key, "name" character varying, "location" character varying, "status" integer, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.6ms)[0m  [1m[35mDROP TABLE IF EXISTS "taggings" CASCADE[0m
  [1m[35m (3.3ms)[0m  [1m[35mCREATE TABLE "taggings" ("id" bigserial primary key, "tag_id" bigint NOT NULL, "control_id" bigint NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.8ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_control_id" ON "taggings"  ("control_id")[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE  INDEX  "index_taggings_on_tag_id" ON "taggings"  ("tag_id")[0m
  [1m[35m (2.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "tags" CASCADE[0m
  [1m[35m (7.9ms)[0m  [1m[35mCREATE TABLE "tags" ("id" bigserial primary key, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (3.3ms)[0m  [1m[35mDROP TABLE IF EXISTS "users" CASCADE[0m
  [1m[35m (6.3ms)[0m  [1m[35mCREATE TABLE "users" ("id" bigserial primary key, "name" character varying, "organization_id" bigint NOT NULL, "username" character varying DEFAULT '' NOT NULL, "password_digest" character varying DEFAULT '' NOT NULL, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE  INDEX  "index_users_on_organization_id" ON "users"  ("organization_id")[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE UNIQUE INDEX  "index_users_on_username" ON "users"  ("username")[0m
  [1m[35m (4.0ms)[0m  [1m[35mDROP TABLE IF EXISTS "users_roles" CASCADE[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE TABLE "users_roles" ("user_id" bigint, "role_id" bigint)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_role_id" ON "users_roles"  ("role_id")[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id_and_role_id" ON "users_roles"  ("user_id", "role_id")[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE  INDEX  "index_users_roles_on_user_id" ON "users_roles"  ("user_id")[0m
  [1m[35m (2.4ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_a74bb03c49"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (1.9ms)[0m  [1m[35mALTER TABLE "campaigns" ADD CONSTRAINT "fk_rails_9eb8249bf2"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.6ms)[0m  [1m[35mALTER TABLE "identities" ADD CONSTRAINT "fk_rails_5373344100"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (3.9ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_41670766b9"
FOREIGN KEY ("resource_id")
  REFERENCES "resources" ("id")
[0m
  [1m[35m (2.1ms)[0m  [1m[35mALTER TABLE "issues" ADD CONSTRAINT "fk_rails_0da50c43eb"
FOREIGN KEY ("result_id")
  REFERENCES "results" ("id")
[0m
  [1m[35m (16.3ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_efb2ffdf17"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (3.2ms)[0m  [1m[35mALTER TABLE "results" ADD CONSTRAINT "fk_rails_66a308b2c3"
FOREIGN KEY ("job_id")
  REFERENCES "jobs" ("id")
[0m
  [1m[35m (3.9ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_b9f82f696d"
FOREIGN KEY ("control_id")
  REFERENCES "controls" ("id")
[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "taggings" ADD CONSTRAINT "fk_rails_9fcd2e236b"
FOREIGN KEY ("tag_id")
  REFERENCES "tags" ("id")
[0m
  [1m[35m (1.1ms)[0m  [1m[35mALTER TABLE "users" ADD CONSTRAINT "fk_rails_d7b9ff90af"
FOREIGN KEY ("organization_id")
  REFERENCES "organizations" ("id")
[0m
  [1m[35m (0.5ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mActiveRecord::InternalMetadata Update (6.0ms)[0m  [1m[33mUPDATE "ar_internal_metadata" SET "value" = $1, "updated_at" = $2 WHERE "ar_internal_metadata"."key" = $3[0m  [["value", "development"], ["updated_at", "2020-10-07 21:58:35.402209"], ["key", "environment"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mActiveRecord::InternalMetadata Update (4.5ms)[0m  [1m[33mUPDATE "ar_internal_metadata" SET "value" = $1, "updated_at" = $2 WHERE "ar_internal_metadata"."key" = $3[0m  [["value", "test"], ["updated_at", "2020-10-07 21:58:35.420588"], ["key", "environment"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.4ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "schema_sha1"], ["LIMIT", 1]]
  [1m[35m (4.1ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mOrganization Load (0.3ms)[0m  [1m[34mSELECT "organizations".* FROM "organizations" WHERE "organizations"."name" = $1 LIMIT $2[0m  [["name", "Demo Organization"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mOrganization Create (1.8ms)[0m  [1m[32mINSERT INTO "organizations" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Demo Organization"], ["created_at", "2020-10-07 21:58:35.537608"], ["updated_at", "2020-10-07 21:58:35.537608"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mUser Load (0.5ms)[0m  [1m[34mSELECT "users".* FROM "users" WHERE "users"."username" = $1 LIMIT $2[0m  [["username", "demo"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mUser Create (0.9ms)[0m  [1m[32mINSERT INTO "users" ("name", "organization_id", "username", "password_digest", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["name", "Demo"], ["organization_id", 1], ["username", "demo"], ["password_digest", "$2a$12$5q5me2qelQ2/RvMPQMJk8eu4.l0ScEDjmdCLMcucOGQMCPo0Q8xWW"], ["created_at", "2020-10-07 21:58:35.790354"], ["updated_at", "2020-10-07 21:58:35.790354"]]
  [1m[36mRole Load (1.0ms)[0m  [1m[34mSELECT "roles".* FROM "roles" INNER JOIN "users_roles" ON "roles"."id" = "users_roles"."role_id" WHERE "users_roles"."user_id" = $1[0m  [["user_id", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mRole Load (0.4ms)[0m  [1m[34mSELECT "roles".* FROM "roles" WHERE "roles"."name" = $1 AND "roles"."resource_type" IS NULL AND "roles"."resource_id" IS NULL ORDER BY "roles"."id" ASC LIMIT $2[0m  [["name", "user"], ["LIMIT", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mRole Create (1.4ms)[0m  [1m[32mINSERT INTO "roles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "user"], ["created_at", "2020-10-07 21:58:35.820352"], ["updated_at", "2020-10-07 21:58:35.820352"]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mRole Exists? (0.7ms)[0m  [1m[34mSELECT 1 AS one FROM "roles" WHERE "roles"."name" = $1 LIMIT $2[0m  [["name", "user"], ["LIMIT", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[36mUser::HABTM_Roles Create (0.8ms)[0m  [1m[32mINSERT INTO "users_roles" ("user_id", "role_id") VALUES ($1, $2)[0m  [["user_id", 1], ["role_id", 1]]
  ↳ app/models/user.rb:122:in `assign_default_role'
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mSource Load (0.4ms)[0m  [1m[34mSELECT "sources".* FROM "sources" WHERE "sources"."name" = $1 LIMIT $2[0m  [["name", "Cloud Asset Inventory"], ["LIMIT", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Create (0.6ms)[0m  [1m[32mINSERT INTO "sources" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Cloud Asset Inventory"], ["created_at", "2020-10-07 21:58:35.851979"], ["updated_at", "2020-10-07 21:58:35.851979"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Update (0.5ms)[0m  [1m[33mUPDATE "sources" SET "location" = $1, "status" = $2, "updated_at" = $3 WHERE "sources"."id" = $4[0m  [["location", "gcs://bucket-acme-8765/cai"], ["status", 1], ["updated_at", "2020-10-07 21:58:35.859735"], ["id", 1]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mSource Load (0.5ms)[0m  [1m[34mSELECT "sources".* FROM "sources" WHERE "sources"."name" = $1 LIMIT $2[0m  [["name", "Kubernetes Sync Inventory"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Create (0.4ms)[0m  [1m[32mINSERT INTO "sources" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Kubernetes Sync Inventory"], ["created_at", "2020-10-07 21:58:35.868843"], ["updated_at", "2020-10-07 21:58:35.868843"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Update (0.3ms)[0m  [1m[33mUPDATE "sources" SET "location" = $1, "status" = $2, "updated_at" = $3 WHERE "sources"."id" = $4[0m  [["location", "gcs://bucket-acme-8765/k8s"], ["status", 0], ["updated_at", "2020-10-07 21:58:35.875840"], ["id", 2]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mSource Load (0.5ms)[0m  [1m[34mSELECT "sources".* FROM "sources" WHERE "sources"."name" = $1 LIMIT $2[0m  [["name", "Demo Kubernetes Inventory"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Create (0.5ms)[0m  [1m[32mINSERT INTO "sources" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Demo Kubernetes Inventory"], ["created_at", "2020-10-07 21:58:35.886011"], ["updated_at", "2020-10-07 21:58:35.886011"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mSource Update (0.6ms)[0m  [1m[33mUPDATE "sources" SET "location" = $1, "status" = $2, "updated_at" = $3 WHERE "sources"."id" = $4[0m  [["location", "file://200924_cai.json"], ["status", 0], ["updated_at", "2020-10-07 21:58:35.892393"], ["id", 3]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Darkbit Best Practices"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.6ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Darkbit Best Practices"], ["created_at", "2020-10-07 21:58:35.915398"], ["updated_at", "2020-10-07 21:58:35.915398"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.5ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"db-bp-1\",\"gcp\"]"], ["updated_at", "2020-10-07 21:58:35.922900"], ["id", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Google Cloud CIS 1.1"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.9ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Google Cloud CIS 1.1"], ["created_at", "2020-10-07 21:58:35.950439"], ["updated_at", "2020-10-07 21:58:35.950439"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.5ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"cis-1.1\",\"pci-3.4\",\"k8s-critical\"]"], ["updated_at", "2020-10-07 21:58:35.961869"], ["id", 2]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.5ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "GKE CIS 1.1"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.5ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "GKE CIS 1.1"], ["created_at", "2020-10-07 21:58:35.971629"], ["updated_at", "2020-10-07 21:58:35.971629"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.9ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Kubernetes"], ["tags", "[\"cis-1.1\",\"gke\",\"hipaa-6.2\",\"hipaa-7.5\"]"], ["updated_at", "2020-10-07 21:58:35.978635"], ["id", 3]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "PCI DSS"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.4ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "PCI DSS"], ["created_at", "2020-10-07 21:58:35.989786"], ["updated_at", "2020-10-07 21:58:35.989786"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.4ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"pci\",\"gcp\",\"gke\"]"], ["updated_at", "2020-10-07 21:58:35.995649"], ["id", 4]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.3ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "AWS Well Architected"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.4ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "AWS Well Architected"], ["created_at", "2020-10-07 21:58:36.003294"], ["updated_at", "2020-10-07 21:58:36.003294"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.5ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "AWS"], ["tags", "[\"well-architected\",\"aws-bp\"]"], ["updated_at", "2020-10-07 21:58:36.009517"], ["id", 5]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.6ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Public Resources - AWS"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.4ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Public Resources - AWS"], ["created_at", "2020-10-07 21:58:36.019891"], ["updated_at", "2020-10-07 21:58:36.019891"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.6ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "AWS"], ["tags", "[\"public-resources\",\"db-bp-2\"]"], ["updated_at", "2020-10-07 21:58:36.026771"], ["id", 6]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "Public Resources - GCP"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.6ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "Public Resources - GCP"], ["created_at", "2020-10-07 21:58:36.036295"], ["updated_at", "2020-10-07 21:58:36.036295"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (2.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.5ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"public-resources\",\"db-bg-3\",\"k8s-service-mesh\"]"], ["updated_at", "2020-10-07 21:58:36.049554"], ["id", 7]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.4ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "GKE Critical"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.4ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "GKE Critical"], ["created_at", "2020-10-07 21:58:36.069266"], ["updated_at", "2020-10-07 21:58:36.069266"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.7ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Google Cloud"], ["tags", "[\"gke-critical\"]"], ["updated_at", "2020-10-07 21:58:36.075658"], ["id", 8]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mProfile Load (0.5ms)[0m  [1m[34mSELECT "profiles".* FROM "profiles" WHERE "profiles"."name" = $1 LIMIT $2[0m  [["name", "K8s Visibility"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Create (0.4ms)[0m  [1m[32mINSERT INTO "profiles" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "K8s Visibility"], ["created_at", "2020-10-07 21:58:36.086310"], ["updated_at", "2020-10-07 21:58:36.086310"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mProfile Update (0.7ms)[0m  [1m[33mUPDATE "profiles" SET "author" = $1, "platform" = $2, "tags" = $3, "updated_at" = $4 WHERE "profiles"."id" = $5[0m  [["author", "Darkbit"], ["platform", "Kubernetes"], ["tags", "[\"k8s-logging\"]"], ["updated_at", "2020-10-07 21:58:36.096648"], ["id", 9]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "77fe366c-b65a-5051-b211-a4ca2ec23662"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "77fe366c-b65a-5051-b211-a4ca2ec23662"], ["created_at", "2020-10-07 21:58:36.151801"], ["updated_at", "2020-10-07 21:58:36.151801"]]
  [1m[35m (1.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 1]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTag Create (0.6ms)[0m  [1m[32mINSERT INTO "tags" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "dbc"], ["created_at", "2020-10-07 21:58:36.181324"], ["updated_at", "2020-10-07 21:58:36.181324"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 1], ["created_at", "2020-10-07 21:58:36.195497"], ["updated_at", "2020-10-07 21:58:36.195497"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-2"], ["title", "Centralized Secrets Management not in use"], ["description", "As infrastructure-as-code automation becomes widely used in an environment, it becomes possible to consistently separate out secret material from applications and code in a standard way. Once this happens, patterns in the code will emerge where the same secrets are stored and used in multiple places in the infrastructure.  Using a centralized, secure system for storing and accessing them that is able to operate in a cloud-native environment provides a means for centralized provisioning, auditing, rotation, and revocation of all secrets in the organization.  The damage due to credential theft and time available to an attacker with automatically rotated credentials is significantly decreased, and the likelihood for sensitive secret material to be exposed to additional persons or systems than are required is also diminished."], ["platform", "global"], ["impact", 5], ["validation", "\nReview all source control repositories, artifact creation processes, and deployment pipelines for the presence of static secrets in configuration files and ensure those values are not \"hardcoded\".  Ensure all new developers are trained on secure handling of secrets, and add secrets handling checks to all pull request/code reviews."], ["remediation", "\nConsider deploying a centralized system such as Hashicorp Vault or GCP Secrets Manager and working through all aspects of the infrastructure to remove statically defined secrets in favor of fetching them dynamically from a centrals secret store."], ["refs", "[{\"text\":\"Hashicorp Vault\",\"url\":\"https://www.hashicorp.com/products/vault/\",\"ref\":\"link\"},{\"text\":\"GCP Secrets Manager\",\"url\":\"https://cloud.google.com/secret-manager/docs\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.200556"], ["id", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f0258634-29df-5872-9cec-4a329d66f4ca"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f0258634-29df-5872-9cec-4a329d66f4ca"], ["created_at", "2020-10-07 21:58:36.207867"], ["updated_at", "2020-10-07 21:58:36.207867"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.1ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 2]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 2], ["created_at", "2020-10-07 21:58:36.219181"], ["updated_at", "2020-10-07 21:58:36.219181"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-3"], ["title", "Centralized Logging and Monitoring should be off-node and off-cluster"], ["description", "Without all systems, OS applications, Kubernetes components, and container applications logging and sending metrics to a centralized point outside of the primary cluster, the operations team will not be in a position to observe, triage, and accurately troubleshoot issues as they occur.  As a Security Analysis SaaS offering, system availability and reliable ingestion pipelines are vital to the value of the service.  Without a deep understanding of all critical aspects and logging tendencies of all applications and system components, a strong understanding of what falls inside the \"norm\" versus what is broken is difficult to diagnose when one component is not operating correctly."], ["platform", "global"], ["impact", 9], ["validation", "\nEnsure that all virtual machine instances and Kubernetes clusters are configured to ship logs and metrics to an appropriate, separate destination.  When new resources are being created, validate their logs and metrics are being correctly received."], ["remediation", "\nAll platform logs should be centrally collected, analyzed, and leveraged to understand system errors when they occur and how they affect operations.  All metrics should be centrally collected, charted, and leveraged to understand load, usage, and resource consumption as it relates to ingestion rates.  For example, all CPU/RAM/Network/Disk metrics should be collected for VMs and containers in addition to application-specific metrics such as logs per second, average log size, log processing time per \"hop\", etc.  Both performance metrics and log event metrics should be gathered outside the cluster they are originating from into a central point to be able to understand what \"healthy\" means for each and every system, Kubernetes component, and containerized deployment.  In GCP, the main point of log and metrics aggregation for all GKE clusters, GKE pods, GKE nodes, GCE instances, Firewall logs, VPC flow logs, and more is Stackdriver.  However, the log filtering and metrics visualization capabilities may not be as full-featured as commercial offerings, and this is a common point of third-party integration for GCP organizations."], ["refs", "[{\"text\":\"GCP Stackdriver\",\"url\":\"https://cloud.google.com/stackdriver#documentation\",\"ref\":\"link\"},{\"text\":\"Grafana Stackdriver Integration\",\"url\":\"https://grafana.com/docs/grafana/latest/features/datasources/stackdriver/\",\"ref\":\"link\"},{\"text\":\"Datadog\",\"url\":\"https://www.datadoghq.com/\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-2\",\"DE.AE-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.225371"], ["id", 2]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "a8e1c332-1fa8-5ea4-92df-56622a3b973c"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "a8e1c332-1fa8-5ea4-92df-56622a3b973c"], ["created_at", "2020-10-07 21:58:36.233601"], ["updated_at", "2020-10-07 21:58:36.233601"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 3]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 3], ["created_at", "2020-10-07 21:58:36.244075"], ["updated_at", "2020-10-07 21:58:36.244075"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-9"], ["title", "Project Lifecycle should be automated"], ["description", "When creating GCP projects, there are several steps that should be followed to ensure consistency and standardization of the base configuration of all projects.  Using automation with infrastructure-as-code tools like Terraform to manage the creation and management of all GCP projects greatly improves the ease of administration and enforces security best practices."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud projects list` and review projects for consistent application of initial project settings and following of conventions using `gcloud compute networks list`, `gcloud compute firewall-rules list`, and `gcloud iam service-accounts list/get-iam-policy`."], ["remediation", "\nUsing Terraform code stored in source control repositories, define and create all GCP projects using code.  Ensure that projects do not include the default networks and firewall rules, the default compute service account is not bound to \"Project Editor\", and incorporate any other standard settings for all projects to have.  The Cloud Foundation Toolkit from Google offers a pre-made Terraform module to make this easier."], ["refs", "[{\"text\":\"Terraform\",\"url\":\"https://www.terraform.io/\",\"ref\":\"link\"},{\"text\":\"Google Project Factory\",\"url\":\"https://github.com/terraform-google-modules/terraform-google-project-factory\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-2\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.252676"], ["id", 3]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2607af8b-07eb-5f45-8105-c8f0a68247c8"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2607af8b-07eb-5f45-8105-c8f0a68247c8"], ["created_at", "2020-10-07 21:58:36.261297"], ["updated_at", "2020-10-07 21:58:36.261297"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 4]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 4], ["created_at", "2020-10-07 21:58:36.288859"], ["updated_at", "2020-10-07 21:58:36.288859"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-10"], ["title", "Security Policies should be enforced using Organization Policies"], ["description", "GCP IAM grants users the ability to create or modify resources, but GCP Organization Policies help control how those resources are defined.  For example, a user might be able to create a GCE instance, but a \"constraint\" has been placed by an Organization Policy that prevents the instance from having an external IP address attached.  Organization Policies can be applied at the Org node, a GCP Folder, or at a GCP Project level, and they offer a way for GCP Administrators to delegate control over resources so long as they follow the desired constraints."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud beta resource-manager org-policies list --organization=ORGID` or `--folder=FOLDERID` or `--project=PROJECTID` to validate the organization policies are in the correct place in the hierarchy."], ["remediation", "\nThe following policies are recommended:\n\n* Prevent Instances from having external IPs\n* Skip Default Network creation during project creation\n* Trusted GCE Images enforcement\n* Serial Port Access\n* Service Account Key creation of user-managed keys\n\nUsing GCP Folders directly under the Organization node, apply the above constraints to a Folder.  For approved exemptions, places those resources inside Projects under a sibling Folder under the Organization node and apply the modified Organization Policy to that Folder.  It's recommended that proper testing be performed in a dedicated folder containing only test projects and resources to understand the behavior."], ["refs", "[{\"text\":\"GCP Organization Policies\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/overview\",\"ref\":\"link\"},{\"text\":\"Understanding Organization Policies\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/understanding-constraints\",\"ref\":\"link\"},{\"ids\":[\"ID.GV-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.297070"], ["id", 4]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f4a5c64d-5db9-57e3-aa23-569e995cdb54"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f4a5c64d-5db9-57e3-aa23-569e995cdb54"], ["created_at", "2020-10-07 21:58:36.306118"], ["updated_at", "2020-10-07 21:58:36.306118"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 5]]
  [1m[36mTag Load (1.1ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 5], ["created_at", "2020-10-07 21:58:36.318512"], ["updated_at", "2020-10-07 21:58:36.318512"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-11"], ["title", "Project names should follow a consistent naming convention"], ["description", "GCP Project names are visible in many places in the UI, the CLI, and in logs.  Consistently naming projects can help ease administration as the purpose of the project can be encoded in the name with some upfront planning."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud projects list` and look for projects that do not follow the defined naming convention as potential points of project creation that do not follow automated processes."], ["remediation", "\nCreate all GCP project IDs using a scheme such as: <org abbrev>-<environment>-<application or stack name> and also use the same string for the project name.  e.g. acme-dev-frontend or acme-prod-backendcluster.  Do not include sensitive information in project IDs.  Project IDs can have 4-30 lowercase letters, digits, or hyphens, must start with a lowercase letter, and must end with a letter or number."], ["refs", "[{\"text\":\"GCP Projects\",\"url\":\"https://cloud.google.com/resource-manager/docs/creating-managing-projects\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.324921"], ["id", 5]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5be7cee6-ee00-56ec-b271-4b2b6a6a3b34"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5be7cee6-ee00-56ec-b271-4b2b6a6a3b34"], ["created_at", "2020-10-07 21:58:36.333941"], ["updated_at", "2020-10-07 21:58:36.333941"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 6]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 6], ["created_at", "2020-10-07 21:58:36.342655"], ["updated_at", "2020-10-07 21:58:36.342655"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-12"], ["title", "Resource Structure does not follow the proper hierarchy aligned with environment separation goals"], ["description", "Folders and Projects should be implemented in a hierarchical pattern aligned with the ownership of teams and applications.  Projects should contain a single set of directly related resources and separated into different projects for each environment type (dev/stage/prod).\n\nAny change to the network, virtual machines, operating system, Kubernetes components, and applications running inside Kubernetes requires proper testing to ensure that change operates as desired.  Managing the risk of each change is best handled by creating dedicated environments using identical infrastructure-as-code techniques.  Without a \"dev\" or \"test\" environment, every change in the sole production cluster is inherently untested and a potential point for causing an outage."], ["platform", "gcp"], ["impact", 9], ["validation", "\nUse the GCP UI to view the folder and project structure.  Ensure the hierarchy and naming align with environment types and resources inside each project correspond to that environment only."], ["remediation", "\nUsing infrastructure-as-code tools such as Terraform, create identical environments for development, test/staging to complement the production environment.  Test all changes, upgrades, and fixes in the development environment, and perform those changes cleanly on the test/staging environment.  With a solid understanding of the changes and effects, planning and deploying to production becomes much less risky.  As a side effect of building environments with code, it provides confidence of full-environment reproducibility.\n\nUnder the organization node, create one or more folders that represents each service offering or \"stack\". e.g. \"SaaS\".  Under the \"SaaS\" folder, create folders for \"Dev\", \"Stage\", and \"Prod\".  Under each of those folders, create one or more projects to hold those resources that align with the environment.  By using folders, IAM permissions can be granted on the parent folder and they are inherited by the projects under them.  In addition, Stackdriver audit log sinks (exports) can be configured on a folder and apply to all logs from all projects underneath.\n\nMoving from one environment to 3 requires some changes to the centralized administrative access and monitoring/logging systems, so consider the Shared VPC approach VPC peering to help isolate identical copies of environments yet still manage and monitor them consistently."], ["refs", "[{\"text\":\"GCP Shared VPCs\",\"url\":\"https://cloud.google.com/vpc/docs/shared-vpc\",\"ref\":\"link\"},{\"text\":\"Terraform\",\"url\":\"https://www.terraform.io/\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.AM-3\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.349638"], ["id", 6]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e895db93-5bf2-55a0-9adc-17731c080bd8"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e895db93-5bf2-55a0-9adc-17731c080bd8"], ["created_at", "2020-10-07 21:58:36.358333"], ["updated_at", "2020-10-07 21:58:36.358333"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 7]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 7], ["created_at", "2020-10-07 21:58:36.368102"], ["updated_at", "2020-10-07 21:58:36.368102"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-14"], ["title", "IAM ServiceAccountUser granted at the project level"], ["description", "When creating a GCP resources that attaches a GCP service account, the calling user or service account must have the permission to \"use\" that service account. Otherwise, the ability to create a GCE instance with any service account attached would be a direct path to privilege escalation if at least one other service account in the project had higher permissions. This permission can be granted on a specific service account or at the project level.  Granting the permission directly on the service account resource permits \"use\" of just that service account.  Granting the permission at the project level permits the \"use\" of any service account in the project.  Even if the project does not currently have a highly privileged service account today, it might in the future, and that would inadvertently increase the power of this binding."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud beta projects get-iam-policy PROJECTID --flatten='bindings[]' --filter=bindings.role:iam.serviceAccountUser --format=\"csv[no-heading](bindings.members[])\"` for each project and ensure no results are displayed."], ["remediation", "\nRemove the permission at the project level and instead assign \"iam.serviceAccountUser\" on the small number of service accounts in the project that are necessary."], ["refs", "[{\"text\":\"Granting IAM Roles to Service Accounts\",\"url\":\"https://cloud.google.com/iam/docs/granting-roles-to-service-accounts\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\",\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.374816"], ["id", 7]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5a21d6de-3854-514c-a2ec-23f35fcd161f"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5a21d6de-3854-514c-a2ec-23f35fcd161f"], ["created_at", "2020-10-07 21:58:36.384426"], ["updated_at", "2020-10-07 21:58:36.384426"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 8]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 8], ["created_at", "2020-10-07 21:58:36.394023"], ["updated_at", "2020-10-07 21:58:36.394023"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTag Create (0.3ms)[0m  [1m[32mINSERT INTO "tags" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["name", "k8s-logging"], ["created_at", "2020-10-07 21:58:36.401803"], ["updated_at", "2020-10-07 21:58:36.401803"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 8], ["created_at", "2020-10-07 21:58:36.407509"], ["updated_at", "2020-10-07 21:58:36.407509"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-15"], ["title", "Overuse of Primitive IAM Roles"], ["description", "GCP \"Primitive\" Roles of \"Project Owner\", \"Project Editor\", and \"Project Viewer\" are broad groupings of permissions that cross nearly every API in a project.  Assigning \"Project Owner\" is granting full control over that project.  Assigning \"Project Editor\" is granting read/write to nearly every resource in a project with exceptions for IAM management.  Assigning \"Project Viewer\" allows for reading nearly every resource in the project.  By their nature, they do not conform to the principle of least privilege.  Instead, binding predefined IAM Roles or creating custom IAM Roles is preferred."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud organizations get-iam-policy ORGIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/owner\" or .role==\"roles/editor\" or .role==\"roles/viewer\") | \"($role): (.members[])\"'` for the organization level.  For each folder, run `gcloud resource-manager folders get-iam-policy FOLDERIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/owner\" or .role==\"roles/editor\" or .role==\"roles/viewer\") | \"($role): (.members[])\"'`.  For each project, run `gcloud projects get-iam-policy PROJECTID --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/owner\" or .role==\"roles/editor\" or .role==\"roles/viewer\") | \"($role): (.members[])\"'` and validate that the minimum assignments necessary are present."], ["remediation", "\nUse the IAM Role recommendation information to gauge how many permissions are granted versus how many are in actual use over the past 90 days.  Consider implementing the predefined roles or custom roles it suggests and revoking the primitive role.  Considerations: At least one member of the project must have the Owner role (roles/owner). If the Owner role is revoked from all members, it might remove the ability to manage the project.  When using access controls that are separate from Cloud IAM, such as Cloud Storage access control lists (ACLs) or Kubernetes role-based access control (RBAC), make sure those access controls will work correctly after the primitive role is revoked."], ["refs", "[{\"text\":\"IAM Recommender Overview\",\"url\":\"https://cloud.google.com/iam/docs/recommender-overview\",\"ref\":\"link\"},{\"text\":\"Managing IAM Recommender\",\"url\":\"https://cloud.google.com/iam/docs/recommender-managing\",\"ref\":\"link\"},{\"text\":\"Using IAM Securely\",\"url\":\"https://cloud.google.com/iam/docs/using-iam-securely\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.412874"], ["id", 8]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7d7ec1dc-fdfb-5edd-91dd-cf09a6a8d987"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7d7ec1dc-fdfb-5edd-91dd-cf09a6a8d987"], ["created_at", "2020-10-07 21:58:36.422901"], ["updated_at", "2020-10-07 21:58:36.422901"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 9]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 9], ["created_at", "2020-10-07 21:58:36.431795"], ["updated_at", "2020-10-07 21:58:36.431795"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-18"], ["title", "Overlapping IAM Role Permissions"], ["description", "A project was found to have IAM Role assignments that fully overlap.  That is, one or more IAM Roles are assigned that have permissions fully covered by another IAM Role assigned.  This is a minor misconfiguration that should be resolved to clarify the explicit intent and aid in auditing permissions in the future."], ["platform", "gcp"], ["impact", 1], ["validation", "\nReview the permissions at the organization, folder, and project level, and look for combinations of primitive IAM Roles such as \"Project Owner\" or \"Project Editor\" assigned in combination with other custom or predefined IAM roles."], ["remediation", "\nReview the configuration of IAM permissions and consider consolidating the permissions down to the single IAM Role that encapsulates the permissions necessary to do the job role.  The most expeditious solution is to simply remove the smaller IAM Role.  A common example is a predefined role such as \"Compute Admin\" being fully encapsulated in a primitive role such as \"Project Owner\"."], ["refs", "[{\"text\":\"Using IAM Securely\",\"url\":\"https://cloud.google.com/iam/docs/using-iam-securely\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.437126"], ["id", 9]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e6504c23-cf7f-52aa-92a3-49e54ca7f332"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.0ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e6504c23-cf7f-52aa-92a3-49e54ca7f332"], ["created_at", "2020-10-07 21:58:36.444829"], ["updated_at", "2020-10-07 21:58:36.444829"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 10]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 10], ["created_at", "2020-10-07 21:58:36.459644"], ["updated_at", "2020-10-07 21:58:36.459644"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-19"], ["title", "Organization Admin assigned at the Folder or Project level"], ["description", "The predefined Organization Administrator IAM Role is meant to be assigned at the Organization level, not the Folder or Project level.  This is likely a misconfiguration.  However, it offers the `resourcemanager.projects.setIamPolicy` permission which allows modification of permissions on that Project including adding oneself or others as \"Project Owner\" and gaining full access to the Project and all resources contained inside it."], ["platform", "gcp"], ["impact", 3], ["validation", "\nFor each folder, run `gcloud resource-manager folders get-iam-policy FOLDERIDNUMBER --format=json `| jq -r 'select(.bindings) | .bindings[] | select(.role==\"roles/resourcemanager.organizationAdmin\") | .members[]'.  For each project, run `gcloud projects get-iam-policy PROJECTID --format=json | jq -r 'select(.bindings) | .bindings[] | select(.role==\"roles/resourcemanager.organizationAdmin\") | .members[]'` and validate that no entries are present."], ["remediation", "\nReview the need for Organization Administrator to be assigned at the Folder or Project level and instead grant the desired IAM Roles for those users."], ["refs", "[{\"text\":\"Organization Access Control\",\"url\":\"https://cloud.google.com/resource-manager/docs/access-control-org\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.466471"], ["id", 10]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "288c5376-739a-5da8-927d-b72a185f8439"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "288c5376-739a-5da8-927d-b72a185f8439"], ["created_at", "2020-10-07 21:58:36.475753"], ["updated_at", "2020-10-07 21:58:36.475753"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 11]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 11], ["created_at", "2020-10-07 21:58:36.499225"], ["updated_at", "2020-10-07 21:58:36.499225"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-20"], ["title", "Default Firewall Rules are present"], ["description", "The default firewalls in the default VPC permit inbound access to SSH, RDP, and ICMP from 0.0.0.0/0 and between all instances on the local subnet.  By default, GCE instances and GKE workers are created in the default subnet of the default VPC in a project and inherit this access for ease of use, but this means they are exposed via SSH or RDP to the entire Internet."], ["platform", "gcp"], ["impact", 8], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.name | test(\"^default-allow-\")) | .name' | grep -v 'default-allow-internal'` and ensure entries named `default-allow-icmp`, `default-allow-rdp`, and `default-allow-ssh` are not listed."], ["remediation", "\nDelete the default firewall rules in all projects and create new firewall rules explicitly with the principle of least privilege/access in mind."], ["refs", "[{\"text\":\"Default Firewall Rules\",\"url\":\"https://cloud.google.com/vpc/docs/firewalls#more_rules_default_vpc\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.509287"], ["id", 11]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3d56976e-3673-5c48-a501-33e0a2975038"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3d56976e-3673-5c48-a501-33e0a2975038"], ["created_at", "2020-10-07 21:58:36.528804"], ["updated_at", "2020-10-07 21:58:36.528804"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 12]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 12], ["created_at", "2020-10-07 21:58:36.540742"], ["updated_at", "2020-10-07 21:58:36.540742"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-21"], ["title", "Firewall logging should be enabled on all rules"], ["description", "Firewall rules do not enable logging of connections by default.  In regulated environments, firewall logging is a requirement in almost every situation to be able to understand when systems are accessed on certain ports or for evidence of which systems were accessed in the event of a security incident."], ["platform", "gcp"], ["impact", 9], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.logConfig.enable==false) | \"(.name)\"'` and ensure no entries are present."], ["remediation", "\nFor all TCP and UDP firewall rules, enable firewall logging on each rule.  Logs are sent automatically to Stackdriver for review for the default retention period of 30 days."], ["refs", "[{\"text\":\"Firewall Rules Logging\",\"url\":\"https://cloud.google.com/vpc/docs/firewall-rules-logging\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.CM-7\",\"DE.CM-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.559892"], ["id", 12]]
  [1m[35m (1.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8d492ba7-166e-5e64-8645-210040600af1"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8d492ba7-166e-5e64-8645-210040600af1"], ["created_at", "2020-10-07 21:58:36.577324"], ["updated_at", "2020-10-07 21:58:36.577324"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 13]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (3.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 13], ["created_at", "2020-10-07 21:58:36.600782"], ["updated_at", "2020-10-07 21:58:36.600782"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-22"], ["title", "VPC Flow logging should be enabled on all VPC Subnets"], ["description", "VPC flow logs record metadata about all traffic flowing in and out of a VPC. These logs are vital for auditing and review after security incidents to be able to create an accurate timeline of network events to go with application and Cloud API Audit logs."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute networks subnets list --format=json | jq -r '.[] | select(.logConfig.enable | not) | \"(.name) (.region)\"'` and ensure no entries are present."], ["remediation", "\nEnable VPC Flow logging on all VPCs with a 100% sample rate for production environments or those that hold sensitive data.  When directing to a GCS bucket, enable bucket versioning and optionally configure an object lifecycle policy to retain the data for the desired period only."], ["refs", "[{\"text\":\"Using VPC Flow Logs\",\"url\":\"https://cloud.google.com/vpc/docs/using-flow-logs\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.CM-7\",\"DE.CM-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.663126"], ["id", 13]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "09ca0a00-f921-54bf-ab6e-80690f9dd06d"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "09ca0a00-f921-54bf-ab6e-80690f9dd06d"], ["created_at", "2020-10-07 21:58:36.675508"], ["updated_at", "2020-10-07 21:58:36.675508"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 14]]
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 14], ["created_at", "2020-10-07 21:58:36.698665"], ["updated_at", "2020-10-07 21:58:36.698665"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-23"], ["title", "Firewall rules allows access to SSH TCP/22 from all hosts"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to administrative ports via SSH (TCP/22) should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 8], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"'` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `22`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires SSH access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets or to the bastion host(s) in the environment."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.709340"], ["id", 14]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39bd81b4-4925-5701-a5be-a2ee38b67166"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39bd81b4-4925-5701-a5be-a2ee38b67166"], ["created_at", "2020-10-07 21:58:36.720537"], ["updated_at", "2020-10-07 21:58:36.720537"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 15]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 15], ["created_at", "2020-10-07 21:58:36.733458"], ["updated_at", "2020-10-07 21:58:36.733458"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 15], ["created_at", "2020-10-07 21:58:36.743741"], ["updated_at", "2020-10-07 21:58:36.743741"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (7.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-24"], ["title", "Default deny egress rules should be configured"], ["description", "There are no egress firewall rules in place, so the implicit egress \"allow all\" firewall policy is in effect.  This allows any GCP resource to connect to any external destination on any port or protocol.  While this default configuration provides ease of use, it offers no protection for exfiltration of data, lateral movement, or network pivoting in the event of a compromise."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.destinationRanges) | select(.denied) | select(.direction==\"EGRESS\") | select(.destinationRanges[] | contains(\"0.0.0.0/0\")) | select(.denied[].IPProtocol==\"all\") | \"(.name)\"'` and ensure that an entry is present."], ["remediation", "\nConfigure an explicit deny egress firewall rule in each VPC of priority 65535, and configure explicit egress firewall rules that allow external access on the specific ports to specific destinations as needed.  When combined with firewall logging, this has the added benefit of detecting when applications are misconfigured or when potentially malicious activity is attempting to use non-approved ports."], ["refs", "[{\"text\":\"Default GCP Firewall Rules\",\"url\":\"https://cloud.google.com/vpc/docs/firewalls#default_firewall_rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.DS-5\",\"DE.AE-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.759203"], ["id", 15]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "27d34b2a-4b21-5a95-9707-30c32ade1045"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "27d34b2a-4b21-5a95-9707-30c32ade1045"], ["created_at", "2020-10-07 21:58:36.775723"], ["updated_at", "2020-10-07 21:58:36.775723"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 16]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 16], ["created_at", "2020-10-07 21:58:36.788765"], ["updated_at", "2020-10-07 21:58:36.788765"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-25"], ["title", "GCE Instances have public IPs"], ["description", "GCE Instances should not have public IP addresses assigned directly to them, and should be administered using their private IP and services running on them exposed only via load balancers.  This reduces the scope of attacks against vulnerable services and affords additional protection against denial-of-service."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud compute instances list --format=json | jq -r '.[] | . as $instance | .networkInterfaces[] | select(.accessConfigs) | .accessConfigs[] | select(.type==\"ONE_TO_ONE_NAT\") | \"($instance.name): (.natIP)\"'` and ensure that no entries with public IPs exist."], ["remediation", "\nConfigure all GCE Instances to not have public IP addresses assigned.  In GKE, enable private nodes.  For services running on these systems that should be exposed externally, configure a load balancer.  For remote administration, consider using the Identity-Aware Proxy service to create an SSH or RDP-over-TLS tunnel directly to the private IP of the instance."], ["refs", "[{\"text\":\"IAP Proxy for GCE\",\"url\":\"https://cloud.google.com/iap/docs/enabling-compute-howto\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.795916"], ["id", 16]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9352728c-93c6-55ee-a072-8c3132241cf9"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9352728c-93c6-55ee-a072-8c3132241cf9"], ["created_at", "2020-10-07 21:58:36.804844"], ["updated_at", "2020-10-07 21:58:36.804844"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 17]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 17], ["created_at", "2020-10-07 21:58:36.817816"], ["updated_at", "2020-10-07 21:58:36.817816"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-26"], ["title", "Default networks are present"], ["description", "Each project contains a default VPC/Network with default subnets in every region for ease of use, but the IP ranges used are likely not desired and may overlap between different projects.  This may cause issues in the future if VPC Peering is desired as the subnets will conflict and prevent routing."], ["platform", "gcp"], ["impact", 2], ["validation", "\nIn each project, run `gcloud compute networks list --format=json | jq -r 'select(.[]) | .[] | select(.name==\"default\") | .name'` and ensure no entries are listed."], ["remediation", "\nDelete the default VPC/Network and subnets in each project and instead create a new VPC and subnets according to the networking and IP address management needs of the organization to avoid overlap.  To ensure all projects created do not have the default VPC/Network and subnets created automatically, configure the constraints/compute.skipDefaultNetworkCreation organization policy at the organization node."], ["refs", "[{\"text\":\"Default VPC Network\",\"url\":\"https://cloud.google.com/vpc/docs/vpc#default-network\",\"ref\":\"link\"},{\"text\":\"Organization Policies\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/org-policy-constraints\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-3\",\"PR.AC-5\",\"PR.DS-7\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.825674"], ["id", 17]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1cc2e0e7-6dc9-5c4f-959e-3e60addad801"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1cc2e0e7-6dc9-5c4f-959e-3e60addad801"], ["created_at", "2020-10-07 21:58:36.834127"], ["updated_at", "2020-10-07 21:58:36.834127"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 18]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 18], ["created_at", "2020-10-07 21:58:36.848109"], ["updated_at", "2020-10-07 21:58:36.848109"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-27"], ["title", "User-managed GCP Service Account Keys older than 90 days"], ["description", "GCP Service Account Keys that are created by an administrator are known as \"user-managed\" keys.  Unless rotated by the user, they are static for their lifetime.  They should be rotated on a frequent basis to limit their active lifetime in the event the key material is compromised."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=ORGIDNUMBER --format=\"value(projectId)\"); do for sa in $(gcloud iam service-accounts list --format=\"value(email)\" --project=$project); do gcloud iam service-accounts keys list --iam-account $sa --project=$project --format=json | jq -r '.[] | select(.keyType==\"USER_MANAGED\") | \"(.name): (.validAfterTime) (.validBeforeTime)\"'; done; done` and review the validAfterTime and validBeforeTime values for each key to ensure they are not valid for longer than 90 days."], ["remediation", "\nGCP Service Accounts have native, dynamic key integrations to services like GCE, GKE, AppEngine, Cloud Functions, and more such that exporting a static key is only necessary for integrations from non-GCP services like Splunk, Sumologic, Datadog, etc that need access to GCP resources from outside the organization.  This removes the need for exporting keys for all but a small number of clearly defined use cases for those types of integrations.  Refactor GCP applications using static, exported service account keys to use the native integration.  For keys used by external services, rotate them every 90 days."], ["refs", "[{\"text\":\"Managing Service Account Keys\",\"url\":\"https://cloud.google.com/iam/docs/creating-managing-service-account-keys\",\"ref\":\"link\"},{\"text\":\"Security Health Analytics\",\"url\":\"https://cloud.google.com/security-command-center/docs/how-to-manage-security-health-analytics\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-3\",\"PR.AC-6\",\"PR.AC-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.858512"], ["id", 18]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f657ccb7-f778-5c52-9d83-a691e190e289"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f657ccb7-f778-5c52-9d83-a691e190e289"], ["created_at", "2020-10-07 21:58:36.868069"], ["updated_at", "2020-10-07 21:58:36.868069"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 19]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 19], ["created_at", "2020-10-07 21:58:36.878504"], ["updated_at", "2020-10-07 21:58:36.878504"]]
  [1m[35m (2.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 19], ["created_at", "2020-10-07 21:58:36.893280"], ["updated_at", "2020-10-07 21:58:36.893280"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-28"], ["title", "GCP Projects should enable data access logging"], ["description", "GCP Audit logs automatically capture administrative activity logs for any creation or modification of resources via the GCP API.  e.g. \"create GCE instance\" or \"delete GCS bucket\".  By default, read requests to get/list resources and read/write requests that access user-provided data are not logged.  e.g. \"get or delete an object in a GCS bucket\".  These logs can and should be enabled on non-development projects to enable full capture of API activity necessary to support incident analysis and for meeting certain regulatory compliance requirements."], ["platform", "gcp"], ["impact", 8], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=ORGIDNUMBER --format=\"value(projectId)\"); do gcloud projects get-iam-policy $project --format=json | jq -r 'select(.auditConfigs)'; done` and ensure that it returns the following: `[\n      {\n        \"service\": \"allServices\",\n        \"auditLogConfigs\": [\n          { \"logType\": \"ADMIN_READ\" },\n          { \"logType\": \"DATA_READ\"  },\n          { \"logType\": \"DATA_WRITE\" },\n        ]\n      },\n    ]`."], ["remediation", "\nEnable \"Admin READ\" and \"Data READ and WRITE\" access logging for \"allServices\" at the organization level so that it applies to all downstream folders and projects.  Configure Stackdriver to export audit logs to a storage medium such as a GCS bucket and configure a lifecycle and retention policy to automatically move data to cheaper storage and to prune old data.  Caveat: Audit logs are often verbose and generate large volumes of log entries, and storing these in GCS buckets incurs an additional cost.  Use the exemption configuration to remove GCP internal service audit logs if necessary."], ["refs", "[{\"text\":\"Project Audit Logs\",\"url\":\"https://cloud.google.com/logging/docs/audit/understanding-audit-logs\",\"ref\":\"link\"},{\"text\":\"Configuring Data Access Logs\",\"url\":\"https://cloud.google.com/logging/docs/audit/configure-data-access\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.899348"], ["id", 19]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d2a48599-29d1-5e8a-a9e4-fb1fb35cfa75"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d2a48599-29d1-5e8a-a9e4-fb1fb35cfa75"], ["created_at", "2020-10-07 21:58:36.908165"], ["updated_at", "2020-10-07 21:58:36.908165"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 20]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 20], ["created_at", "2020-10-07 21:58:36.921444"], ["updated_at", "2020-10-07 21:58:36.921444"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-29"], ["title", "Cloud Security Command Center should be enabled"], ["description", "Security Command Center helps security teams gather data, identify threats, and act on them before they result in business damage or loss. It offers deep insight into application and data risk so that organizations can quickly mitigate threats to your their resources across and evaluate overall health. Security Command Center provides a single, centralized dashboard to:  - View and monitor an inventory of your cloud assets. - Scan storage systems for sensitive data. - Detect common web vulnerabilities and anomalous behavior. - Review access rights to your critical resources in your organization. - Apply recommended remediations to resolve vulnerabilities."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=ORGIDNUMBER --format=\"value(projectId)\"); do gcloud services list --project=$project | grep securitycenter; done` and ensure at least one entry is returned."], ["remediation", "\nLogged into GCP with roles/resourcemanager.organizationAdmin and roles/securitycenter.admin permissions, navigate to Security > Security Command Center in the UI and follow the prompts for enabling the service for all current and future projects.  Also, click on \"Security Health Analytics\" in the Dashboard and enable it.  Finally, navigate to Security > Threat Detection and enable Event Threat Detection to be able to receive events in Cloud Security Command Center."], ["refs", "[{\"text\":\"Cloud Security Command Center Quickstart\",\"url\":\"https://cloud.google.com/security-command-center/docs/quickstart-scc-setup\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.AM-5\",\"ID.GV-1\",\"ID.RA-1\",\"ID.RA-2\",\"ID.RA-3\",\"ID.RA-4\",\"ID.RA-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.928197"], ["id", 20]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5344a9bb-7f90-5b64-a466-111c6c59f09d"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5344a9bb-7f90-5b64-a466-111c6c59f09d"], ["created_at", "2020-10-07 21:58:36.937232"], ["updated_at", "2020-10-07 21:58:36.937232"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 21]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 21], ["created_at", "2020-10-07 21:58:36.952416"], ["updated_at", "2020-10-07 21:58:36.952416"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.9ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-30"], ["title", "CloudSQL Instances should have a private IP address"], ["description", "By default, CloudSQL instances are assigned a public IPv4 address, and the access list allows any source IP address to attempt to connect and authenticate to the database.  This facilitates development and ease of connectivity for troubleshooting, but it means an attacker can access the potentially sensitive data in the database without restriction if they obtain valid credentials."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.ipConfiguration.ipv4Enabled==true) | \"(.name) Public IP: (.settings.ipConfiguration.ipv4Enabled)\"'` and ensure no entries are listed."], ["remediation", "\nTo reduce the likelihood of an attacker to access the database service directly or to use stolen credentials from any source IP, the instance should be configured with a private IP address only. This should be configured during creation of the instance and a VPC peering relationship should be configured between the CloudSQL VPC and the VPCs where applications accessing the database reside."], ["refs", "[{\"text\":\"CloudSQL MySQL Private IP\",\"url\":\"https://cloud.google.com/sql/docs/mysql/configure-private-services-access\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Private IP\",\"url\":\"https://cloud.google.com/sql/docs/postgres/configure-private-services-access\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Private IP\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/configure-private-services-access\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-3\",\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:36.960736"], ["id", 21]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f033a7cd-69ce-53d9-8ca7-74579eb07a70"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f033a7cd-69ce-53d9-8ca7-74579eb07a70"], ["created_at", "2020-10-07 21:58:36.972495"], ["updated_at", "2020-10-07 21:58:36.972495"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 22]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 22], ["created_at", "2020-10-07 21:58:36.984203"], ["updated_at", "2020-10-07 21:58:36.984203"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-31"], ["title", "CloudSQL Instances should require SSL/TLS"], ["description", "By default, CloudSQL instances will accept both SSL/TLS and plaintext database connections.  As CloudSQL instances are provisioned inside a separate VPC within GCP that the user does not control, this means that database traffic will traverse a VPC peering connection without in-transit encryption.  Requiring SSL/TLS connections ensures that all connections are encrypted over the wire."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.ipConfiguration.requireSsl==null) | \"(.name) SSL: (.settings.ipConfiguration.requireSsl)\"'` and ensure no entries are listed."], ["remediation", "\nConfigure the instance during creation or while running to `require-ssl`.  For example, `gcloud sql instances patch [INSTANCE_NAME] --require-ssl`.  To allow applications to connect securely without changing application code, the cloudsql-proxy can be used.  It can handle setting up a localhost SSL proxy/tunnel and applications can be configured to connect to the database via that tunnel."], ["refs", "[{\"text\":\"CloudSQL MySQL Require SSL/TLS\",\"url\":\"https://cloud.google.com/sql/docs/mysql/configure-ssl-instance\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Require SSL/TLS\",\"url\":\"https://cloud.google.com/sql/docs/postgres/configure-ssl-instance\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Require SSL/TLS\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/configure-ssl-instance\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-7\",\"PR.DS-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.005872"], ["id", 22]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "6581aa85-27d2-5f66-95f5-b4f1f6b8a68f"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "6581aa85-27d2-5f66-95f5-b4f1f6b8a68f"], ["created_at", "2020-10-07 21:58:37.015384"], ["updated_at", "2020-10-07 21:58:37.015384"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 23]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 23], ["created_at", "2020-10-07 21:58:37.028490"], ["updated_at", "2020-10-07 21:58:37.028490"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-32"], ["title", "Firewalls ingress to TCP/3306 from 0.0.0.0/0"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to database ports via TCP/3306 should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `3306`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires Database access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets where the applications and administrative systems reside."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.035176"], ["id", 23]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "647dfcff-8bf4-5215-94e1-765d9da48454"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "647dfcff-8bf4-5215-94e1-765d9da48454"], ["created_at", "2020-10-07 21:58:37.043495"], ["updated_at", "2020-10-07 21:58:37.043495"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 24]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 24], ["created_at", "2020-10-07 21:58:37.057156"], ["updated_at", "2020-10-07 21:58:37.057156"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-33"], ["title", "Firewalls ingress to TCP/5432 from 0.0.0.0/0"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to database ports via TCP/5432 should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `5432`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires Database access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets where the applications and administrative systems reside."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.063311"], ["id", 24]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1dd1167e-7787-53b9-b32b-aa3cbfc49a11"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1dd1167e-7787-53b9-b32b-aa3cbfc49a11"], ["created_at", "2020-10-07 21:58:37.071413"], ["updated_at", "2020-10-07 21:58:37.071413"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 25]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 25], ["created_at", "2020-10-07 21:58:37.082506"], ["updated_at", "2020-10-07 21:58:37.082506"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-34"], ["title", "Firewalls ingress to TCP/3389 from 0.0.0.0/0"], ["description", "Firewall rules that permit inbound/ingress access from any IP address (0.0.0.0/0) to database ports via RDP (TCP/3389) should be reviewed for necessity to prevent unintended exposure of services and systems protected by that security group.  The primary exclusion to this is a dedicated, hardened bastion host."], ["platform", "gcp"], ["impact", 7], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"` and ensure no entries that permit `IPProtocol` of `tcp` and `ports` of `3389`."], ["remediation", "\nFor each firewall rule, assess whether the attached systems requires Remote Desktop access from any IP address.  If it doesn't, consider reducing the source IP ranges to a specific set of subnets or to the bastion host(s) in the environment."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.090724"], ["id", 25]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e738902b-746f-579b-981c-d36a054bf19f"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e738902b-746f-579b-981c-d36a054bf19f"], ["created_at", "2020-10-07 21:58:37.100089"], ["updated_at", "2020-10-07 21:58:37.100089"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 26]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 26], ["created_at", "2020-10-07 21:58:37.110681"], ["updated_at", "2020-10-07 21:58:37.110681"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-36"], ["title", "GCP usage within 30% of project quota limit"], ["description", "The GCP service enforces several quotas on all GCP projects to protect both service availability and the customer.  Without quotas, a compromised account would offer \"unlimited\" resources to mine bitcoin, or a single customer could attempt to exhaust all available resources of a given service type.  Quotas on Instance counts, Virtual CPUs, and Persistent Disks are commonly known, but there are several quotas that can easily catch users by surprise when attempting even modest scale-up activities.  As the process for increasing quota limits can take 1-3 days, it's best to request these increases well ahead of the need to prevent self-inflicted capacity based outages."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `for project in $(gcloud projects list --filter=parent.id=1071234196403 --format=\"value(projectId)\"); do gcloud compute project-info describe --project $project --format=json | jq -r '.quotas[] | \"(.metric): (.usage) (.limit)\"'; done` and `gcloud compute regions list --format=json | jq -r '.[] | .name as $name | .quotas[] | \"($name) (.metric): (.usage) (.limit)\"'`.  Ensure that usage does not exceed 70% of the limit value for all quotas."], ["remediation", "\nReview the project-level and per-region quotas for all critical GCP projects on a routine basis.  For quotas that are within 30-50% of total capacity, evaluate the need for increasing those limits and use the GCP console to request them as needed."], ["refs", "[{\"text\":\"Managing GCP Quotas\",\"url\":\"https://cloud.google.com/compute/quotas\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"ID.AM-5\",\"ID.RA-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.118037"], ["id", 26]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7befc99c-0695-574a-b10a-af5c538a2171"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7befc99c-0695-574a-b10a-af5c538a2171"], ["created_at", "2020-10-07 21:58:37.126991"], ["updated_at", "2020-10-07 21:58:37.126991"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 27]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 27], ["created_at", "2020-10-07 21:58:37.136073"], ["updated_at", "2020-10-07 21:58:37.136073"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-39"], ["title", "Exported GCP Service Account Keys in use inside GCP/GKE resources"], ["description", "When application code needs to interact with the GCP APIs, it needs an identity and credentials.  The creation of a GCP Service Account represents the identity, and a GCP-managed keypair associated with that Service Account serves as the credentials used to generate session tokens needed during API interaction.  For applications that reside outside GCP, users can generate and export up to ten new Service Account Keys for a single Service Account.  These exported keys are then \"user-managed\" in that they don't expire or require any additional information to be used to authenticate as that Service Account using GCP APIs.  Until recently, it was common practice to manually export a Service Account Key in a JSON-file format and store that inside a GKE/Kubernetes Secret to support Pods having GCP API access.  However, these keys require manual rotation and replacement, and this makes automatic key rotation for compliance reasons or following a security incident extremely difficult."], ["platform", "gcp"], ["impact", 5], ["validation", "\nReview the presence of, age, and expiration of all user-managed/exported Service Account Keys in the account.  Ensure the description of the Service Account and/or Key provides an indication of where it is being used.  If GCP Organization Policies are enforcing, ensure the `iam.disableServiceAccountKeyCreation` control is applied to all but a small approved list of Folders and Projects."], ["remediation", "\nPeriodically review all Service Account Keys associated with Service Accounts, and ensure their usage is only in limited situations where there is no other option.  For GCE, attaching the Service Account to the instance is the preferred method as the credentials are short-lived and automatically rotated every hour.  For Pods in GKE, use the Workload Identity feature to map GKE/Kubernetes Service Accounts to GCP Service Accounts via IAM mapping and get similar behavior to the GCE instance metadata approach.  To prevent keys from being generated, consider enforcing the `iam.disableServiceAccountKeyCreation` GCP Organization Policy on all Folders/Projects that do not hold IAM responsibilities for external application authentication."], ["refs", "[{\"text\":\"GCP Service Accounts\",\"url\":\"https://cloud.google.com/iam/docs/understanding-service-accounts\",\"ref\":\"link\"},{\"text\":\"GCP Service Account Keys\",\"url\":\"https://cloud.google.com/iam/docs/creating-managing-service-account-keys\",\"ref\":\"link\"},{\"text\":\"GCP Organization Policy\",\"url\":\"https://cloud.google.com/resource-manager/docs/organization-policy/restricting-service-accounts#disable_service_account_key_creation\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.142126"], ["id", 27]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9a58ed98-e24a-5f2a-a420-0b445ddb376d"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9a58ed98-e24a-5f2a-a420-0b445ddb376d"], ["created_at", "2020-10-07 21:58:37.152896"], ["updated_at", "2020-10-07 21:58:37.152896"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 28]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 28], ["created_at", "2020-10-07 21:58:37.162967"], ["updated_at", "2020-10-07 21:58:37.162967"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-40"], ["title", "Shared VPC projects contain non VPC related resources"], ["description", "GCP Projects that contain VPCs to be \"shared\" with other GCP Projects are also known as \"Host\" Projects, and the GCP Projects that are associated with the Host Projects are known as \"Resource\" Projects.  This approach maintains the networking configuration centrally with dedicated IAM permissions, and the ability to \"use\" the network is granted to each Service Project which is typically owned by other teams in the organization who own the instances and clusters.  Where possible, the Shared VPC project should retain its single purpose configuration and not hold resources unrelated to the VPC networking, routing, and firewall settings.  Resources outside of those purposes should be held in one or more Service Projects instead to maintain cleaner ownership and permissions isolation."], ["platform", "gcp"], ["impact", 3], ["validation", "\nReview all Host Projects and validate that no GCE instances, GKE clusters, GCS buckets, etc exist and that IAM permissions for the Project are only network-focused."], ["remediation", "\nIf resources exist in the Shared VPC project that are not networking related, they should be migrated to a dedicated Service Project.  Permissions to manage the VPC resources in the Shared VPC Project should be carefully reviewed to ensure they only grant access to perform network configuration tasks."], ["refs", "[{\"text\":\"GCP Shared VPCs\",\"url\":\"https://cloud.google.com/vpc/docs/shared-vpc\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.PT-4\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.170745"], ["id", 28]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "cb1f71c5-e10d-5e0e-9057-4b794d1cd588"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.9ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "cb1f71c5-e10d-5e0e-9057-4b794d1cd588"], ["created_at", "2020-10-07 21:58:37.180043"], ["updated_at", "2020-10-07 21:58:37.180043"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 29]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 29], ["created_at", "2020-10-07 21:58:37.192824"], ["updated_at", "2020-10-07 21:58:37.192824"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-41"], ["title", "Load Balancers should use a MODERN or RESTRICTED SSL policy"], ["description", "By default, Load Balancers use an SSL/TLS policy equivalent to the COMPATIBLE profile which supports a wide range of ciphers and TLS versions of varying security.  In nearly all use cases, the more stringent profiles should be used to ensure client connections only negotiate with strong ciphers and recent TLS versions.  For compliance-focused environments, the RESTRICTED policy should be used."], ["platform", "gcp"], ["impact", 3], ["validation", "\nRun `gcloud compute target-https-proxies list --format=json | jq -r '.[] | select(.sslPolicy | not) | \"(.name) (.selfLink)\"'` and `gcloud compute target-ssl-proxies list --format=json | jq -r '.[] | select(.sslPolicy | not) | \"(.name) (.selfLink)\"'` and ensure they do not return any entries."], ["remediation", "\nConfigure all Load Balancers to leverage the MODERN or RESTRICTED SSL policy or a CUSTOM SSL policy with equivalent enforcement of secure ciphers and TLS versions."], ["refs", "[{\"text\":\"GCP SSL Policies\",\"url\":\"https://cloud.google.com/load-balancing/docs/ssl-policies-concepts\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-2\",\"PR.PT-4\",\"PR.AC-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.198327"], ["id", 29]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0089ced9-0d18-552a-88de-b5d77c179e2d"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0089ced9-0d18-552a-88de-b5d77c179e2d"], ["created_at", "2020-10-07 21:58:37.205731"], ["updated_at", "2020-10-07 21:58:37.205731"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 30]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 30], ["created_at", "2020-10-07 21:58:37.216038"], ["updated_at", "2020-10-07 21:58:37.216038"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-42"], ["title", "Firewall rules allows all ports from all hosts"], ["description", "Firewall rules that allow all ports from any CIDR range are effectively disabling firewall protection to the attached service or system."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud compute firewall-rules list --format=json | jq -r '.[] | select(.sourceRanges) | select(.allowed) | select(.sourceRanges[] | contains(\"0.0.0.0/0\")) | \"(.name) (.allowed[])\"'` and ensure no entries that permit `IPProtocol` of `all`."], ["remediation", "\nFor each firewall rule, review the application needs for protocols and ports, and reconfigure the firewall rule(s) to only grant access to those."], ["refs", "[{\"text\":\"Configuring Firewall Rules\",\"url\":\"https://cloud.google.com/vpn/docs/how-to/configuring-firewall-rules\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.222308"], ["id", 30]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2f3f76ca-7048-5b40-97a1-350869c51f0c"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2f3f76ca-7048-5b40-97a1-350869c51f0c"], ["created_at", "2020-10-07 21:58:37.229693"], ["updated_at", "2020-10-07 21:58:37.229693"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 31]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 31], ["created_at", "2020-10-07 21:58:37.240121"], ["updated_at", "2020-10-07 21:58:37.240121"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-43"], ["title", "GCS Bucket Logging should be enabled"], ["description", "GCS bucket logging helps maintain an audit trail of access that can be used in the event of a security incident.  Bucket logging is disabled by default, so any unauthorized access will go untraced unless this is explicitly enabled."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `for bucket in $(gsutil ls); do gsutil logging get $bucket; done | grep \"has no logging\"` and validate that no entries are present."], ["remediation", "\nEnable data access audit logs on all storage buckets that store data that requires auditable logging."], ["refs", "[{\"text\":\"GCS Audit Logs\",\"url\":\"https://cloud.google.com/storage/docs/audit-logs\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.245946"], ["id", 31]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9082de43-725d-5562-90a9-8204a5aba5c4"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9082de43-725d-5562-90a9-8204a5aba5c4"], ["created_at", "2020-10-07 21:58:37.257528"], ["updated_at", "2020-10-07 21:58:37.257528"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 32]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 32], ["created_at", "2020-10-07 21:58:37.283939"], ["updated_at", "2020-10-07 21:58:37.283939"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-44"], ["title", "GCS Buckets without object versioning enabled"], ["description", "GCS Buckets that store sensitive data should have object versioning enabled to help protect against the overwriting of objects or data loss in the event of a compromise.  A concrete example is a bucket that receives audit/access logs from other services.  Without object versioning, an attacker might be able to delete evidence of their activities.  With object versioning enabled, they won't be able to remove the original version of the log data."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `for bucket in $(gsutil ls); do gsutil versioning get $bucket; done | grep \"Suspended\"` and validate that no entries are present."], ["remediation", "\nEnable object versioning on all storage buckets that store data that requires integrity protection."], ["refs", "[{\"text\":\"GCS Object Versioning\",\"url\":\"https://cloud.google.com/storage/docs/object-versioning\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.291726"], ["id", 32]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8f62fb14-a782-5888-b0cb-3d5ee30b4bdd"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8f62fb14-a782-5888-b0cb-3d5ee30b4bdd"], ["created_at", "2020-10-07 21:58:37.300672"], ["updated_at", "2020-10-07 21:58:37.300672"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 33]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 33], ["created_at", "2020-10-07 21:58:37.311960"], ["updated_at", "2020-10-07 21:58:37.311960"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-45"], ["title", "Predefined GKE IAM Roles should be avoided"], ["description", "Access to the GKE Cluster API Server resources is controlled by a combination of IAM and in-cluster RBAC permissions.  If either grants access to the resource, access is allowed.  When using IAM permissions, access is granted to the permitted resources in all namespaces.  Using RBAC policies allows for granting more granular access to resources on a cluster-wide or per-namespace level and follows the principle of least privilege.  In this case, only IAM permissions are being used for allowing access via the \"Project Owner\" IAM Role, and this effectively grants full access to all resources in the cluster and \"root\" access to all GKE worker nodes."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud organizations get-iam-policy ORGIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/container.admin\" or .role==\"roles/container.developer\" or .role==\"roles/container.viewer\") | \"($role): (.members[])\"'` for the organization level.  For each folder, run `gcloud resource-manager folders get-iam-policy FOLDERIDNUMBER --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/container.admin\" or .role==\"roles/container.developer\" or .role==\"roles/container.viewer\") | \"($role): (.members[])\"'`.  For each project, run `gcloud projects get-iam-policy PROJECTID --format=json | jq -r 'select(.bindings) | .bindings[] | .role as $role | select(.role==\"roles/container.admin\" or .role==\"roles/container.developer\" or .role==\"roles/container.viewer\") | \"($role): (.members[])\"'` and validate that the minimum assignments necessary are present."], ["remediation", "\nThe recommended approach is to avoid using IAM permissions to grant access to GKE clusters with one exception: a custom IAM Role that only permits cluster users with the ability to download a kubeconfig file via the \"gcloud container clusters get-credentials\" API call.  All Kubernetes access should be granted inside the cluster using RBAC ClusterRoleBindings or per-namespace RoleBindings.  Create a custom IAM Role call \"Kubernetes API Access\" with the following permissions: - container.apiServices.get - container.apiServices.list - container.clusters.get - container.clusters.getCredentials  Create a security group with all members that need cluster access, and bind the \"Kubernetes API Access\" IAM Role to that group at the project where the cluster lives.  For each administrator, create a ClusterRoleBinding that grants that user the \"Cluster Admin\" ClusterRole.  For each developer/CI system, create a RoleBinding that grants that user the Role they need in the namespace(s) they need access to that are not kube-system.  This is commonly the \"admin\" ClusterRole bound to the namespace to delegate them full control over that namespace."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control\",\"ref\":\"Kubernetes RBAC\"},{\"text\":\"GKE Multi-tenancy\",\"url\":\"https://speakerdeck.com/alp/multi-tenancy-best-practices-for-google-kubernetes-engine?slide=3\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.319940"], ["id", 33]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "50399e71-32dc-569b-bcd1-d63fa0a39a85"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "50399e71-32dc-569b-bcd1-d63fa0a39a85"], ["created_at", "2020-10-07 21:58:37.328841"], ["updated_at", "2020-10-07 21:58:37.328841"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 34]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 34], ["created_at", "2020-10-07 21:58:37.339018"], ["updated_at", "2020-10-07 21:58:37.339018"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 34], ["created_at", "2020-10-07 21:58:37.346749"], ["updated_at", "2020-10-07 21:58:37.346749"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-46"], ["title", "GKE Network Policy support should be installed"], ["description", "By default in Kubernetes, all Pods can communicate with each other by IP and egress to any subnet (including the Internet) unless routing or firewalls are added to prevent that traffic.  This presents ample opportunity for lateral movement from the perspective of a compromised workload. One of the best ways to reduce the scope of that movement is to deploy NetworkPolicy resources that define firewall rules for pod-to-pod traffic.  In GKE, the Network Policy add-on must be enabled to allow for the cluster to enforce firewall policies on Pods."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.networkPolicy.enabled==true and .networkPolicy.provider==\"CALICO\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the cluster to enabled Network Policy support to allow for in-cluster support for NetworkPolicy (firewall rules) resources."], ["refs", "[{\"text\":\"Kubernetes Network Policy\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#restrict_with_network_policy\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.354961"], ["id", 34]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9eb1bf9e-1214-510e-9675-397a7ffd52fb"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9eb1bf9e-1214-510e-9675-397a7ffd52fb"], ["created_at", "2020-10-07 21:58:37.363178"], ["updated_at", "2020-10-07 21:58:37.363178"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 35]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 35], ["created_at", "2020-10-07 21:58:37.375394"], ["updated_at", "2020-10-07 21:58:37.375394"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-47"], ["title", "GKE Control Plane IPs should be restricted to a known set of IP ranges"], ["description", "The Kubernetes API Server systems (Control Plane) expose the Kubernetes API Server TLS port publicly without an IP restrictions or limitations.  This provides convenient remote administrative access, but it affords only a single layer of defense in front of the Kubernetes cluster and all applications and data inside.  A pre-authentication or denial-of-service vulnerability could compromise or disrupt the cluster completely.  Several pre-authentication denial-of-service vulnerabilities have been discovered and fixed in recent Kubernetes releases."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.masterAuthorizedNetworksConfig.enabled==true) | select(.masterAuthorizedNetworksConfig.cidrBlocks[].cidrBlock!=\"0.0.0.0/0\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the master authorized networks on the GKE cluster to be restricted to a known set of IP ranges for API Server access.  In environments with bastion hosts or VPNs, their internal subnet range or security groups are commonly used."], ["refs", "[{\"text\":\"Billion Laughs Attack\",\"url\":\"https://www.stackrox.com/post/2019/09/protecting-kubernetes-api-against-cve-2019-11253-billion-laughs-attack/\",\"ref\":\"link\"},{\"text\":\"Billion Laughs PoC\",\"url\":\"https://gist.github.com/bgeesaman/0e0349e94cd22c48bf14d8a9b7d6b8f2\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.PT-3\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.385439"], ["id", 35]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "6506294c-7084-5b9a-a0c5-a94b5fca6082"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "6506294c-7084-5b9a-a0c5-a94b5fca6082"], ["created_at", "2020-10-07 21:58:37.394857"], ["updated_at", "2020-10-07 21:58:37.394857"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 36]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 36], ["created_at", "2020-10-07 21:58:37.405306"], ["updated_at", "2020-10-07 21:58:37.405306"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-48"], ["title", "GKE Workload Identity should be enabled and enforcing metadata protection on all NodePools"], ["description", "Currently, all pods have the ability to reach the Instance Metadata API corresponding to the underlying node.  By extension, those pods can access the APIs and data used to bootstrap the Kubernetes worker node.  The credentials used to bootstrap a Kubernetes worker node are very commonly sufficient to be used to privilege escalate to \"cluster-admin\".  Also by extension, this means that every container image ever run in this cluster in the non-\"prod\" namespace has had the ability to reach and export these credentials.  Therefore, it's very important for a cluster's security posture to prevent pods from being able to reach the Instance Metadata API to fetch those bootstrapping credentials."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.workloadIdentityConfig.workloadPool | test(\"svc.id.goog\")) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure Workload Identity on the cluster and every node pool in the cluster with the GKE_METADATA setting enabled.  Alternatively, deploy an egress NetworkPolicy blocking egress to 169.254.169.254 for all non-kube-system namespaces."], ["refs", "[{\"text\":\"GKE Workload Identity\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity\",\"ref\":\"link\"},{\"text\":\"Hardening GKE\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#workload_identity\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\",\"PR.AC-5\",\"PR.AC-6\",\"PR.AC-7\",\"PR.DS-2\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.411065"], ["id", 36]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "896263b0-7ac0-54db-a3c3-620c97edfd50"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "896263b0-7ac0-54db-a3c3-620c97edfd50"], ["created_at", "2020-10-07 21:58:37.421020"], ["updated_at", "2020-10-07 21:58:37.421020"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 37]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 37], ["created_at", "2020-10-07 21:58:37.431161"], ["updated_at", "2020-10-07 21:58:37.431161"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 37], ["created_at", "2020-10-07 21:58:37.438924"], ["updated_at", "2020-10-07 21:58:37.438924"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-49"], ["title", "GKE Node pools should use dedicated GCP ServiceAccounts"], ["description", "By default, GKE associates the \"default\" compute service account to GKE worker nodes, and it is automatically granted the \"Project Editor\" IAM Role.  To avoid using an inherently shared service account with over-provisioned permissions, create a dedicated service account for each GKE cluster in each project and grant it only the minimal IAM permissions needed."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.serviceAccount | test(\"-compute@developer.gserviceaccount.com\") | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nCreate a dedicated GCP service account for each cluster in each project. Create a custom IAM Role with the \"monitoring.viewer\", \"monitoring.metricWriter\", and \"logging.logWriter\" permissions, and associate that with the dedicated GCP service account.  Ensure the OAuth Scopes attached to the nodes are:\n\n* https://www.googleapis.com/auth/devstorage.read_only\n* https://www.googleapis.com/auth/logging.write\n* https://www.googleapis.com/auth/monitoring\n* https://www.googleapis.com/auth/servicecontrol\n* https://www.googleapis.com/auth/service.management.readonly\n* https://www.googleapis.com/auth/trace.append\n\nConsideration: Changing the service account or the OAuth Scopes will result in a rolling redeployment of the Node Pool."], ["refs", "[{\"text\":\"GKE NodePool OAuth Scopes\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#use_least_privilege_sa\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-6\",\"PR.IP-1\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.444524"], ["id", 37]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c0247bd6-3f66-5a6a-b867-817bff7dc370"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c0247bd6-3f66-5a6a-b867-817bff7dc370"], ["created_at", "2020-10-07 21:58:37.455778"], ["updated_at", "2020-10-07 21:58:37.455778"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 38]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 38], ["created_at", "2020-10-07 21:58:37.467432"], ["updated_at", "2020-10-07 21:58:37.467432"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-50"], ["title", "GKE Node pools should use Shielded GKE Nodes"], ["description", "Starting in GKE 1.13.6 and later, GKE Worker nodes can be provisioned with a Virtual Trusted Platform Module (vTPM) that can be used to cryptographically verify the integrity of the boot process and to securely distribute the bootstrapping credentials used by the Kubelet to attach the node to the cluster on first boot.  Without this feature, the Kubelet's bootstrapping credentials are available via the GCE Metadata API, and that can be accessed by any Pod unless additional protections are put in place.  These credentials can be leveraged to escalate to cluster-admin in most situations."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.shieldedInstanceConfig.enableIntegrityMonitoring==true and .nodePools[].config.shieldedInstanceConfig.enableSecureBoot==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nModify the cluster node pool configuration to enable shielded nodes (--enable-shielded-nodes) and secure boot (--shielded-secure-boot).  This will remove the sensitive bootstrapping credentials from the GCE Metadata API and enable additional verification checks to ensure the worker nodes have not been compromised at a fundamental level.  Considerations: The nodes must be running the COS or COS_CONTAINERD operating system, and enabling this change will require a node pool rolling redeployment performed at the next maintenance window."], ["refs", "[{\"text\":\"GKE Hardening\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#shielded_nodes\",\"ref\":\"link\"},{\"text\":\"GKE Shielded Nodes\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/shielded-gke-node\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-6\",\"PR.DS-8\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.474134"], ["id", 38]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1b62d4fd-a5c1-5624-9067-e45c3261c24c"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1b62d4fd-a5c1-5624-9067-e45c3261c24c"], ["created_at", "2020-10-07 21:58:37.483767"], ["updated_at", "2020-10-07 21:58:37.483767"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 39]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 39], ["created_at", "2020-10-07 21:58:37.496005"], ["updated_at", "2020-10-07 21:58:37.496005"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 39], ["created_at", "2020-10-07 21:58:37.505389"], ["updated_at", "2020-10-07 21:58:37.505389"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-51"], ["title", "Production GKE Clusters should have a highly-available control plane"], ["description", "By default, GKE creates a \"zonal\" cluster.  That is, a cluster where the single control plane GCE instance is deployed in one GCP availability zone.  GKE clusters can also be configured as \"regional\" clusters in which three control plane GCE instances can be deployed evenly across three availability zones at no direct, additional cost.  Having three control plane instances insulates from a single control plane instance failure and allows for zero-downtime API server upgrades."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.location | test(\"^[a-z]+-[a-z0-9]+$\")) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nFor all production GKE clusters, configure the \"location\" as the region name instead of the zone name.  This requires rebuilding the cluster if it is already deployed as a zonal cluster."], ["refs", "[{\"text\":\"GKE Regional Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/regional-clusters\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.510873"], ["id", 39]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "03cf095b-e748-59e1-b596-777da1ba23c3"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "03cf095b-e748-59e1-b596-777da1ba23c3"], ["created_at", "2020-10-07 21:58:37.520636"], ["updated_at", "2020-10-07 21:58:37.520636"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 40]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 40], ["created_at", "2020-10-07 21:58:37.530080"], ["updated_at", "2020-10-07 21:58:37.530080"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.9ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-52"], ["title", "GKE Clusters should use a Private Cluster Endpoint/IP"], ["description", "By default, GKE creates clusters with a public IP address on the control plane without any network restriction on source IP ranges that can access it.  Even though the access controls protecting the API server require authentication and authorization, the API server is open to denial-of-service attacks, being probed by bots/scanners inflating Stackdriver logs, and direct exploitation should a Kubernetes API Server vulnerability be discovered."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.privateClusterConfig.enablePrivateEndpoint==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConsider rebuilding GKE clusters with the \"private master endpoint\" configuration to ensure the API server is not assigned a routable public IP address.  Additional considerations:\n\n* Converting a public to a private GKE cluster requires rebuilding it.\n* Use a dedicated /28 subnet for the control plane IP space that does not overlap anywhere and is not part of 172.17.0.0/16.\n* Private control planes leverage VPC peering and count toward VPC peering quota.\n* Modifications to the VPC peering or firewall rules from the control plane to the worker nodes can break the cluster."], ["refs", "[{\"text\":\"GKE Private Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.PT-3\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.535441"], ["id", 40]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0e680f8d-95d8-5fcb-937e-9891dd11fe2e"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0e680f8d-95d8-5fcb-937e-9891dd11fe2e"], ["created_at", "2020-10-07 21:58:37.563022"], ["updated_at", "2020-10-07 21:58:37.563022"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 41]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 41], ["created_at", "2020-10-07 21:58:37.576066"], ["updated_at", "2020-10-07 21:58:37.576066"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-53"], ["title", "Production GKE Cluster NodePools should be spread across multiple availability zones"], ["description", "By default, GKE creates a \"zonal\" cluster.  That is, a cluster where the single control plane GCE instance is deployed in one GCP availability zone and the worker GCE instances are deployed as a node pool in that same availability zone.  This optimizes for cost and simplicity at the expense of redundancy and protection against a zone outage.  If the control plane is set to \"regional\", then the worker GCE instances are deployed evenly across the three availability zones with instance groups per zone.  Setting the node pool instance count to \"1\" on a regional cluster will create one GCE instance in each of the three zones for a total of three worker nodes."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.locations | length >= 3) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nFor all production GKE clusters, configure the \"location\" as the region name instead of the zone name.  This requires rebuilding the cluster if it is already deployed as a zonal cluster.  The worker nodes will automatically be spread evenly across all three availability zones.\n\nConsideration: as traffic goes from node to node over zone boundaries, additional network costs will be incurred."], ["refs", "[{\"text\":\"GKE Regional Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/regional-clusters\",\"ref\":\"link\"},{\"text\":\"GKE Network Pricing\",\"url\":\"https://cloud.google.com/compute/network-pricing\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.586489"], ["id", 41]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "ed4eb845-f04a-5774-986b-112d4a468704"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "ed4eb845-f04a-5774-986b-112d4a468704"], ["created_at", "2020-10-07 21:58:37.595494"], ["updated_at", "2020-10-07 21:58:37.595494"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 42]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 42], ["created_at", "2020-10-07 21:58:37.608921"], ["updated_at", "2020-10-07 21:58:37.608921"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-54"], ["title", "GKE Maintenance Window should be explicitly set"], ["description", "The GKE service performs maintenance functions on the cluster control plane and workers automatically, and the default configuration is for the time to be chosen by the service.  However, an organization will often want to configure that time window to fall during hours when traffic levels are lowest, batch processing is not occurring, or when operations teams are available to troubleshoot application issues."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.maintenancePolicy.window | null | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure either a \"simple\" maintenance window of 4 hours (UTC) per day or a more complex maintenance window with rules to define a more granular schedule.  Consideration: The policy must allow at least 24 hours of maintenance availability in a 14-day rolling window. Only contiguous availability windows of at least four hours are considered."], ["refs", "[{\"text\":\"GKE Maintenance Windows\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/maintenance-windows-and-exclusions\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\",\"ID.RA-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.616712"], ["id", 42]]
  [1m[35m (1.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "54c8a422-1076-5507-afbc-1baf12e5bafc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "54c8a422-1076-5507-afbc-1baf12e5bafc"], ["created_at", "2020-10-07 21:58:37.640389"], ["updated_at", "2020-10-07 21:58:37.640389"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 43]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 43], ["created_at", "2020-10-07 21:58:37.661585"], ["updated_at", "2020-10-07 21:58:37.661585"]]
  [1m[35m (1.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-55"], ["title", "GKE Intranode Visibility should be enabled"], ["description", "When enabling VPC Flow Logs on a VPC where GKE clusters are running, traffic that does not exit the node is not captured.  That is, traffic between two pods on the same node do not exit the host's network and therefore are omitted from VPC Flow Logging.  Enabling Intranode Visibility allows this traffic to be recorded in the VPC Flow Logs for analysis and diagnosis."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.networkConfig.enableIntraNodeVisibility==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure Intranode Visibility on GKE Clusters running in VPCs with Flow logging enabled.  Considerations: VPC Flow logs may increase in size and contribute to additional cost."], ["refs", "[{\"text\":\"GKE Intranode Visibility\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/intranode-visibility\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-3\",\"DE.CM-1\",\"DE.CM-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.674686"], ["id", 43]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "be0d8437-d539-53fc-b017-0c5e92b00050"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "be0d8437-d539-53fc-b017-0c5e92b00050"], ["created_at", "2020-10-07 21:58:37.687123"], ["updated_at", "2020-10-07 21:58:37.687123"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 44]]
  [1m[36mTag Load (0.9ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 44], ["created_at", "2020-10-07 21:58:37.705008"], ["updated_at", "2020-10-07 21:58:37.705008"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-56"], ["title", "GKE Logs should be sent to Stackdriver"], ["description", "By default, GKE enables a Stackdriver log export managed add-on capability that ships all Host OS, Kubernetes components, and container logs to the Stackdriver endpoint in the current project.  This provides a detailed record of nearly all activities in the cluster and nodes to support troubleshooting and auditing functions.  Even if a third party logging solution is implemented to capture and ship logs, it's recommended that this add-on is enabled to ensure all Host OS and Kubernetes component logs are captured off-cluster."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.loggingService==\"logging.googleapis.com/kubernetes\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the Kubernetes Engine Monitoring for \"System and workload logging and monitoring\" via the console or by way of the `--enable-stackdriver-kubernetes` option to gcloud on all GKE clusters. Existing clusters can have this feature enabled in-place with no downtime."], ["refs", "[{\"text\":\"Kubernetes Engine Monitoring\",\"url\":\"https://cloud.google.com/monitoring/kubernetes-engine/installing\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.710770"], ["id", 44]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39990107-d55c-5487-b87f-bbfe4d19bfd2"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39990107-d55c-5487-b87f-bbfe4d19bfd2"], ["created_at", "2020-10-07 21:58:37.720709"], ["updated_at", "2020-10-07 21:58:37.720709"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 45]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 45], ["created_at", "2020-10-07 21:58:37.736016"], ["updated_at", "2020-10-07 21:58:37.736016"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.9ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-57"], ["title", "GKE Metrics should be sent to Stackdriver"], ["description", "By default, GKE enables a Stackdriver metrics export managed add-on capability that ships all Host OS, Kubernetes components, and container metrics to the Stackdriver metrics endpoint in the current project.  This provides a detailed record of nearly all performance metrics in the cluster and nodes to support troubleshooting and auditing functions.  Even if a third party metrics solution is implemented, it's recommended that this add-on is enabled to ensure all Host OS and Kubernetes component metrics are captured off-cluster."], ["platform", "gcp"], ["impact", 6], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.monitoringService==\"monitoring.googleapis.com/kubernetes\") | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the Kubernetes Engine Monitoring for \"System and workload logging and monitoring\" via the console or by way of the `--enable-stackdriver-kubernetes` option to gcloud on all GKE clusters. Existing clusters can have this feature enabled in-place with no downtime."], ["refs", "[{\"text\":\"Kubernetes Engine Monitoring\",\"url\":\"https://cloud.google.com/monitoring/kubernetes-engine/installing\",\"ref\":\"link\"},{\"ids\":[\"DE.AE-1\",\"DE.AE-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.743848"], ["id", 45]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "15d42207-9457-5b63-acf8-186414fa05bb"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "15d42207-9457-5b63-acf8-186414fa05bb"], ["created_at", "2020-10-07 21:58:37.754393"], ["updated_at", "2020-10-07 21:58:37.754393"]]
  [1m[35m (1.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 46]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 46], ["created_at", "2020-10-07 21:58:37.773220"], ["updated_at", "2020-10-07 21:58:37.773220"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-58"], ["title", "GKE Node Pools should use the COS or COS_CONTAINERD Operating System"], ["description", "GKE Nodes can leverage either Container-Optimized OS or Ubuntu-based operating system images.  Unless there is a very specific use-case that a Container-Optimized OS image cannot support such as installed certain drivers and/or kernel modules, Ubuntu nodes are not recommended.  Container-Optimized OS is a fully hardened operating system designed specifically to run containerized workloads with a high degree of security, and it receives automatic updates from Google.  The track record for security issues that affect Ubuntu nodes in GKE that did not affect COS nodes is also important to consider."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.imageType | test(\"^COS\")) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure your GKE Node Pools to leverage either the COS or COS_CONTAINERD image type.  The COS image leverages Docker, and the COS_CONTAINERD image implements only containerd and does not use the commonly known Docker socket at `/var/run/docker.sock` which allows applications that can access that socket to effectively be \"root\" on the host.  If your workloads do not require the ability to mount the docker socket for activities such as image building in-cluster or certain security features, COS_CONTAINERD offers an even smaller attack surface than COS.  Considerations: changing the image type recreates the nodes in the node pool."], ["refs", "[{\"text\":\"GKE Node Images\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/node-images\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.790135"], ["id", 46]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.8ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0208f5cf-e54b-5a4b-a90a-18f3db82d37e"], ["LIMIT", 1]]
  [1m[35m (1.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0208f5cf-e54b-5a4b-a90a-18f3db82d37e"], ["created_at", "2020-10-07 21:58:37.805995"], ["updated_at", "2020-10-07 21:58:37.805995"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 47]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 47], ["created_at", "2020-10-07 21:58:37.824349"], ["updated_at", "2020-10-07 21:58:37.824349"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.3ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-59"], ["title", "GCP Projects should have only one GKE Cluster"], ["description", "GCP Projects are typically the most granular point for IAM permissions to be declared, and the way GKE clusters expect to leverage the project's resources makes isolating multiple clusters in the same project very difficult.  Assignment of IAM Roles related to instance and cluster administration is typically only available at the Project level, so permissions apply to all clusters.  In addition, logs and metrics sent from GKE clusters go to the Project's shared Stackdriver location, and IAM Roles for logging and monitoring grant access for all logs and metrics for all clusters and applications--making it extremely difficult to prevent users of one cluster from seeing all logs from all applications and all namespaces.  Finally, in some cases of misconfiguration, a compromise of a GKE cluster can lead to compromise of all clusters in the same Project."], ["platform", "gcp"], ["impact", 2], ["validation", "\nFor each GCP Project, run `gcloud container clusters list` and ensure only one cluster is listed per project."], ["remediation", "\nOrganize GCP Projects such that each GKE Cluster has a designated Project with no other resources co-located unless they directly support the cluster.  Understand that certain IAM Roles such as \"Compute Admin\" equate to \"Kubernetes Engine Administrator\" because access to the GCE Instances that make up the GKE worker nodes as \"root\" means those users can also access all data, secrets, and applications inside Kubernetes.  Therefore, also review the IAM permissions in the Project to ensure unintended permission \"cross-over\" is minimized."], ["refs", "[{\"text\":\"IAM Concepts\",\"url\":\"https://cloud.google.com/iam/docs/concepts\",\"ref\":\"link\"},{\"text\":\"GCP Enterprise Best Practices\",\"url\":\"https://cloud.google.com/docs/enterprise/best-practices-for-enterprise-organizations\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.AC-5\",\"PR.DS-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.834172"], ["id", 47]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3f80d3c0-7172-5d22-9dc2-a46b12dc6919"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.2ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3f80d3c0-7172-5d22-9dc2-a46b12dc6919"], ["created_at", "2020-10-07 21:58:37.848015"], ["updated_at", "2020-10-07 21:58:37.848015"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 48]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 48], ["created_at", "2020-10-07 21:58:37.871653"], ["updated_at", "2020-10-07 21:58:37.871653"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-60"], ["title", "GKE Node pools should AutoRepair"], ["description", "GKE Nodes have several health checks that continuously run to validate that the worker node is running and capable of handling workloads.  If an issue occurs that the system cannot auto-resolve, the automatic repair feature will handle evicting workloads from the node and reprovisioning the underlying GCE instance for you.  This is highly recommended for reducing administrator load and maintaining healthy clusters."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].management.autoRepair==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the node pools to enable AutoRepair during node pool creation or to existing clusters with the `--enable-autorepair` feature set."], ["refs", "[{\"text\":\"GKE Node Auto Repair\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.881122"], ["id", 48]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2a0af119-6735-501b-964a-30efbcd4a153"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2a0af119-6735-501b-964a-30efbcd4a153"], ["created_at", "2020-10-07 21:58:37.894923"], ["updated_at", "2020-10-07 21:58:37.894923"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 49]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 49], ["created_at", "2020-10-07 21:58:37.906403"], ["updated_at", "2020-10-07 21:58:37.906403"]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-61"], ["title", "GKE Node pools should AutoUpgrade"], ["description", "The GKE service will automatically maintain the version and patch release of the control plane nodes, but the Node Pools are left to the user to keep upgraded by default.  This can result in situations where security issues are patched on the control plane but not on the nodes, and performing node upgrades is an activity that can consume a large amount of administrative time if performed manually across many clusters and node pools.  If your workloads are properly configured to withstand a single node failure, these maintenance activities can be performed during upgrade windows without manual intervention or downtime."], ["platform", "gcp"], ["impact", 2], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].management.autoUpgrade==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the node pools to enable AutoUpgrade during node pool creation or to existing clusters with the `--enable-autoupgrade` feature set.  It's strongly recommended to validate that all workloads can handle the upgrade process smoothly in a development cluster before enabling this setting in production."], ["refs", "[{\"text\":\"GKE Node Auto Upgrade\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-upgrades\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.920420"], ["id", 49]]
  [1m[35m (1.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "4cef5a03-d6db-5fd8-92fe-453b24cdb3db"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "4cef5a03-d6db-5fd8-92fe-453b24cdb3db"], ["created_at", "2020-10-07 21:58:37.932355"], ["updated_at", "2020-10-07 21:58:37.932355"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 50]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 50], ["created_at", "2020-10-07 21:58:37.963599"], ["updated_at", "2020-10-07 21:58:37.963599"]]
  [1m[35m (5.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 50], ["created_at", "2020-10-07 21:58:37.985227"], ["updated_at", "2020-10-07 21:58:37.985227"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-62"], ["title", "GKE Node pools should use the minimum OAuth Scopes"], ["description", "GKE Nodes are fundamentally GCE instances, and GCE instances with a Service Account attached have the permissions of the IAM Roles attached.  However, those permissions can be restricted even further by defining OAuth Scopes that explicitly list the APIs the OAuth Token generated for that Service Account are valid for.  For example, a GCE instance with an attached Service Account that is assigned the IAM Role of \"Project Owner\" but has only the \"https://www.googleapis.com/auth/devstorage\" OAuth Scope will only be able to interact with GCS Buckets.  However, if that OAuth Scope was set to \"https://www.googleapis.com/auth/cloud-platform\" (equivalent to \"any/all APIs\"), that instance would have the full privileges provided by \"Project Owner\".  By default, GKE Node Pools should only specify the following OAuth Scopes that provide the minimum access needed:\n\n* https://www.googleapis.com/auth/devstorage.read_only\n* https://www.googleapis.com/auth/logging.write\n* https://www.googleapis.com/auth/monitoring\n* https://www.googleapis.com/auth/service.management.readonly\n* https://www.googleapis.com/auth/servicecontrol\n* https://www.googleapis.com/auth/trace.append"], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.nodePools[].config.oauthScopes[] | test(\"cloud-platform\") | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure GKE Node Pools to explicitly set only the minimum OAuth Scopes.  For pods/applications that were running on these nodes and leveraging the node's Service Account for access to GCP APIs, understand that access is shared by all pods unless Workload Identity is deployed.  To map GCP Service Accounts to individual Pods/Workloads, create GCP Service Accounts in the Project with the necessary permissions and leverage Workload Identity to attach those credentials directly."], ["refs", "[{\"text\":\"GKE NodePool OAuth Scopes\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster#use_least_privilege_sa\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-1\",\"PR.AC-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:37.993638"], ["id", 50]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1dc51c31-05b3-5fe8-9b79-9d09c7a9db93"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1dc51c31-05b3-5fe8-9b79-9d09c7a9db93"], ["created_at", "2020-10-07 21:58:38.003174"], ["updated_at", "2020-10-07 21:58:38.003174"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 51]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.0ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 51], ["created_at", "2020-10-07 21:58:38.014081"], ["updated_at", "2020-10-07 21:58:38.014081"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-63"], ["title", "GKE Subnet Alias ranges should be configured"], ["description", "In order to support private GKE Clusters, Alias IP ranges on the VPC Subnets is required.  In addition to private clusters, Alias IP ranges simplify the route tables in the VPC, reduce the number of \"hops\" traffic takes from load balancers to Pods, and allows the GCE network interfaces to perform anti-spoofing checks as IP forwarding is not required on the instance.  Finally, the separation of VM IPs from Container IPs allows for native firewall rules to be configured for pod traffic separately from VM traffic."], ["platform", "gcp"], ["impact", 5], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.ipAllocationPolicy.useIpAliases==true) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nDuring cluster creation, specify a VPC Subnet that supports Alias IP ranges and secondary ranges for Pods and Services.  This can only be done at cluster creation time."], ["refs", "[{\"text\":\"VPC Alias IPs\",\"url\":\"https://cloud.google.com/vpc/docs/alias-ip\",\"ref\":\"link\"},{\"text\":\"VPC-Native GKE Clusters\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/alias-ips\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.PT-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.023358"], ["id", 51]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8aced34e-ed35-50d8-aaab-3bd7271bb6f7"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8aced34e-ed35-50d8-aaab-3bd7271bb6f7"], ["created_at", "2020-10-07 21:58:38.032562"], ["updated_at", "2020-10-07 21:58:38.032562"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 52]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.0ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 52], ["created_at", "2020-10-07 21:58:38.052958"], ["updated_at", "2020-10-07 21:58:38.052958"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 52], ["created_at", "2020-10-07 21:58:38.064012"], ["updated_at", "2020-10-07 21:58:38.064012"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-64"], ["title", "Legacy ABAC authorization in GKE"], ["description", "Role-Based Access Control has been the default authorization mechanism in Kubernetes since version 1.6.  GKE still provides a legacy capability that supports ABAC, but it should not be used.  It essentially provides \"cluster admin\" access for any authenticated credential to the cluster and has no method for changing this policy.  This is an extremely permissive setting that allows for full cluster compromise should an attacker gain access to a single pod with a mounted Kubernetes service account or a valid cluster credential."], ["platform", "gcp"], ["impact", 9], ["validation", "\nRun `gcloud container clusters describe <clustername> --format=json | jq -r 'select(.legacyAbac.enabled | not) | \"(.name)\"'` and ensure that the cluster's name is listed."], ["remediation", "\nConfigure the cluster without the `--enable-legacy-authorization` flag set.  If migrating an existing cluster from ABAC to RBAC by modifying this setting in-place, ensure that all the required RBAC RoleBindings and ClusterRoleBindings are present first.  This should be performed in a development environment before applying this process to production clusters."], ["refs", "[{\"text\":\"GKE Cluster Hardening\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.070399"], ["id", 52]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.8ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "055adcff-8a12-503a-8056-fe418d714bbf"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "055adcff-8a12-503a-8056-fe418d714bbf"], ["created_at", "2020-10-07 21:58:38.081766"], ["updated_at", "2020-10-07 21:58:38.081766"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 53]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 53], ["created_at", "2020-10-07 21:58:38.093627"], ["updated_at", "2020-10-07 21:58:38.093627"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-65"], ["title", "CloudSQL Instances High-Availability"], ["description", "By default, CloudSQL instances are deployed as a single instance, and this means an instance failure or availability-zone outage would take the database offline.  Production applications should be relying on access to data stores that can withstand these failure conditions where possible, and the CloudSQL service offering provides a high-availability instance type that runs in multiple availability-zones in the same region for this purpose."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.availabilityType==\"ZONAL\") | \"(.name) Type: (.settings.availabilityType)\"'` and ensure no entries are listed as \"ZONAL\"."], ["remediation", "\nCreate or update the CloudSQL instances used in production with the \"REGIONAL\" availability type instead of the default of \"ZONAL\". Existing instances can be modified to have these settings take effect, but it requires the instance to be restarted."], ["refs", "[{\"text\":\"CloudSQL MySQL High Availability\",\"url\":\"https://cloud.google.com/sql/docs/mysql/high-availability\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL High Availability\",\"url\":\"https://cloud.google.com/sql/docs/postgres/high-availability\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver High Availability\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/high-availability\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.100455"], ["id", 53]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "323aca0a-eab5-5ecc-8e58-ea66f6cb8103"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "323aca0a-eab5-5ecc-8e58-ea66f6cb8103"], ["created_at", "2020-10-07 21:58:38.109414"], ["updated_at", "2020-10-07 21:58:38.109414"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 54]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 54], ["created_at", "2020-10-07 21:58:38.121767"], ["updated_at", "2020-10-07 21:58:38.121767"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-66"], ["title", "CloudSQL Instances maintenance windows"], ["description", "The CloudSQL service performs maintenance functions on the instances automatically, and the default configuration is for the time to be chosen by the service.  However, an organization will often want to configure that time window to fall during hours when traffic levels are lowest, batch processing is not occurring, or when operations teams are available to troubleshoot application issues."], ["platform", "gcp"], ["impact", 5], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.maintenanceWindow.day==0 and .settings.maintenanceWindow.hour==0) | \"(.name) Type: (.settings.maintenanceWindow.day) (.settings.maintenanceWindow.hour)\"'` and ensure no entries are listed as \"0 0\"."], ["remediation", "\nConfigure the maintenance preferences on the CloudSQL instance to a preferred window that has the days and hours when updates should occur, and select the order of update to be \"Any\", \"Earlier\", or \"Later\" to correspond to the timing of when the rolling updates should include this instance.  Typically, development instances should be set to \"Earlier\" and production instances set to \"Later\" to help validate upgrades and patches on less critical databases first.  Also, opt-in to email notifications for maintenance on the communications page at `https://console.cloud.google.com/user-preferences/communication`."], ["refs", "[{\"text\":\"CloudSQL MySQL Maintenance Windows\",\"url\":\"https://cloud.google.com/sql/docs/mysql/maintenance\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Maintenance Windows\",\"url\":\"https://cloud.google.com/sql/docs/postgres/maintenance\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Maintenance Windows\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/maintenance\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.128828"], ["id", 54]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "e8f23fba-c1ab-5c39-8a2b-faf957ded12c"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "e8f23fba-c1ab-5c39-8a2b-faf957ded12c"], ["created_at", "2020-10-07 21:58:38.137860"], ["updated_at", "2020-10-07 21:58:38.137860"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 55]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 55], ["created_at", "2020-10-07 21:58:38.148954"], ["updated_at", "2020-10-07 21:58:38.148954"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-67"], ["title", "CloudSQL Instance automatic backups with point-in-time recovery"], ["description", "By default, CloudSQL instances have automatic backups with point-in-time recovery enabled.  It's important that these settings are not disabled to ensure that all databases can be restored to a known-good state should a security incident occur.  For example, a SQL injection attack that results in the deletion or modification of tables in the database."], ["platform", "gcp"], ["impact", 9], ["validation", "\nIn each project, run `gcloud sql instances list --format=json | jq -r '.[] | select(.settings.backupConfiguration.enabled==false) | \"(.name) Backups on: (.settings.backupConfiguration.enabled) and PITR on: (.settings.backupConfiguration.binaryLogEnabled)\"'` and ensure no entries are listed."], ["remediation", "\nEnsure all CloudSQL instances are configured with automatic backups during a desired window and point-in-time recovery is enabled.  Existing instances can be modified to have these settings take effect, but it requires the instance to be restarted."], ["refs", "[{\"text\":\"CloudSQL MySQL Backups\",\"url\":\"https://cloud.google.com/sql/docs/mysql/backup-recovery/backups\",\"ref\":\"link\"},{\"text\":\"CloudSQL PostgreSQL Backups\",\"url\":\"https://cloud.google.com/sql/docs/postgres/backup-recovery/backups\",\"ref\":\"link\"},{\"text\":\"CloudSQL Sqlserver Backups\",\"url\":\"https://cloud.google.com/sql/docs/sqlserver/backup-recovery/backups\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-4\",\"PR.PT-5\",\"PR.IP-10\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.157107"], ["id", 55]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9bde9d05-e5e0-545e-bcea-a722d5e0d511"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9bde9d05-e5e0-545e-bcea-a722d5e0d511"], ["created_at", "2020-10-07 21:58:38.166126"], ["updated_at", "2020-10-07 21:58:38.166126"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 56]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 56], ["created_at", "2020-10-07 21:58:38.177361"], ["updated_at", "2020-10-07 21:58:38.177361"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-68"], ["title", "Public nodes via SSH"], ["description", "The Kubernetes Worker nodes are exposed publicly via SSH.  This provides convenient remote administrative access, but it affords only a single layer of defense in front of the Kubernetes cluster and all applications and data inside. Having \"root\" access to one Kubernetes cluster node is very often sufficient to become \"cluster-admin\" in the cluster which grants full control of the cluster and the underlying nodes."], ["platform", "k8s"], ["impact", 5], ["validation", "\nEnsure that all Kubernetes worker nodes are not available on TCP/22 from any IP address using a simple port probe. e.g. `nc -vz ip.of.the.worker 22`."], ["remediation", "\nConfigure the firewall rules on the Kubernetes worker systems to be restricted to a known set of IP ranges for SSH access.  In environments with bastion hosts or VPNs, their internal subnet range or security groups are commonly used."], ["refs", "[{\"text\":\"Kubernetes Security Best Practices\",\"url\":\"https://kubernetes.io/blog/2016/08/security-best-practices-kubernetes-deployment/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.MA-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.184334"], ["id", 56]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "68066452-dd6e-5468-a50d-f70ef5bb4adc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "68066452-dd6e-5468-a50d-f70ef5bb4adc"], ["created_at", "2020-10-07 21:58:38.194750"], ["updated_at", "2020-10-07 21:58:38.194750"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 57]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 57], ["created_at", "2020-10-07 21:58:38.204345"], ["updated_at", "2020-10-07 21:58:38.204345"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-69"], ["title", "Secrets in ConfigMaps"], ["description", "Kubernetes ConfigMaps can be used to store configuration key/value pairs and files to be dynamically mounted into pods at runtime, and those can often contain sensitive data like API keys and other credentials.  However, this exposes them to users and other workloads that interact with the API server who have the RBAC permission \"get configmaps\" in the cluster which is commonly a much wider audience than desired."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get configmaps --all-namespaces -o yaml > cfgmaps.yml` and use a tool like TruffleHog to review the data for potentially sensitive items."], ["remediation", "\nEnsure that no secret material is directly defined in ConfigMaps.  Instead, store them in a Secret and use the secretKeyRef mechanism to mount them in as files inside the container at runtime."], ["refs", "[{\"text\":\"Kubernetes ConfigMaps\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/\",\"ref\":\"link\"},{\"text\":\"TruffleHog\",\"url\":\"https://github.com/dxa4481/truffleHog\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.210582"], ["id", 57]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0b473d00-130f-5be6-a6ff-3ef74e8ee55e"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0b473d00-130f-5be6-a6ff-3ef74e8ee55e"], ["created_at", "2020-10-07 21:58:38.220755"], ["updated_at", "2020-10-07 21:58:38.220755"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 58]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 58], ["created_at", "2020-10-07 21:58:38.231154"], ["updated_at", "2020-10-07 21:58:38.231154"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-70"], ["title", "Ensure resource specification enforcement is installed"], ["description", "By default in Kubernetes, the ability to create resources is only controlled via RBAC authorization.  If a user has the ability to create or modify a Pod, they are able to create or modify any setting during its creation.  This can include settings that allow it to run as root/privileged, mount the host filesystem, to add Linux system capabilities, to attach to the host's network and process namespace, and more.  All of these settings are potential pathways for escaping to the underlying nodes and compromising the entire cluster.  To prevent users from creating resources with undesired configurations, an administrator can deploy an \"Admission Controller\" such as PodSecurityPolicy or a \"Dynamic Admission Control Webhook\" to ask a service like Gatekeeper.  If either determines the workload to not meet policy, it can prevent the workload from running."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get psps --all-namespaces` to identify `PodSecurityPolicy` resources in place, or run `kubectl get deployments --all-namespaces` and look for `gatekeeper` or `k-rail` deployments to be present."], ["remediation", "\nWhile PodSecurityPolicy is a native admission controller that can protect clusters from users running insecure pod workloads, it is still in Kubernetes beta, and it is limited only to Pod resources.  The Gatekeeper project, which uses Open Policy Agent as its policy engine, can be deployed more easily, can review any resource in the cluster if desired, and allows for full customization of what to look for.  Deploying either OPA/Gatekeeper or K-Rail is therefore the recommended solution for those that do not already have PodSecurityPolicy implemented."], ["refs", "[{\"text\":\"Kubernetes PodSecurityPolicy\",\"url\":\"https://kubernetes.io/docs/concepts/policy/pod-security-policy/\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"text\":\"K-rail\",\"url\":\"https://github.com/cruise-automation/k-rail\",\"ref\":\"link\"},{\"text\":\"GKE PodSecurityPolicy\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/pod-security-policies\",\"ref\":\"link\"},{\"text\":\"EKS PodSecurityPolicy\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/pod-security-policy.html\",\"ref\":\"link\"},{\"text\":\"AKS PodSecurityPolicy\",\"url\":\"https://docs.microsoft.com/en-us/azure/aks/use-pod-security-policies\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.238318"], ["id", 58]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "261a1a40-e362-5bbc-ad48-cc59419ac436"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "261a1a40-e362-5bbc-ad48-cc59419ac436"], ["created_at", "2020-10-07 21:58:38.248015"], ["updated_at", "2020-10-07 21:58:38.248015"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (2.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 59]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 59], ["created_at", "2020-10-07 21:58:38.273716"], ["updated_at", "2020-10-07 21:58:38.273716"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 59], ["created_at", "2020-10-07 21:58:38.283569"], ["updated_at", "2020-10-07 21:58:38.283569"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-71"], ["title", "Validate NetworkPolicies are defined in each namespace"], ["description", "By default in Kubernetes, all Pods can communicate with each other by IP and egress to any subnet (including the Internet) unless routing or firewalls are added to prevent that traffic.  This presents ample opportunity for lateral movement from the perspective of a compromised workload. One of the best ways to reduce the scope of that movement is to deploy NetworkPolicy resources that define firewall rules for pod-to-pod traffic.  All pod-to-pod and egress traffic is allowed, and this means that pods that handle customer data can talk directly to core Kubernetes system pods, the Internet, and other systems inside the VPC if the security groups allow."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get networkpolicies --all-namespaces` and ensure each namespace has the desired policies defined."], ["remediation", "\nImplement NetworkPolicy rules on the kube-system namespace to prevent all inbound traffic from non-kube-system namespaces to all workloads in the kube-system namespace with the exception of UDP/TCP 53 for DNS lookups.  Next, identify the network traffic patterns of externally exposed workloads and implement NetworkPolicies that restrict their traffic to the \"next hop\" service or ranges.  Finally, perform the same pattern to all internal workloads.  Considerations: Implementing NetworkPolicies should be performed in a development environment to fully understand implications and to avoid introducing an outage in production."], ["refs", "[{\"text\":\"Kubernetes Network Policies\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/network-policies/\",\"ref\":\"link\"},{\"text\":\"NetworkPolicy Recipes\",\"url\":\"https://github.com/ahmetb/kubernetes-network-policy-recipes\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.292186"], ["id", 59]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "1666b935-62e1-5594-a7a6-ab0395b90ed4"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "1666b935-62e1-5594-a7a6-ab0395b90ed4"], ["created_at", "2020-10-07 21:58:38.300342"], ["updated_at", "2020-10-07 21:58:38.300342"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 60]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.0ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 60], ["created_at", "2020-10-07 21:58:38.311880"], ["updated_at", "2020-10-07 21:58:38.311880"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-72"], ["title", "ServiceAccount mounted unnecessarily"], ["description", "By default, the \"default\" Service Account in each namespace will be mounted inside every container in every Pod unless explicitly configured to use another Service Account or to not be mounted.  The Service Account token that is mounted for convenience inside the pod in case the container workload needs a valid credential to communicate with the Kubernetes API.  However, most workloads do not require this access, and so they should be explicitly configured not to mount it to minimize exposure to these credentials."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace +\"/\"+ .metadata.name +\": \"+ .spec.serviceAccount'` and review the listing for pods that mount service accounts where API access is not required.  Typically, workloads that mount the \"default\" service account are likely candidates as pods should be mounting dedicated service accounts if needed."], ["remediation", "\nFor every non-kube-system namespace, modify all Service Accounts to opt out of automounting API credentials by setting automountServiceAccountToken: false.  Ensure RBAC bindings to all \"default\" Service Accounts are removed, and use dedicated Service Accounts for each workload that needs API Access with dedicated RBAC Role/ClusterRoleBindings."], ["refs", "[{\"text\":\"Kubernetes ServiceAccounts\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.320025"], ["id", 60]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "9feaff35-13bb-5856-aac9-7cd93cae3beb"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "9feaff35-13bb-5856-aac9-7cd93cae3beb"], ["created_at", "2020-10-07 21:58:38.328975"], ["updated_at", "2020-10-07 21:58:38.328975"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 61]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 61], ["created_at", "2020-10-07 21:58:38.339085"], ["updated_at", "2020-10-07 21:58:38.339085"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-73"], ["title", "Orphaned Persistent Volume Claims found"], ["description", "Multiple persistent disk volume claims were found to be in the \"Released\" state, and they indicate a potential misconfiguration in a deployment or statefulset leaving them behind."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pvc --all-namespaces` and look for items in the \"Released\" state.  Ideally, all should be in use."], ["remediation", "\nEnsure the workloads that created and abandoned the affected persistent volume claims correctly clean up after themselves and delete the persistent volume claims if they are no longer needed."], ["refs", "[{\"text\":\"Kubernetes Persistent Volumes\",\"url\":\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.344871"], ["id", 61]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "329030a1-3e54-50be-99c1-ff580fce5595"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "329030a1-3e54-50be-99c1-ff580fce5595"], ["created_at", "2020-10-07 21:58:38.353825"], ["updated_at", "2020-10-07 21:58:38.353825"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 62]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 62], ["created_at", "2020-10-07 21:58:38.364899"], ["updated_at", "2020-10-07 21:58:38.364899"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-74"], ["title", "Inconsistent use of CPU/RAM requests/limits"], ["description", "By default in Kubernetes, workloads that do not specify how many resources they expect to use and/or a limit to their resources receive the default settings.  The default settings depend on a LimitRange resource in the namespace, and the default is to request 1/10th of a CPU core (100 millicores or \"100m\"), no request for RAM, and no CPU or RAM limits.  This means that every pod is able to burst up to the total physical resources of the node, and the scheduler will tightly pack pods on a node.  This configuration is typically no problem at low or average load, so it might take a while to surface and cause resource constraint problems.  But when those resources are exhausted, the node becomes \"Unready\" and all workloads are evicted.  When they land on the other nodes that are already heavily loaded, it overloads them until they evict all pods.  This can cause a cascading resource failure outage."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace as $ns | .metadata.name as $name| .spec.containers[] | $ns +\"/\"+ $name +\"[\"+ .name +\"]: \"+ .resources.requests.cpu +\",\"+ .resources.limits.cpu +\",\"+ .resources.requests.memory +\",\"+ .resources.limits.memory'` to get a comma separated listing of \"CPU Req, CPU Limits, Memory Reqs, Memory Limits\" for each container in every pod.  All containers should specify all four values explicitly."], ["remediation", "\nFor every deployment in the cluster, ensure it has the proper settings for CPU and Memory \"Requests\" and CPU and Memory \"Limits\".  The \"Requests\" settings are vital for the scheduler to correctly place workloads on nodes without going over actual capacity.  The \"Limits\" settings are vital for the node to ensure the workload does not consume all physical resources on the node.  \"Requests\" should be set at 10% above average consumption and \"Limits\" should be 10-20% higher than maximum consumption.  Use \"kubectl top node\" and \"kubectl top pods --all-namespaces\" to see actual usage for running workloads."], ["refs", "[{\"text\":\"Kubernetes Resourcing\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/\",\"ref\":\"link\"},{\"text\":\"Kubectl Cheat Sheet\",\"url\":\"https://kubernetes.io/docs/reference/kubectl/cheatsheet/#interacting-with-running-pods\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.370573"], ["id", 62]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d8276fe4-4044-5077-be5c-d95fc59f6e14"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d8276fe4-4044-5077-be5c-d95fc59f6e14"], ["created_at", "2020-10-07 21:58:38.379471"], ["updated_at", "2020-10-07 21:58:38.379471"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 63]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 63], ["created_at", "2020-10-07 21:58:38.393478"], ["updated_at", "2020-10-07 21:58:38.393478"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-75"], ["title", "Ensure all pods reference container images from known sources"], ["description", "By default, Kubernetes allows users with the ability to create pods to reference any container image path, including public registries like DockerHub.  This allows developers to share and use pre-made container images easily, but it enables unvalidated and untrusted code to run inside your cluster with potential access to mounted secrets and service account tokens.  Container images should be verified to be conformant to security standards before being run, and the first step to this is to validate that all container images are being pulled from a known set of registries.  This helps development teams and security teams work from the same base location for running and validating images."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get po -A -ojsonpath='{..image}' | kubectl get pods --all-namespaces -o jsonpath='{..image}' |tr -s '[[:space:]]' '\n' | sort | uniq -c ` and ensure all images are sourced from the official Kubernetes or cloud provider registries and your own internal container registries."], ["remediation", "\nReview all deployments and pod specifications, and find any that reference non-approved container registries.  Create a dedicated container registry in your environment, validate those container images meet your security policies, and store/mirror them to that dedicated container registry/registries.  Consider enforcing image sources early with a validation step in the CI/CD pipeline and enforcing the policy with OPA/Gatekeeper or other policy-based admission controller inside the cluster."], ["refs", "[{\"text\":\"Kubectl List Images\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/list-all-running-container-images/\",\"ref\":\"link\"},{\"text\":\"DockerHub Library\",\"url\":\"https://hub.docker.com/u/library\",\"ref\":\"link\"},{\"text\":\"Google Container Registry\",\"url\":\"https://cloud.google.com/container-registry\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.400523"], ["id", 63]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "51a10d61-4108-5f95-9db4-c172cc4d03a7"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "51a10d61-4108-5f95-9db4-c172cc4d03a7"], ["created_at", "2020-10-07 21:58:38.409005"], ["updated_at", "2020-10-07 21:58:38.409005"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 64]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 64], ["created_at", "2020-10-07 21:58:38.421589"], ["updated_at", "2020-10-07 21:58:38.421589"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-76"], ["title", "Containers are not built using centralized, automated CI pipeline"], ["description", "Currently, the custom containers are built manually from an administrator's workstation and not via a centralized, automated process.  The key concern is reproducibility.  Without centralizing the source code and the code and configuration to build images, only one person with a specific laptop can build and change container images confidently."], ["platform", "k8s"], ["impact", 9], ["validation", "\nFor each running container image, ensure that there is a source control repository where it holds the instructions for how to build the image and that it leverages a CI or automated build system to generate a new image artifact.  Review the build history to ensure there are recent passing builds."], ["remediation", "\nImplement a CI system or leverage native container build services within the cloud provider to build newly tagged container images and push them to a private registry.  This ensures repeatability of the process by any member of the team as well as a shared history for build success and failures are present."], ["refs", "[{\"text\":\"GCP Cloud Build\",\"url\":\"https://cloud.google.com/cloud-build/docs/\",\"ref\":\"link\"},{\"text\":\"Google Container Registry\",\"url\":\"https://cloud.google.com/container-registry/docs/\",\"ref\":\"link\"},{\"ids\":[\"ID.SC-4\",\"ID.SC-2\",\"PR.IP-2\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.427574"], ["id", 64]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "df3d2443-7fdc-5024-a970-135a7e32d438"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "df3d2443-7fdc-5024-a970-135a7e32d438"], ["created_at", "2020-10-07 21:58:38.435234"], ["updated_at", "2020-10-07 21:58:38.435234"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 65]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 65], ["created_at", "2020-10-07 21:58:38.445962"], ["updated_at", "2020-10-07 21:58:38.445962"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-77"], ["title", "Ensure continuous container scanning and redeployment"], ["description", "When deploying container images into a Kubernetes cluster, they should first be reviewed to meet an acceptable risk profile.  This is typically done using automated container vulnerability scans at build time.  However, container deployments with infrequent needs for changes will mean that they can exist for long periods without being rebuilt in order to receive security fixes.  As the number of deployments grows, this process must be automated or it will be quickly beyond a human's ability to manage."], ["platform", "k8s"], ["impact", 9], ["validation", "\nEnsure a solution is implemented, validate that it is deployed in all clusters if needed, and verify that all container registries and images are being scanned daily (or more frequently) for new vulnerabilities.  If possible, validate that a policy is in place to alert administrators of severe vulnerabilities and even block them from being deployed."], ["remediation", "\nDeploy either a cloud provider solution or leverage a third party tool that continuously scans images in use against all current vulnerabilities.  Configure a security policy such that all high/critical vulnerabilities alert the appropriate teams.  If possible, configure the tooling to automatically trigger a new container build."], ["refs", "[{\"text\":\"Kritis\",\"url\":\"https://github.com/grafeas/kritis\",\"ref\":\"link\"},{\"text\":\"Grafeas\",\"url\":\"https://github.com/grafeas/kritis/blob/master/docs/tutorial.md\",\"ref\":\"link\"},{\"text\":\"Sysdig\",\"url\":\"https://sysdig.com\",\"ref\":\"link\"},{\"text\":\"Twistlock\",\"url\":\"https://twistlock.com\",\"ref\":\"link\"},{\"text\":\"Aqua Security\",\"url\":\"https://aquasec.com\",\"ref\":\"link\"},{\"text\":\"GKE Binary Authorization\",\"url\":\"https://cloud.google.com/binary-authorization/docs/setting-up\",\"ref\":\"link\"},{\"text\":\"GCP Container Analysis\",\"url\":\"https://cloud.google.com/container-registry/docs/container-analysis\",\"ref\":\"link\"},{\"ids\":[\"ID.SC-4\",\"ID.SC-2\",\"PR.DS-6\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.455757"], ["id", 65]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "86d03ac3-702b-567a-9407-7bd74e633bc3"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "86d03ac3-702b-567a-9407-7bd74e633bc3"], ["created_at", "2020-10-07 21:58:38.465436"], ["updated_at", "2020-10-07 21:58:38.465436"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 66]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 66], ["created_at", "2020-10-07 21:58:38.476131"], ["updated_at", "2020-10-07 21:58:38.476131"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.0ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-78"], ["title", "Cluster workloads mount the Docker socket directly"], ["description", "In Kubernetes clusters running on nodes that leverage Docker for running containers, providing access to the /var/run/docker.sock is equivalent to granting that container 'root' on the underlying host as it allows for running containers on the node with any permission.  It should not be mounted inside a container as it bridges two layers in the infrastructure that should be kept independent from each other.  With the socket mounted, cluster users do not have to have 'cluster admin' to be able to get 'root' on the nodes.  Instead, they only need the 'exec pod' permission in this namespace to be able to exec commands inside this container to become 'root' on the nodes and compromise the cluster.  In addition, many Kubernetes distributions are moving to ContainerD which does not have a listening Docker socket and therefore a smaller attack surface.  In GKE, this workload cannot operate on the newer 'COS_CONTAINERD' image types."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace as $ns | .metadata.name as $name| .spec.volumes[] |select(.hostPath.path|tostring|test(\".sock\")) | $ns +\"/\"+ $name +\"[\"+ .name +\"]: \"+ .hostPath.path'` and validate that no pods are returned that mount \"/var/run/docker.sock\" or similar."], ["remediation", "\nConsider modifying the workload or choosing another workload that does similar functionality but does not mount the Docker socket.  This will remove the attack surface added by this workload and also enable the migration to the COS_CONTAINERD image type when it becomes the default."], ["refs", "[{\"text\":\"GKE Containerd\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/concepts/using-containerd\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.481853"], ["id", 66]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7ff475ce-ef30-5d68-b04a-e96be923090a"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7ff475ce-ef30-5d68-b04a-e96be923090a"], ["created_at", "2020-10-07 21:58:38.492187"], ["updated_at", "2020-10-07 21:58:38.492187"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 67]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 67], ["created_at", "2020-10-07 21:58:38.501873"], ["updated_at", "2020-10-07 21:58:38.501873"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-79"], ["title", "Ensure privileged containers are only in system namespaces"], ["description", "Container run in Kubernetes that require deep access to the underlying worker nodes are often run in a `privileged` security context.  Common examples are daemonsets that implement functionality for container and host logging or metrics export, driver installation, and container and host security detection.  Privileged containers are essentially \"root\" on the underlying node, and they should therefore be kept in \"system\" namespaces to allow for proper RBAC and admission control policies to be created to protect them.  If they are in namespaces with other normal application workloads, it becomes difficult to ensure proper separation and prevent host escapes."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | \"(.metadata.namespace)/(.metadata.name): (.spec.containers[].securityContext.privileged)\"' | grep -v \"null$\"` and validate that all privileged pods are in namespaces named and dedicated for system workloads."], ["remediation", "\nEither leverage the `kube-system` namespace or deploy privileged daemonsets to dedicated namespaces only used for these purposes.  Restrict RBAC permissions and admission control policies to only permit the required admins access to operate and exec into them for troubleshooting."], ["refs", "[{\"text\":\"Kubernetes port-forward\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\",\"PR.PT-3\",\"PR.AT-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.508426"], ["id", 67]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3957d9b0-4a99-5b41-9520-2b7228e9d343"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3957d9b0-4a99-5b41-9520-2b7228e9d343"], ["created_at", "2020-10-07 21:58:38.517488"], ["updated_at", "2020-10-07 21:58:38.517488"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 68]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.1ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 68], ["created_at", "2020-10-07 21:58:38.538824"], ["updated_at", "2020-10-07 21:58:38.538824"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.7ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-80"], ["title", "Container images do not refer to the exact tag or commit"], ["description", "When referring to a container image stored in a registry, it's common practice for the owner of the image to tag the most recent image with a semver tag and also the `latest` tag when uploading it.  This is a convenenience for users wanting to work with the most up-to-date image, but it presents an opportunity for inconsistencies inside Kubernetes.  If a deployment with more than one replica references an image with the tag `latest`, the underlying node will pull and run that image at that time.  If the image in the registry is updated with a new `latest` image and the deployment scales the number of replicas such that a new worker node is to run it, that node will potentially pull the newer `latest` image. This could result in multiple pods in a single deployment running a different image with different functionality or even cause a difficult to trace outage.  During the image build process, it's common practice to tag the image with shortened hash from the git commit that triggered the image build to help with tracing an image directly back to the code and process that created it and to satisfy certain auditing requirements."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get po -A -ojsonpath='{..image}' | kubectl get pods --all-namespaces -o jsonpath='{..image}' |tr -s '[[:space:]]' '\n' | sort | uniq -c | grep latest` and ensure no images reference the `latest` tag."], ["remediation", "\nReview all deployments and pod specifications, and modify any that reference the `latest` tag to use a specific version tag or even the `sha256` hash.  Consider enforcing this practice early with a validation step in the CI/CD pipeline and enforcing the policy with OPA/Gatekeeper or other policy-based admission controller inside the cluster."], ["refs", "[{\"text\":\"Container Image Tagging\",\"url\":\"https://docs.docker.com/engine/reference/commandline/build/#tag-an-image--t\",\"ref\":\"link\"},{\"text\":\"Kubectl List Images\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/list-all-running-container-images/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Configuration Best Practices\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/overview/#container-images\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-6\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.550125"], ["id", 68]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "640b3852-f894-5537-b656-6bb5501f9602"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "640b3852-f894-5537-b656-6bb5501f9602"], ["created_at", "2020-10-07 21:58:38.560809"], ["updated_at", "2020-10-07 21:58:38.560809"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 69]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 69], ["created_at", "2020-10-07 21:58:38.570630"], ["updated_at", "2020-10-07 21:58:38.570630"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-81"], ["title", "Inconsistent use of Liveness and Readiness probes on pods listening on a port"], ["description", "By default, pods that listen on ports do not have Liveness and Readiness probes configured.  These are both required for pods to be able to support zero-downtime deployment upgrades for services that handle continuous traffic.  Readiness probes are network or command checks that have to succeed before the pod goes to the 'Ready' state.  This means traffic routed to them by a Service will not occur until they are 'ready' to handle that traffic successfully.  Liveness probes are network or command checks that have to succeed on a routine basis for the pod to remain in the 'Ready' state.  If the checks fail, the pod will be removed from the 'Ready' state, and the service will know not to route traffic to that pod."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | .metadata.namespace as $ns | .metadata.name as $name| .spec.containers[] | select(.ports) | $ns +\"/\"+ $name + \"[\"+ .name +\"]: \"+ (.readinessProbe.successThreshold|tostring) +\" \"+ (.livenessProbe.successThreshold|tostring)'` and ensure every container that exposes ports also has non-zero numbers representing the readiness and liveness probes."], ["remediation", "\nAll pods that listen on ports behind services should have Liveness and Readiness probes configured in their pod specification to behave properly and reduce network-related errors."], ["refs", "[{\"text\":\"Liveness and Readiness Probes\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.576965"], ["id", 69]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39a7bf62-d40d-5b79-93e3-3abc0512d3a3"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39a7bf62-d40d-5b79-93e3-3abc0512d3a3"], ["created_at", "2020-10-07 21:58:38.585407"], ["updated_at", "2020-10-07 21:58:38.585407"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 70]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 70], ["created_at", "2020-10-07 21:58:38.596974"], ["updated_at", "2020-10-07 21:58:38.596974"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-82"], ["title", "AppArmor profiles are not implemented"], ["description", "AppArmor is a Linux kernel security module that supplements the standard Linux user and group based permissions to confine programs to a limited set of resources. AppArmor can be configured for any application to reduce its potential attack surface and provide greater in-depth defense. It is configured through profiles tuned to whitelist the access needed by a specific program or container, such as Linux capabilities, network access, file permissions, etc.  AppArmor can help you to run a more secure deployment by restricting what containers are allowed to do, and/or provide better auditing through system logs. It is important to keep in mind that AppArmor is not a full exploit prevention mechanism, but it can reduce the abilities of a process inside a container that can limit further damage.  GKE nodes running Ubuntu and COS or COS_CONTAINERD have AppArmor support automatically enabled, but Kubernetes deployments must opt-in to be able to use AppArmor pods when they are run."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[].metadata | \"(.namespace)/(.name): (.annotations)\"' | grep -v apparmor` to find the pods that do not specify an apparmor profile in their annotations."], ["remediation", "\nFor all non-kube-system deployments/statefulsets, annotate the pod specification with \"container.apparmor.security.beta.kubernetes.io/<container_name>: \"runtime/default\" for each container in the pod specification.  This will enable the default AppArmor profile if the container is not running as a \"privileged\" container and afford protection against sensitive endpoints in /proc and /sys."], ["refs", "[{\"text\":\"Kubernetes AppArmor\",\"url\":\"https://kubernetes.io/docs/tutorials/clusters/apparmor/\",\"ref\":\"link\"},{\"text\":\"Docker AppArmor\",\"url\":\"https://docs.docker.com/engine/security/apparmor/\",\"ref\":\"link\"},{\"text\":\"Default AppArmor Profile\",\"url\":\"https://github.com/moby/moby/blob/master/profiles/apparmor/template.go\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-3\",\"DE.CM-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.602099"], ["id", 70]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d363bc20-2c74-582a-9bfd-8ac5bc228dbd"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d363bc20-2c74-582a-9bfd-8ac5bc228dbd"], ["created_at", "2020-10-07 21:58:38.609545"], ["updated_at", "2020-10-07 21:58:38.609545"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 71]]
  [1m[36mTag Load (0.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 71], ["created_at", "2020-10-07 21:58:38.621152"], ["updated_at", "2020-10-07 21:58:38.621152"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-83"], ["title", "Seccomp profiles are not implemented"], ["description", "Seccomp profiles define which system calls should be allowed or blocked, and the container runtime will apply then at container start time so the kernel can enforce it. Once applied, you are effectively decreasing your attack surface and limiting the container processes from making privileged syscalls in the event of a container compromise."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[].metadata | \"(.namespace)/(.name): (.annotations)\"' | grep -v seccomp` to find the pods that do not specify a seccomp profile in their annotations."], ["remediation", "\nFor all non-kube-system deployments/statefulsets, annotate the pod specification with \"container.seccomp.security.alpha.kubernetes.io/<container_name>: \"runtime/default\" for each container in the pod specification.  This will enable the default Seccomp profile if the container is not running as a \"privileged\" container and afford protection against dangerous syscalls."], ["refs", "[{\"text\":\"Kubernetes SecurityContext\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Seccomp\",\"url\":\"https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp\",\"ref\":\"link\"},{\"text\":\"Seccomp Examples\",\"url\":\"https://github.com/kubernetes/kubernetes/blob/release-1.4/docs/design/seccomp.md#examples\",\"ref\":\"link\"},{\"text\":\"Getting Started with Seccomp and Kubernetes\",\"url\":\"https://itnext.io/seccomp-in-kubernetes-part-i-7-things-you-should-know-before-you-even-start-97502ad6b6d6\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-3\",\"DE.CM-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.627422"], ["id", 71]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5ad73b30-7bdd-51a2-8f89-0354a88a0878"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5ad73b30-7bdd-51a2-8f89-0354a88a0878"], ["created_at", "2020-10-07 21:58:38.636309"], ["updated_at", "2020-10-07 21:58:38.636309"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 72]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 72], ["created_at", "2020-10-07 21:58:38.646864"], ["updated_at", "2020-10-07 21:58:38.646864"]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-84"], ["title", "Namespaces do not have ResourceQuotas defined"], ["description", "ResourceQuotas can be applied to a Kubernetes namespace to ensure the resources contained inside the namespace do not exceed a desired quota.  Setting appropriate limits on each namespace can ensure workloads to not exhaust all available resources and cause an outage."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get resourcequotas --all-namespaces` and ensure each namespace has a ResourceQuota resource configured."], ["remediation", "\nIn each non-kube-system namespace, define a ResourceQuota that places limits on the maximum number of pods, CPU, and memory that can be used.  Ensure that every workload running in the namespace specifies a valid CPU and RAM requests and limits setting."], ["refs", "[{\"text\":\"Kubernetes Resource Quotas\",\"url\":\"https://kubernetes.io/docs/concepts/policy/resource-quotas/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.654601"], ["id", 72]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "870ac85c-d995-5c86-9a4f-f3b85491144b"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "870ac85c-d995-5c86-9a4f-f3b85491144b"], ["created_at", "2020-10-07 21:58:38.663765"], ["updated_at", "2020-10-07 21:58:38.663765"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 73]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 73], ["created_at", "2020-10-07 21:58:38.672859"], ["updated_at", "2020-10-07 21:58:38.672859"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-85"], ["title", "Namespaces do not have LimitRanges defined"], ["description", "LimitRanges can be applied to a Kubernetes namespace to ensure that all pods that fail to set a CPU and RAM requests and limits setting get an appropriate setting.  This ensures that pods are more accurately indicating to the Kubernetes scheduler how many actual resources they require, and that translates to nodes with more balanced workloads and avoids oversubscription situations that can cause outages."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get limitranges --all-namespaces` and ensure each namespace has a LimitRange resource configured."], ["remediation", "\nIn each non-kube-system namespace, define a LimitRange that places a minimum setting for CPU and RAM requests/limits on all workloads that fail to define their own setting."], ["refs", "[{\"text\":\"Kubernetes LimitRanges\",\"url\":\"https://kubernetes.io/docs/concepts/policy/limit-range/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.679169"], ["id", 73]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "ca95e423-1cd2-5349-b256-e66fcc5570b8"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "ca95e423-1cd2-5349-b256-e66fcc5570b8"], ["created_at", "2020-10-07 21:58:38.689024"], ["updated_at", "2020-10-07 21:58:38.689024"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 74]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 74], ["created_at", "2020-10-07 21:58:38.698908"], ["updated_at", "2020-10-07 21:58:38.698908"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-86"], ["title", "Malformed RBAC RoleBindings"], ["description", "A review of the ClusterRoleBindings and RoleBindings determined that there were incorrectly formed entries that are not enforcing a desired policy."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get clusterrolebinding -o yaml` and `kubectl get rolebinding --all-namespaces -o yaml` and review the output to ensure each has a `roleRef` and a `subjects` block with one or more entries each."], ["remediation", "\nReview each ClusterRoleBinding and Rolebinding for correctness and ensure that each one has valid `roleRef` and `subjects` blocks defined."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.704909"], ["id", 74]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "16aab1d2-3514-5377-b886-f9ff87be9f63"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "16aab1d2-3514-5377-b886-f9ff87be9f63"], ["created_at", "2020-10-07 21:58:38.712941"], ["updated_at", "2020-10-07 21:58:38.712941"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 75]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 75], ["created_at", "2020-10-07 21:58:38.725594"], ["updated_at", "2020-10-07 21:58:38.725594"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-87"], ["title", "Application-level encryption of secrets in etcd is not implemented"], ["description", "The Kubernetes API Server has the ability to leverage an external KMS provider for encryption and decryption of secrets stored inside etcd.  This provides additional protection in the event of unauthorized access to the disk or datastore where etcd maintains the cluster state.  It also ensures that the most sensitive data in etcd backups are not directly readable if stored in cloud storage buckets."], ["platform", "k8s"], ["impact", 2], ["validation", "\nFollow the instructions for your specific cloud provider's Kubernetes offering to verify that application level encryption of Kubernetes Secrets with KMS keys is configured."], ["remediation", "\nFollow the instructions for your specific cloud provider's Kubernetes offering to enable application level encryption of Kubernetes Secrets with KMS keys."], ["refs", "[{\"text\":\"Kubernetes KMS Provider\",\"url\":\"https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/\",\"ref\":\"link\"},{\"text\":\"GKE Application Secrets Encryption\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/encrypting-secrets\",\"ref\":\"link\"},{\"text\":\"EKS Application Secrets Encryption\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-1\",\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.730924"], ["id", 75]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "128b1a5e-3506-549b-a527-31a2527c976c"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "128b1a5e-3506-549b-a527-31a2527c976c"], ["created_at", "2020-10-07 21:58:38.738221"], ["updated_at", "2020-10-07 21:58:38.738221"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 76]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 76], ["created_at", "2020-10-07 21:58:38.748449"], ["updated_at", "2020-10-07 21:58:38.748449"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-88"], ["title", "Pod Disruption Budgets are not used for all critical deployments"], ["description", "Deployments with more than one replica require two critical elements to be able to handle a node failure or upgrade gracefully: Node anti-affinity to keep pods from being scheduled on the same node, and PodDisruptionBudgets (PDBs) which prevent the cluster from evicting pods unless enough other pods in that same deployment are healthy.  Without a PDB in place, a single node failure can temporarily evict too many pods and cause a service outage."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get pdb --all-namespaces` and ensure that a PDB exists for each `deployment` and `statefulset`."], ["remediation", "\nFor each workload, determine if it requires high availability for the overall service to function.  If so, configure the deployment to have at least two replicas, have node anti-affinity to tell the Kubernetes scheduler to place them on separate nodes, use a service in front of the deployments for a discoverable name to reach, and configure a PodDisruptionBudget (PDB) to ensure that either a certain percentage of replicas are available or a certain number are not unavailable."], ["refs", "[{\"text\":\"Kubernetes PodDisruptionBudgets\",\"url\":\"https://kubernetes.io/docs/tasks/run-application/configure-pdb/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.756921"], ["id", 76]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "cb315c62-1b51-5a5f-b447-73a4fa73e305"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "cb315c62-1b51-5a5f-b447-73a4fa73e305"], ["created_at", "2020-10-07 21:58:38.764746"], ["updated_at", "2020-10-07 21:58:38.764746"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 77]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 77], ["created_at", "2020-10-07 21:58:38.775072"], ["updated_at", "2020-10-07 21:58:38.775072"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-89"], ["title", "Container level malicious activity prevention/detection is not installed"], ["description", "In production Kubernetes clusters handling sensitive data, visibility into potentially malicious activity inside the containers is vital for maintaining positive control of the environment.  When a pod is compromised and actively being used to gain further access into other applications or data, it's important to be alerted immediately to be able to take defensive action to kill the pod, identify the vulnerability, fix the container, and redeploy as quickly as possible."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get daemonsets --all-namespaces -o wide` and ensure that each node has a healthy instance of the per-node agent running."], ["remediation", "\nConsider deploying a container security monitoring solution like Falco, Twistlock, or Aqua Security to monitor all nodes for container behavior that has high confidence of being malicious.  Configure it to alert to the primary on-call person for triage, and perform tuning to ensure it is not over-alerting with false positives."], ["refs", "[{\"text\":\"Sysdig\",\"url\":\"https://sysdig.com\",\"ref\":\"link\"},{\"text\":\"Falco\",\"url\":\"https://falco.org\",\"ref\":\"link\"},{\"text\":\"Palo Alto/Twistlock\",\"url\":\"https://twistlock.com\",\"ref\":\"link\"},{\"text\":\"Aqua Security\",\"url\":\"https://aquasecurity.com\",\"ref\":\"link\"},{\"ids\":[\"DE.CM-1\",\"DE.CM-4\",\"DE.CM-7\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.780491"], ["id", 77]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (2.9ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5f994da4-66b3-5b4b-a187-c67970bc112b"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5f994da4-66b3-5b4b-a187-c67970bc112b"], ["created_at", "2020-10-07 21:58:38.804773"], ["updated_at", "2020-10-07 21:58:38.804773"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 78]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 78], ["created_at", "2020-10-07 21:58:38.815418"], ["updated_at", "2020-10-07 21:58:38.815418"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-90"], ["title", "Automated Kubernetes resource backups are not configured"], ["description", "Backing up the contents of etcd is essential for backing up the desired state of the Kubernetes cluster, and it could be vital as part of a disaster recovery or security incident response plan to regain successful operation."], ["platform", "k8s"], ["impact", 9], ["validation", "\nManually validate that the backup location is being populated on the schedule desired with backup files clearly marked with the timestamp.  Ensure that the latest backup file is readable and contains the necessary data."], ["remediation", "\nInstall and configure the latest version of VMWare's Velero (formerly Heptio Ark) to export automated backups of all resources in etcd to a cloud storage bucket."], ["refs", "[{\"text\":\"VMWare Velero\",\"url\":\"https://github.com/vmware-tanzu/velero\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-4\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.823960"], ["id", 78]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "3bc617f8-f8c7-5073-9d3d-ebf8cb55477a"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "3bc617f8-f8c7-5073-9d3d-ebf8cb55477a"], ["created_at", "2020-10-07 21:58:38.832119"], ["updated_at", "2020-10-07 21:58:38.832119"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 79]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 79], ["created_at", "2020-10-07 21:58:38.843301"], ["updated_at", "2020-10-07 21:58:38.843301"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-91"], ["title", "Kubernetes resource backup/restore processes not exercised."], ["description", "A key step for recovering a breached cluster is having a full backup of etcd, but backups are not useful unless properly validated on a routine basis.  There are any number of misconfigurations that could result in the backup having incorrect or partial coverage, for example."], ["platform", "k8s"], ["impact", 9], ["validation", "\nEnsure the date/time of the last tested backup is within a desired timeframe (e.g. < 90 days)."], ["remediation", "\nPerform validation of the backups by testing the full restoration process on a routine basis, and configure alerts if the backup processes fail."], ["refs", "[{\"text\":\"VMWare Velero\",\"url\":\"https://github.com/vmware-tanzu/velero\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-10\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.849512"], ["id", 79]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "ed41f165-65e0-57e9-b43d-9aedd95d911a"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "ed41f165-65e0-57e9-b43d-9aedd95d911a"], ["created_at", "2020-10-07 21:58:38.860717"], ["updated_at", "2020-10-07 21:58:38.860717"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 80]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.1ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 80], ["created_at", "2020-10-07 21:58:38.882707"], ["updated_at", "2020-10-07 21:58:38.882707"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-92"], ["title", "Full operating system base images in use"], ["description", "When building container images, choosing a base image that is based on a \"full\" operating system has several downsides:\n\n* They are typically larger in size, and this increases bandwidth for pushing/pulling the image layers, storage costs, and image pull times during container startup.\n* They often contain a large number of libraries and packages that may not be used by the container application, and this can exponentially increase the effort spent tracking and patching vulnerabilities in the container.\n* They often include more administrative utilities by default such as `curl`, `wget`, and `nc` that an attacker can leverage if they get access to a running container.\n\nUsing a minimal base distribution with a small number of base packages can lead to smaller images with less vulnerabilities to patch.  Another approach is to use \"distroless\" images where the container is a \"scratch\" image with just a single compiled binary to be run."], ["platform", "k8s"], ["impact", 5], ["validation", "\nPerform a vulnerability scan of the last three minor releases of several base image types that your application could potentially use (e.g. `ubuntu` and `alpine`), and then scan the final images after your application is loaded.  Evaluate the results to find the balance between security, ease of maintenance, and application functionality."], ["remediation", "\nEnsure all container image build pipelines are configured to leverage a known set of approved base images that have minimal base packages and a track record for low vulnerability counts in the base layers.  Another approach to consider is \"Docker-Slim\" for minifying your final images based on profiling a running container and automatically stripping out unneeded components."], ["refs", "[{\"text\":\"Snyk Analysis of top base images\",\"url\":\"https://snyk.io/blog/the-top-two-most-popular-docker-base-images-each-have-over-500-vulnerabilities/\",\"ref\":\"link\"},{\"text\":\"Docker-Slim\",\"url\":\"https://github.com/docker-slim/docker-slim\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-12\",\"DE.CM-8\",\"PR.PT-3\",\"PR.IP-1\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.893347"], ["id", 80]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "cf0d95ac-b646-518d-aa8e-f216e45d7dab"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "cf0d95ac-b646-518d-aa8e-f216e45d7dab"], ["created_at", "2020-10-07 21:58:38.907402"], ["updated_at", "2020-10-07 21:58:38.907402"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 81]]
  [1m[36mTag Load (1.8ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (3.9ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.1ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 81], ["created_at", "2020-10-07 21:58:38.924662"], ["updated_at", "2020-10-07 21:58:38.924662"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.0ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-93"], ["title", "Large Number of Cluster Admins"], ["description", "The number of groups and/or users that have the RBAC permission \"cluster-admin\" should be limited to a small number of total users.  When the majority of users in a cluster are operating as administrators, it defeats the purpose for separation of duties, increases the chances for an error to cause an outage, and it violates the principle of least privilege."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get clusterrolebinding -o json | jq -r '.items[] | select((.roleRef.name==\"cluster-admin\") and .roleRef.kind==\"ClusterRole\") | .subjects[] | \"(.kind) (.namespace) (.name)\"'` and evaluate the listing to ensure it contains only the required cluster administrators."], ["remediation", "\nReduce the number of users with \"cluster-admin\" privileges to the smallest number feasible while still maintaining operational safety.  This is typically 3-6 users.  To ease administration, create groups and bind the permissions to the group."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\",\"PR.AT-2\",\"PR.IP-1\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.936953"], ["id", 81]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "6728d76f-de9a-50a2-bbee-33f4da917054"], ["LIMIT", 1]]
  [1m[35m (1.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "6728d76f-de9a-50a2-bbee-33f4da917054"], ["created_at", "2020-10-07 21:58:38.946600"], ["updated_at", "2020-10-07 21:58:38.946600"]]
  [1m[35m (2.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.7ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 82]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 82], ["created_at", "2020-10-07 21:58:38.968126"], ["updated_at", "2020-10-07 21:58:38.968126"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.3ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-94"], ["title", "Ensure the Kubernetes Dashboard is not present"], ["description", "While the Kubernetes dashboard is not inherently insecure on its own, it is often coupled with a misconfiguration of RBAC permissions that can unintentionally overgrant access and is not commonly protected with `NetworkPolicies` preventing all pods from being able to reach it.  In increasingly rare circumstances, the Kubernetes dashboard is exposed publicly to the Internet."], ["platform", "k8s"], ["impact", 3], ["validation", "\nRunning `kubectl get pods --all-namespaces -l k8s-app=kubernetes-dashboard` should not return any pods."], ["remediation", "\nInstead of running a workload inside the cluster to display a UI, leverage the cloud provider's UI for listing/managing workloads or consider a tool such as Octant running on local systems.  Run `kubectl get pods --all-namespaces -l k8s-app=kubernetes-dashboard` to find pods part of deployments and use kubectl to delete those deployments."], ["refs", "[{\"text\":\"Kubernetes Dashboard\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:38.979704"], ["id", 82]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "b80127b9-8df6-5689-9449-18249a4e7c1f"], ["LIMIT", 1]]
  [1m[35m (1.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "b80127b9-8df6-5689-9449-18249a4e7c1f"], ["created_at", "2020-10-07 21:58:38.999940"], ["updated_at", "2020-10-07 21:58:38.999940"]]
  [1m[35m (1.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (2.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 83]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 83], ["created_at", "2020-10-07 21:58:39.027090"], ["updated_at", "2020-10-07 21:58:39.027090"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-95"], ["title", "Unsupported Kubernetes Versions in use"], ["description", "The Kubernetes project is fast-moving and has historically released a minor version 3-4 times per year, and it maintains release branches for the three most recent minor releases (e.g. 1.18, 1.17, 1.16).  This means that the \"upstream\" Kubernetes project maintains security and bug fixes for a given minor release for about nine months.  When running on managed Kubernetes offerings like AKS, EKS, and GKE, the support policy is slightly different as there is a delay in validating and testing new minor releases before making them available to customers.  While it might be technically possible to be running an unsupported version, it means an upgrade is necessary to be able to get security and bug fixes, and managed providers may not be able to automatically patch your cluster on your behalf."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl version --short | grep \"^Server\"` to identify the version of the control plane."], ["remediation", "\nMaintain awareness of the latest releases relative to the current running versions.  Perform upgrade testing in a development/sandbox environment first to avoid API deprecation issues.  If using a cloud provider's managed offering, consider enabling automatic upgrades in development/sandbox environments to ease administration burden and to identify issues early.  Practice and perform upgrades routinely to ensure the process does not go stale by administrators and application owners."], ["refs", "[{\"text\":\"Kubernetes Version Support\",\"url\":\"https://kubernetes.io/docs/setup/release/version-skew-policy/\",\"ref\":\"link\"},{\"text\":\"GKE Versions\",\"url\":\"https://cloud.google.com/kubernetes-engine/versioning-and-upgrades\",\"ref\":\"link\"},{\"text\":\"EKS Versions\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/kubernetes-versions.html\",\"ref\":\"link\"},{\"text\":\"AKS Versions\",\"url\":\"https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.RA-1\",\"ID.SC-2\",\"PR.IP-1\",\"PR.MA-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.034624"], ["id", 83]]
  [1m[35m (2.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (2.0ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "a40a1f40-0597-5ea5-b72e-005fbeea3ac6"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "a40a1f40-0597-5ea5-b72e-005fbeea3ac6"], ["created_at", "2020-10-07 21:58:39.055120"], ["updated_at", "2020-10-07 21:58:39.055120"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 84]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.1ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 84], ["created_at", "2020-10-07 21:58:39.069588"], ["updated_at", "2020-10-07 21:58:39.069588"]]
  [1m[35m (1.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-96"], ["title", "Third party images should be validated for policy conformance before use"], ["description", "Container images that are not part of the default Kubernetes system components and are not owned or maintained by the organization are considered third-party images.  These images are often introduced via Helm Charts or Operators, and they should be evaluated with the same scrutiny as any base image with regards to packages, vulnerabilities, running as a non-root user, and more."], ["platform", "k8s"], ["impact", 5], ["validation", "\nIdentify images from third-party registries in use, perform vulnerability scans regularly, and validate that they follow your organization's security standards."], ["remediation", "\nIdentify container images that are not controlled by the organization and determine if their posture meets your organization's security baseline.  If they do not and the original Dockerfile and supporting assets are available in public source control, consider maintaining a \"fork\" of that image with the security modifications necessary.  Alternatively, consider submitting patches upstream to that project so that they can be automatically incorporated going forward.  Focus on containers that run as \"root\" and may need privileged access to the host first."], ["refs", "[{\"text\":\"Snyk Analysis of top base images\",\"url\":\"https://snyk.io/blog/the-top-two-most-popular-docker-base-images-each-have-over-500-vulnerabilities/\",\"ref\":\"link\"},{\"text\":\"Docker-Slim\",\"url\":\"https://github.com/docker-slim/docker-slim\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-12\",\"DE.CM-8\",\"PR.PT-3\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.088129"], ["id", 84]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "efb02cbe-f686-5e6c-b9bc-aa1fa5fee143"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "efb02cbe-f686-5e6c-b9bc-aa1fa5fee143"], ["created_at", "2020-10-07 21:58:39.101515"], ["updated_at", "2020-10-07 21:58:39.101515"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 85]]
  [1m[36mTag Load (1.0ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.6ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 85], ["created_at", "2020-10-07 21:58:39.121419"], ["updated_at", "2020-10-07 21:58:39.121419"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-97"], ["title", "Namespaces should be used to separate unrelated workloads"], ["description", "By default, user-managed resources will be placed in the `default` namespace.  This makes it difficult to properly define policies for RBAC permissions, service account usage, network policies, and more.  Creating dedicated namespaces and running workloads and supporting resources in each helps support proper API server permissions separation and network microsegmentation."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get all` in the `default`, `kube-public`, and if present, `kube-node-lease` namespaces.  There should only be the `kubernetes` service."], ["remediation", "\nCreate dedicated namespaces for each type of related workload, and migrate those resources into those namespaces.  Ensure that RBAC permissions are not granted at the cluster scope but per namespace for the application owners at each namespace level."], ["refs", "[{\"text\":\"Kubernetes Namespaces\",\"url\":\"https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.AC-5\",\"PR.IP-1\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.133203"], ["id", 85]]
  [1m[35m (2.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c89183b3-b5c8-57ef-af97-1d9df089335b"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.9ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c89183b3-b5c8-57ef-af97-1d9df089335b"], ["created_at", "2020-10-07 21:58:39.147197"], ["updated_at", "2020-10-07 21:58:39.147197"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 86]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.1ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 86], ["created_at", "2020-10-07 21:58:39.165106"], ["updated_at", "2020-10-07 21:58:39.165106"]]
  [1m[35m (2.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "k8s-logging"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 2], ["control_id", 86], ["created_at", "2020-10-07 21:58:39.192599"], ["updated_at", "2020-10-07 21:58:39.192599"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (2.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-98"], ["title", "Workloads do not have dedicated Kubernetes Service Accounts"], ["description", "By default, pods that do not specify a service account have the \"default\" service account token for that namespace automatically mounted inside them.  This, by definition, becomes a shared credential that multiple workloads will use.  Similarly, workloads that do specify the same, non-default service account are also sharing credentials.  Multiple workloads sharing a service account credential makes it difficult to properly apply RBAC permissions following least privilege and also more difficult to identify which pod/deployment was responsible for an API call when reviewing audit logs during an incident."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods -o json -A | jq -r '.items[] | select(.spec.serviceAccountName!=null) | \"(.metadata.namespace)/(.metadata.name): (.spec.serviceAccountName)\"'` to help identify which pods are mapping service accounts and to see if any are shared across workloads.  For all workload namespaces, consider disabling the automounting of the \"default\" service account.  Finally, enforce the use of non-default service accounts via dynamic admission control (e.g. OPA/Gatekeeper)."], ["remediation", "\nEnsure all deployments, daemonsets, and statefulsets are only mounting a service account if necessary and ensure it is unique to that workload.  Typically, naming the deployment and the service account with the same prefix helps this process.  Also, consider configuring the namespace to prevent the default service account from being mounted."], ["refs", "[{\"text\":\"Default Mounting of Service Accounts\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-4\",\"PR.AC-6\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.203023"], ["id", 86]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "26577009-7e3b-5ba7-9c94-e9b8cb293075"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "26577009-7e3b-5ba7-9c94-e9b8cb293075"], ["created_at", "2020-10-07 21:58:39.224312"], ["updated_at", "2020-10-07 21:58:39.224312"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 87]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 87], ["created_at", "2020-10-07 21:58:39.257242"], ["updated_at", "2020-10-07 21:58:39.257242"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.2ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-99"], ["title", "Nodepools are not used to separate workloads of different resource profiles"], ["description", "While Kubernetes can manage workloads of different resource profiles on the same physical compute and network capacity, situations can occur where workloads can become \"noisy neighbors\" and compete for the same resources with other Pods on the same node.  Pods that run resource-intensive data processing jobs but are otherwise dormant are a good example.  Specifying inaccurate resource requests and limits can further exacerbate this issue as the scheduler may overcrowd the node."], ["platform", "k8s"], ["impact", 5], ["validation", "\nReview the resource usage of each type of workload and ensure workloads with \"bursty\" resource usage are placed on dedicated nodes.  `kubectl top nodes` and `kubectl top pods` can be helpful for point-in-time usage statistics, but observing workloads over 24-48 hrs is ideal."], ["remediation", "\nWorkloads that have variable resource needs should be physically separated from workloads with steady resource needs in terms of compute and network capacity.  The most common approach is to place a `taint` on a dedicated node pool/group and specify that `toleration` and node selector on the workloads that should only operate on that node pool.  In addition, ensure all workloads have accurate resource requests and limits assigned and that node pools/groups are configured to autoscale up to the total capacity plus 10-20% of headroom of the workloads configured to run on them."], ["refs", "[{\"text\":\"Node Selectors\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\",\"ref\":\"link\"},{\"text\":\"Taints and Tolerations\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.266956"], ["id", 87]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "39a35933-b735-52f6-952d-f3903ce75ef6"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "39a35933-b735-52f6-952d-f3903ce75ef6"], ["created_at", "2020-10-07 21:58:39.280689"], ["updated_at", "2020-10-07 21:58:39.280689"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 88]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 88], ["created_at", "2020-10-07 21:58:39.296121"], ["updated_at", "2020-10-07 21:58:39.296121"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.1ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-100"], ["title", "Secrets in Pod Environment Variables"], ["description", "Kubernetes pods can take statically defined environment variables, and those can often contain sensitive data like API keys and other credentials.  However, this exposes them to users and other workloads that interact with the API server who have the RBAC permission \"get pods\" in the cluster which is commonly a much wider audience than desired."], ["platform", "k8s"], ["impact", 7], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | select(.spec.containers[].env) | \"(.metadata.namespace)/(.metadata.name): (.spec.containers[].env[].value)\"'` and verify that no sensitive data is present."], ["remediation", "\nEnsure that no secret material is directly defined in Pod environment variable specifications.  Instead, store them in a Secret and use the secretKeyRef mechanism to reference them as Environment variables in the container at runtime."], ["refs", "[{\"text\":\"Kubernetes ENV Variables from Secret\",\"url\":\"https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#define-a-container-environment-variable-with-data-from-a-single-secret\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.304110"], ["id", 88]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d0031c18-5bd3-5fa2-9533-07a464e0aa6f"], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d0031c18-5bd3-5fa2-9533-07a464e0aa6f"], ["created_at", "2020-10-07 21:58:39.320424"], ["updated_at", "2020-10-07 21:58:39.320424"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 89]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 89], ["created_at", "2020-10-07 21:58:39.337678"], ["updated_at", "2020-10-07 21:58:39.337678"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-101"], ["title", "RBAC Roles/ClusterRoles use Wildcards"], ["description", "When defining `Roles` and `ClusterRoles` in Kubernetes RBAC, it's possible to specify a wildcard using a `*` for both verbs and resources to simplify the policy creation process.  However, the Kubernetes API can change in subtle ways over time, and new resources and/or verbs may be introduced.  If a policy expresses \"all resources\" using a `*` and a new version of Kubernetes exposes a sensitive new resource, it may now match.  The intent of the previous policy will have been altered and potentially to an undesired effect."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get roles --all-namespaces -o json | jq -r '.items[] | . as $role | .rules[] | select(((.resources!=null) and (.resources[] | contains(\"*\")) or ((.nonResourceURLs!=null) and (.nonResourceURLs[] | contains(\"*\")))) or select(.verbs[] | contains(\"*\"))) | $role.metadata.name' | sort -u` to identify all `Roles` that specify a `*` for either resources or verbs.  Run `kubectl get clusterroles -o json | jq -r '.items[] | . as $role | .rules[] | select(((.resources!=null) and (.resources[] | contains(\"*\")) or ((.nonResourceURLs!=null) and (.nonResourceURLs[] | contains(\"*\")))) or select(.verbs[] | contains(\"*\"))) | $role.metadata.name' | sort -u` for ClusterRoles."], ["remediation", "\nReview all `ClusterRoles` and `Roles` and ensure that all resources and verbs do not use the `*` declaration.  If they do, modify that policy to decleare the explicity resources and verbs instead."], ["refs", "[{\"text\":\"Kubernetes RBAC\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.343227"], ["id", 89]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0fb4069a-689c-53e1-a159-95c40cb065e8"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0fb4069a-689c-53e1-a159-95c40cb065e8"], ["created_at", "2020-10-07 21:58:39.350212"], ["updated_at", "2020-10-07 21:58:39.350212"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 90]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 90], ["created_at", "2020-10-07 21:58:39.363852"], ["updated_at", "2020-10-07 21:58:39.363852"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-102"], ["title", "Pods are in an undesired state"], ["description", "Pods were identified with a current status that indicates a failure condition or an incorrect deployment configuration, and they should be corrected or removed."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get pods --all-namespaces -o json | jq -r '.items[] | select((.status.phase==\"Failed\") or select(.status.containerStatuses[].restartCount > 4)) | \"(.metadata.namespace)/(.metadata.name) -- Status: (.status.phase), High Restart Count: (.status.containerStatuses[].restartCount > 4)\"'` in each cluster to identify pods in an undesired state.  There should be none listed."], ["remediation", "\nFor each workload, identify the underlying cause of the failure condition.  It may need a correction to the container image, a pod specification adjustment, or the presence of a dependent resource such as a ConfigMap, a Secret, or a Persistent Volume.  Typically, the container logs (`kubectl logs`) and pod events (`kubectl describe pod) will provide the information needed to address the issue."], ["refs", "[{\"text\":\"Kubernetes Application Debugging\",\"url\":\"https://kubernetes.io/docs/tasks/debug-application-cluster/debug-application-introspection/\",\"ref\":\"link\"},{\"text\":\"Kubernets Pod Lifecycle\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-5\",\"PR.PT-5\",\"DE.CM-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.369865"], ["id", 90]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "29b51317-7143-5795-817b-e36d1da89363"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "29b51317-7143-5795-817b-e36d1da89363"], ["created_at", "2020-10-07 21:58:39.377791"], ["updated_at", "2020-10-07 21:58:39.377791"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 91]]
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 91], ["created_at", "2020-10-07 21:58:39.395325"], ["updated_at", "2020-10-07 21:58:39.395325"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-103"], ["title", "Replicasets that are not part of Deployments in use"], ["description", "In all but the most custom use cases, ReplicaSets should only be used indirectly via a Deployment that manages it.  \"Bare\" ReplicaSets should be considered for migration to a full Deployment resource to take advantage of useful management features such as rolling update strategies, rollbacks, and garbage collection."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get rs --all-namespaces -o json | jq -r '.items[] | . as $rs | .metadata | select((.ownerReferences==null) or .ownerReferences[].kind!=\"Deployment\") | \"($rs.metadata.namespace)/($rs.metadata.name)\"'` and ensure there are no items listed."], ["remediation", "\nConsider redeploying the ReplicaSet as a Deployment resource."], ["refs", "[{\"text\":\"Kubernetes ReplicaSets\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Deployments\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.401574"], ["id", 91]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7b7f2133-9328-5767-8b43-3d5ac80c9192"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7b7f2133-9328-5767-8b43-3d5ac80c9192"], ["created_at", "2020-10-07 21:58:39.409783"], ["updated_at", "2020-10-07 21:58:39.409783"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 92]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.2ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 92], ["created_at", "2020-10-07 21:58:39.420323"], ["updated_at", "2020-10-07 21:58:39.420323"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-105"], ["title", "Deployments should have more than one desired replica"], ["description", "Deployments with only a single desired replica cannot maintain service during upgrades or node failures as there will always be a delay for the system to notice the pod is no longer running and when it can be scheduled on another node.  In conjunction with having a PodDisruptionBudget configured, having multiple replicas allows for continued availability of the workload during scheduled or unscheduled outages."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | select(.status.replicas==1) | \"(.metadata.namespace)/(.metadata.name)\"'` and ensure that all deployments listed can be unavailable for up to 10 minutes without harming the successful operation of the cluster or dependent workloads."], ["remediation", "\nConfigure the Deployment replica count to be 2 or greater, and ensure a PodDisruptionBudget is configured for that deployment that enforces an appropriate `minAvailable` constraint."], ["refs", "[{\"text\":\"Kubernetes PodDisruptionBudgets\",\"url\":\"https://kubernetes.io/docs/tasks/run-application/configure-pdb/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.432366"], ["id", 92]]
  [1m[35m (1.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.6ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "99976c03-eeca-5bba-90d4-fadeaa87c106"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "99976c03-eeca-5bba-90d4-fadeaa87c106"], ["created_at", "2020-10-07 21:58:39.447977"], ["updated_at", "2020-10-07 21:58:39.447977"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 93]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 93], ["created_at", "2020-10-07 21:58:39.464380"], ["updated_at", "2020-10-07 21:58:39.464380"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-106"], ["title", "Pods have a large TermintionGracePeriodSeconds set"], ["description", "When a Pod is told to exit, Kubernetes will wait `terminationGracePeriodSeconds` before sending a SIGKILL signal to the container process.  The default is 30 seconds, but it can and should be increased if the Pod requires extra time to finish processing work cleanly or to execute a PreStop Hook.  However, if the timeout is extended too far, this can cause long delays during node upgrades and rolling deployments."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods --all-namespaces -o json | jq -r '.items[] | select(.spec.terminationGracePeriodSeconds>299) | \"(.metadata.namespace)/(.metadata.name): (.spec.terminationGracePeriodSeconds)\"'` and consider the possibilities for reducing that timeout safely."], ["remediation", "\nIdentify workloads that have `terminationGracePeriodSeconds` set to 5 or more minutes and validate that they need that time.  If possible, engineer the workload to handle termination more quickly while still maintaining overall application state."], ["refs", "[{\"text\":\"Termination of Kubernetes Pods\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.472057"], ["id", 93]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "88560633-a807-54c7-ad3a-4719d665468f"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "88560633-a807-54c7-ad3a-4719d665468f"], ["created_at", "2020-10-07 21:58:39.480096"], ["updated_at", "2020-10-07 21:58:39.480096"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 94]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 94], ["created_at", "2020-10-07 21:58:39.491898"], ["updated_at", "2020-10-07 21:58:39.491898"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-107"], ["title", "Critical Workloads do not have Anti-Affinity Rules set"], ["description", "Deployments and Statefulsets that require a certain number of Pods running at all times to maintain service availability should be configured with anti-affinity rules to avoid situations where multiple replicas are scheduled on the same node or in a common failure zone.  Should that node or failure zone experience an outage, an unexpected service disruption could result."], ["platform", "k8s"], ["impact", 8], ["validation", "\nRun `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | select(.spec.template.spec.affinity==null) | \"(.metadata.namespace)/(.metadata.name)\"'` and determine if affinity or anti-affinity rules are necessary to help avoid suboptimal scheduling.  Run `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | select(.spec.template.spec.affinity==null) | \"(.metadata.namespace)/(.metadata.name)\"'` for statefulsets."], ["remediation", "\nReview all Deployments and Statefulsets for criticality and determine if additional guidance should be given to the scheduler in the form of affinity and/or anti-affinity rules.  Most commonly, this is either a \"hard\" or \"soft\" requirement to ensure only one Pod of a Deployment lands on the same node."], ["refs", "[{\"text\":\"Assigning Pods to Nodes\",\"url\":\"https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.497351"], ["id", 94]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "2079b140-b95a-5c1a-b1df-a273809e5047"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "2079b140-b95a-5c1a-b1df-a273809e5047"], ["created_at", "2020-10-07 21:58:39.504411"], ["updated_at", "2020-10-07 21:58:39.504411"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 95]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (1.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 95], ["created_at", "2020-10-07 21:58:39.516505"], ["updated_at", "2020-10-07 21:58:39.516505"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-108"], ["title", "Deployments/Statefulsets do not have minimum desired healthy"], ["description", "In a healthy cluster, all running pods should be active, and all Deployments and Statefulsets should have the desired number of active pods.  There are any number of reasons why the number of active replicas in a Deployment or Statefulset is not equal to the desired number, but the result is typically that the services being provided by the workload are degraded or even completely unavailable."], ["platform", "k8s"], ["impact", 8], ["validation", "\nRun `kubectl get deployments --all-namespaces -o json | jq -r '.items[] | . as $wkl | .status.conditions[] | select((.type==\"Available\") and .status!=\"True\") | \"($wkl.metadata.namespace)/($wkl.metadata.name): (.message)\"'` to identify unhealthy workloads and investigate with `kubectl describe pod <podname>` how to alleviate the underlying issue. Run `kubectl get statefulsets --all-namespaces -o json | jq -r '.items[] | . as $wkl | .status.conditions[] | select((.type==\"Available\") and .status!=\"True\") | \"($wkl.metadata.namespace)/($wkl.metadata.name): (.message)\"'` for statefulsets."], ["remediation", "\nThe most common cause of this issue is due to insufficient cluster capacity to be able to successfully run the pod(s).  They will typically appear in the \"Pending\" state, and running `kubectl describe pod` will reveal the reason why the pod can't be scheduled.  That root cause should be addressed to allow the workload to continue operating normally.  For example, if a pod is \"Pending\" because there aren't enough CPU resources to satisfy the pods \"CPU request\", the cluster either needs additional nodes or larger nodes with greater CPU capacity."], ["refs", "[{\"text\":\"Kubernetes Deployments\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.525557"], ["id", 95]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f89d387b-a421-53a4-b5ea-142f243a4935"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f89d387b-a421-53a4-b5ea-142f243a4935"], ["created_at", "2020-10-07 21:58:39.532677"], ["updated_at", "2020-10-07 21:58:39.532677"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 96]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 96], ["created_at", "2020-10-07 21:58:39.542745"], ["updated_at", "2020-10-07 21:58:39.542745"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-109"], ["title", "Services have fewer than two healthy Endpoints"], ["description", "Cluster services that refer to pods via label selectors and port mappings will results in having `endpoint` resources created.  A healthy `service` should have at least 2 valid endpoints at all times which indicates that multiple pods are alive and actively handling requests.  Having \"none\" is an indication of misconfiguraion or outage, and having just one endpoint indicates a potential for service disruption during upgrades or node failures."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `for ns in $(kubectl get ns -o custom-columns=NAME:.metadata.name); do for svc in $(kubectl get -n $ns svc -o custom-columns=NAME:.metadata.name --no-headers); do EP=\"$(kubectl get endpoints -n $ns $svc -o json 2> /dev/null)\";if [[ \"$?\" -ne 0 ]]; then echo \"$ns/$svc has 0 endpoints\"; else echo \"$EP\" | jq -r 'select((.subsets[].addresses | length) < 2) | \"(.metadata.namespace)/(.metadata.name) has fewer than 2 endpoints\"'; fi; done; done` to identify services with fewer than 2 healthy endpoints."], ["remediation", "\nReview all services in all namespaces for having at least two valid endpoints and address the misconfiguration or number of replicas as needed to ensure the correct number are active."], ["refs", "[{\"text\":\"Debugging Services\",\"url\":\"https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/#does-the-service-have-any-endpoints\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.547916"], ["id", 96]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c5d0ad1c-feaf-5997-9fdf-c5af4dcc7543"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c5d0ad1c-feaf-5997-9fdf-c5af4dcc7543"], ["created_at", "2020-10-07 21:58:39.572117"], ["updated_at", "2020-10-07 21:58:39.572117"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 97]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 97], ["created_at", "2020-10-07 21:58:39.584051"], ["updated_at", "2020-10-07 21:58:39.584051"]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-110"], ["title", "Pods in the kube-system namespace should be configured to avoid eviction"], ["description", "Pods in the `kube-system` namespace should be assigned the \"system-cluster-critical\" or \"system-node-critical\" `priorityClassName` to designate that the cluster should evict other pods not critical to the cluster or node's operation first.  When a worker node runs out of resources, it evicts the lowest priority pods that would remedy the resource exhaustion first.  Setting a `priority` at or above 2 billion (2000000000) indicates that a specific workload is critical to the functionality of the cluster."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods -n kube-system -o json | jq -r '.items[] | select(.spec.priority < 2000000000) | \"(.metadata.namespace)/(.metadata.name): (.spec.priority)\"'` and ensure no items are listed."], ["remediation", "\nReview the specifications for the pods in the `kube-system` namespace and ensure it specifies a `priorityClassName` that has a numeric priority value above 2 billion."], ["refs", "[{\"text\":\"Pod Quality of Service\",\"url\":\"https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/\",\"ref\":\"link\"},{\"text\":\"Out of Resource Handling\",\"url\":\"https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/\",\"ref\":\"link\"},{\"text\":\"Guaranteed Scheduling for Critical Pods\",\"url\":\"https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.595218"], ["id", 97]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "b259e239-3547-5930-9d17-b1dc60f3a2ec"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "b259e239-3547-5930-9d17-b1dc60f3a2ec"], ["created_at", "2020-10-07 21:58:39.603051"], ["updated_at", "2020-10-07 21:58:39.603051"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 98]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 98], ["created_at", "2020-10-07 21:58:39.613225"], ["updated_at", "2020-10-07 21:58:39.613225"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-111"], ["title", "Services specifications do not have the correct naming convention set"], ["description", "For the sake of clarity and current/future support for Istio service mesh, all port names in `service` definitions need to follow a convention to aid in proper protocol identification.  For example, a service exposes TCP port 443, but it's not clear to the service mesh if that is passing plain TCP, HTTP, HTTPS, TLS, or gRPC traffic.  Naming the port `tls` or `tls-foo` makes it clear what protocol is intended to pass through this service."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get svc -A -o json | jq -r '.items[] | . as $svc | .spec.ports[] | select(.name | test(\"^grpc|^http|^mongo|^mysql|^redis|^tcp|^tls|^udp\")|not) | \"($svc.metadata.namespace)/($svc.metadata.name): (.name)\"'` and ensure no items are listed."], ["remediation", "\nReview all the ports exposed by services and ensure they follow the <protocol>[-<suffix>] naming convention."], ["refs", "[{\"text\":\"Istio Service Naming Convention\",\"url\":\"https://istio.io/docs/reference/config/analysis/ist0118/\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.619185"], ["id", 98]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "af258b39-ba3c-56cf-ab22-fc0f082f9fb0"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "af258b39-ba3c-56cf-ab22-fc0f082f9fb0"], ["created_at", "2020-10-07 21:58:39.629019"], ["updated_at", "2020-10-07 21:58:39.629019"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 99]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 99], ["created_at", "2020-10-07 21:58:39.638805"], ["updated_at", "2020-10-07 21:58:39.638805"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-112"], ["title", "Containers should have ImagePullPolicy set to Always"], ["description", "Pod specifications should explicitly set the `imagePullPolicy` to `Always` to ensure the correct version of the image is always being used.  This helps avoid issues where container image tags were overwritten in the container registry but the node uses its local cached version instead.  Note that the caching semantics of the underlying image provider make even imagePullPolicy: Always efficient. With Docker, for example, if the image already exists, the pull attempt is fast because all image layers are cached and no image download is needed."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods -A -o json | jq -r '.items[] | . as $pod | .spec.containers[] | select(.imagePullPolicy!=\"Always\") | \"($pod.metadata.namespace)/($pod.metadata.name): (.name) (.imagePullPolicy)\"'` and ensure no items are listed."], ["remediation", "\nReview all containers in pod specifications and ensure the `imagePullPolicy` setting is configured to be `Always`."], ["refs", "[{\"text\":\"Kubernetes Best Practices\",\"url\":\"https://kubernetes.io/docs/concepts/configuration/overview/#container-images\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-5\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.644713"], ["id", 99]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f46f6fd4-1a4b-562d-934b-3ef8b9f07075"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.6ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f46f6fd4-1a4b-562d-934b-3ef8b9f07075"], ["created_at", "2020-10-07 21:58:39.652026"], ["updated_at", "2020-10-07 21:58:39.652026"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 100]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.3ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 100], ["created_at", "2020-10-07 21:58:39.664842"], ["updated_at", "2020-10-07 21:58:39.664842"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-113"], ["title", "Containers should have no sensitive information in Command or Args specifications"], ["description", "Kubernetes pods can specify the `command` and `args` for a container to use at runtime, and those can often contain sensitive data like API keys and other credentials.  However, this exposes them to users and other workloads that interact with the API server who have the RBAC permission \"get pods\" in the cluster which is commonly a much wider audience than desired."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pods --all-namespaces -ojson | jq -r '.items[] | . as $pod | .spec.containers[] | select((.command) or .args) | .command as $cmd | .args as $args | \"($pod.metadata.namespace)/($pod.metadata.name)[(.name)]: ($cmd) ($args)\"'` and review the output.  Ensure no secret material is present."], ["remediation", "\nEnsure that no secret material is directly defined in container `command` or `args` specifications.  Instead, store them in a Secret and use the secretKeyRef mechanism to reference them as files in the container at runtime."], ["refs", "[{\"text\":\"Kubernetes Container Command and Arguments\",\"url\":\"https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.670092"], ["id", 100]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d5adf736-690c-53dd-af10-67bc040f2db4"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d5adf736-690c-53dd-af10-67bc040f2db4"], ["created_at", "2020-10-07 21:58:39.677352"], ["updated_at", "2020-10-07 21:58:39.677352"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.9ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 101]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 101], ["created_at", "2020-10-07 21:58:39.693186"], ["updated_at", "2020-10-07 21:58:39.693186"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-114"], ["title", "All resources should have a standard set of labels for ownership and purpose"], ["description", "Kubernetes resources have a standard labeling mechanism that can take arbitrary key/value pairs, and this makes tagging resources with labels for ownership, environment, data sensitivity, and more straightforward.  In addition to being able to quickly understand the intent of a workload or resource, labels can be used in the definition of security policies.  As cluster resources grow, having a standard convention for labeling resources helps keep track of things and maintain flexible policies."], ["platform", "k8s"], ["impact", 3], ["validation", "\nRun `kubectl get all -A -o json | jq -r '.items[] | \"(.kind)/(.metadata.namespace)/(.metadata.name) (.metadata.labels | tostring)\"'` and ensure all resources contain the desired labels."], ["remediation", "\nEnsure that all resources created and updated contain appropriate values for a small number of labels that make sense for the organization.  Suggested labels are `owner`, `env`, `app`, and `data` for the team responsbile, the dev/stage/prod type, the name of the application, and the sensitivity of the data in the workload, respectively.  Enforcement can be done with OPA/Gatekeeper admission control."], ["refs", "[{\"text\":\"Kubernetes Labels\",\"url\":\"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper Sample Policy\",\"url\":\"https://github.com/open-policy-agent/gatekeeper/tree/master/library/general/requiredlabels\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-2\",\"ID.AM-5\",\"PR.IP-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.700413"], ["id", 101]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "8ed3cd97-4415-5024-9d9a-dab55cd0fe53"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "8ed3cd97-4415-5024-9d9a-dab55cd0fe53"], ["created_at", "2020-10-07 21:58:39.709551"], ["updated_at", "2020-10-07 21:58:39.709551"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 102]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.7ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 102], ["created_at", "2020-10-07 21:58:39.718735"], ["updated_at", "2020-10-07 21:58:39.718735"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.4ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-115"], ["title", "Nodeport Services directly exposed"], ["description", "While Kubernetes supports exposing pods via a port on the underlying node from the TCP/30000-32768 range via the `NodePort` service type, it's not typically the desired approach.  Typically, clusters expose a shared set of load balancers and ingress controllers to handle external service exposure via standard APIs that handle path routing, logging, access control lists, and more.  `NodePort` services require opening uncommon TCP ports in the firewall and typicaly require tight coupling of worker node IPs to be used successfully, and that becomes problematic when nodes fail or when a scale event occurs."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get svc -A -o json | jq -r '.items[] | select(.spec.type==\"NodePort\") | \"(.metadata.namespace)/(.metadata.name): (.spec.type):(.spec.ports[].nodePort)\"'` and ensure that no items are listed."], ["remediation", "\nConvert `NodePort` services into type `LoadBalancer` or consider leveraging an ingress controller to expose the service on a specific hostname and port instead."], ["refs", "[{\"text\":\"NodePort Services\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/service/#nodeport\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-5\",\"PR.DS-5\",\"PR.PT-4\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.727391"], ["id", 102]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "90ce3f57-138b-566e-a61e-77c95a9a243b"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "90ce3f57-138b-566e-a61e-77c95a9a243b"], ["created_at", "2020-10-07 21:58:39.734103"], ["updated_at", "2020-10-07 21:58:39.734103"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 103]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 103], ["created_at", "2020-10-07 21:58:39.742827"], ["updated_at", "2020-10-07 21:58:39.742827"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-116"], ["title", "Services should have ExternalTrafficPolicy set to Local to preserve source IP address"], ["description", "In certain cloud providers, service specifications can be set to the default of 'Cluster' or 'Local'.  Cluster obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading. Local preserves the client source IP and avoids a second hop for `LoadBalancer` and `NodePort` type services, but risks potentially imbalanced traffic spreading.  Preserving the client source IP is critical to being able to perform attribution if an attacker is probing or exploiting an exposed service."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get svc -A -o json | jq -r '.items[] | select(.spec.type!=\"ClusterIP\") | \"(.metadata.namespace)/(.metadata.name): (.spec.externalTrafficPolicy)\"'` and validate that no items are listed."], ["remediation", "\nIn GCP/GKE, ensure IP Aliasing is enabled on the subnet where the cluster is created and the cluster is configured to utilize those ranges.  In AWS, using the \"Network Load Balancer\" instead of the \"Elastic Load Balancer\" in combination with this setting, the source IP can be preserved."], ["refs", "[{\"text\":\"Preserving the Source IP\",\"url\":\"https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip\",\"ref\":\"link\"},{\"ids\":[\"ID.AM-3\",\"PR.AC-3\",\"PR.AC-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.755073"], ["id", 103]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "95220b3a-127b-5240-aece-35c61d8bc3f9"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.5ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "95220b3a-127b-5240-aece-35c61d8bc3f9"], ["created_at", "2020-10-07 21:58:39.773924"], ["updated_at", "2020-10-07 21:58:39.773924"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 104]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 104], ["created_at", "2020-10-07 21:58:39.783618"], ["updated_at", "2020-10-07 21:58:39.783618"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-117"], ["title", "Ingresses should point to active services with multiple healthy endpoints"], ["description", "Ingress resources describe how to route traffic based on hostname and/or URI path to a desired service, and it's very easy to misconfigure an ingress configuration to point to an invalid service or an \"empty\" service."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `for entry in \"$( kubectl get ingress -A -o json | jq -r '.items[] | . as $svc | .spec | .. | .backend? | select(.!=null) | \"($svc.metadata.namespace) (.serviceName)\"')\"; do ns=\"$(echo $entry | awk '{print $1}')\"; svc=\"$(echo $entry | awk '{print $2}')\"; EP=\"$(kubectl get endpoints -n $ns $svc -o json 2> /dev/null)\"; if [[ \"$?\" -ne 0 ]]; then echo \"$ns/$svc has 0 endpoints\"; else echo \"$EP\" | jq -r 'select(.subsets) // \"(.metadata.namespace)/(.metadata.name) has fewer than 2 endpoints\"'; echo \"$EP\" | jq -r 'select(.subsets) | select((.subsets[].addresses | length) < 2) | \"(.metadata.namespace)/(.metadata.name) has fewer than 2 endpoints\"'; fi; done` and ensure that no services are listed."], ["remediation", "\nReview all ingress resource configurations, and ensure the `backend` configurations that point to a `service` are pointing to a service that exists and one that has healthy endpoints."], ["refs", "[{\"text\":\"Kubernetes Ingress\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/ingress/#the-ingress-resource\",\"ref\":\"link\"},{\"text\":\"Kubernetes Services\",\"url\":\"https://kubernetes.io/docs/concepts/services-networking/service/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.791423"], ["id", 104]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "de9455b1-f948-5a70-8645-cd9176125614"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "de9455b1-f948-5a70-8645-cd9176125614"], ["created_at", "2020-10-07 21:58:39.802223"], ["updated_at", "2020-10-07 21:58:39.802223"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 105]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 105], ["created_at", "2020-10-07 21:58:39.811815"], ["updated_at", "2020-10-07 21:58:39.811815"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (2.2ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-118"], ["title", "All Nodes are Ready and Schedulable"], ["description", "Healthy clusters running at optimal efficiency have all nodes in the \"Ready\" state and are actively receiving workloads.  Nodes that are not in the \"Ready\" state or are cordoned/unschedulable are incurring costs but are not contributing to the cluster's capacity."], ["platform", "k8s"], ["impact", 3], ["validation", "\nRun `kubectl get nodes -o json | jq -r '.items[] | . as $node | .status.conditions[] | select((.type==\"Ready\") and .status!=\"True\") | \"($node.metadata.name): (.message)\"'` and ensure no nodes are listed.  Also, run `kubectl get nodes -o json | jq -r '.items[] | . as $node | select(.spec.unschedulable==true) | \"($node.metadata.name): cordoned/unschedulable\"'` and validate no nodes are listed."], ["remediation", "\nRepair all unhealthy nodes, and migrate workloads off of cordoned nodes before removing nodes."], ["refs", "[{\"text\":\"Node Cordoning\",\"url\":\"https://kubernetes.io/docs/concepts/architecture/nodes/#manual-node-administration\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.IP-2\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.817907"], ["id", 105]]
  [1m[35m (1.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7230ef0b-0924-509b-9b12-6c245add2d06"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7230ef0b-0924-509b-9b12-6c245add2d06"], ["created_at", "2020-10-07 21:58:39.848623"], ["updated_at", "2020-10-07 21:58:39.848623"]]
  [1m[35m (2.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 106]]
  [1m[36mTag Load (13.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.8ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 106], ["created_at", "2020-10-07 21:58:39.900400"], ["updated_at", "2020-10-07 21:58:39.900400"]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (2.0ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-119"], ["title", "All Nodes are running the identical OS, Image, and Version"], ["description", "To ensure consistent and reliable operation of the cluster and its workloads, the worker nodes should be running identical versions of the operating system image, kernel version, kube-proxy version, and kubelet version for each node pool or operating system type."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get nodes -o json | jq -r '.items[] | \"(.status.nodeInfo.containerRuntimeVersion)|(.status.nodeInfo.kernelVersion)|(.status.nodeInfo.kubeProxyVersion)|(.status.nodeInfo.kubeletVersion)|(.status.nodeInfo.osImage)\"' | wc -l` and ensure the output equals \"1\" to indicate that all nodes are identical.  Clusters that have multiple node pools or mixed operating system types should have one line count per nodepool or OS type."], ["remediation", "\nUpgrade all nodes of each node pool to a common version for each underlying component.  Mixed operating system clusters should have identical versions per operating system."], ["refs", "[{\"text\":\"Kubernetes Version Skew Support\",\"url\":\"https://kubernetes.io/docs/setup/release/version-skew-policy/\",\"ref\":\"link\"},{\"ids\":[\"PR.MA-1\",\"PR.IP-1\",\"PR.IP-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.915734"], ["id", 106]]
  [1m[35m (2.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "f0521c23-989d-53f5-bd2f-c235b6b4abe3"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "f0521c23-989d-53f5-bd2f-c235b6b4abe3"], ["created_at", "2020-10-07 21:58:39.934296"], ["updated_at", "2020-10-07 21:58:39.934296"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 107]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (1.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 107], ["created_at", "2020-10-07 21:58:39.963508"], ["updated_at", "2020-10-07 21:58:39.963508"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.7ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-120"], ["title", "All Nodes have > 20% capacity allocatable"], ["description", "Kubernetes can pack workloads tightly onto nodes for excellent resource efficiency, but overutilized nodes are more prone to exhausting available resources. This can cause other colocated applications to run more slowly or even cause the kubelet to become unhealthy and evict workloads.  In addition, clusters should always have at least one node's worth of excess capacity ready to gracefully handle workloads rescheduled due to node maintenance or evictions."], ["platform", "k8s"], ["impact", 7], ["validation", "\nRun `echo \"Node CPU Memory\"; kubectl top nodes --no-headers | awk '{print $1\" \"$3\" \"$5}'` and ensure that CPU and Memory are below 80% for all nodes."], ["remediation", "\nEnsure allocated capacity per node remains below 80%, and ensure that workloads are scheduled evenly across nodes.  Consider scaling the number of nodes up to ensure the total workload doesn't exceed 80% of the total cluster capacity."], ["refs", "[{\"text\":\"Kubernetes Metrics Server\",\"url\":\"https://kubernetes.io/docs/tasks/debug-application-cluster/resource-metrics-pipeline/\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:39.975734"], ["id", 107]]
  [1m[35m (2.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.7ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "5f226c37-de2c-56a0-8e19-3c94a23a9d7a"], ["LIMIT", 1]]
  [1m[35m (1.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.7ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "5f226c37-de2c-56a0-8e19-3c94a23a9d7a"], ["created_at", "2020-10-07 21:58:39.993578"], ["updated_at", "2020-10-07 21:58:39.993578"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (1.1ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 108]]
  [1m[36mTag Load (2.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (2.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (2.1ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 108], ["created_at", "2020-10-07 21:58:40.014768"], ["updated_at", "2020-10-07 21:58:40.014768"]]
  [1m[35m (2.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-121"], ["title", "All Nodes are spread evenly across availability zones"], ["description", "When running Kubernetes clusters on cloud providers, production clusters should have their nodes spread as evenly as possible across multiple availability-zones in a given region.  Coupled with anti-affinity rules on critical workloads and multi-zone aware persistent-volumes, it's possible to withstand a single availability-zone outage should one occur."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get nodes -ojson | jq -r '.items[].metadata | select(.annotations.\"failure-domain.beta.kubernetes.io/zone\") | \"(.name): (.annotations.\"failure-domain.beta.kubernetes.io/zone\")\"'` and validate there are multiple availability zones listed and an equal (or near equal) number of nodes in each."], ["remediation", "\nConfigure the node pool/groups to leverage multiple availability zones.  Three zones are recommended in most cases.  Most cloud providers have a configuration option for spreading nodes of the same group across multiple availability zones."], ["refs", "[{\"text\":\"Kubernetes Node Labels\",\"url\":\"https://kubernetes.io/docs/reference/kubernetes-api/labels-annotations-taints/#topologykubernetesiozone\",\"ref\":\"link\"},{\"text\":\"AKS Multiple AZ Node Groups\",\"url\":\"https://docs.microsoft.com/en-us/azure/aks/availability-zones#create-an-aks-cluster-across-availability-zones\",\"ref\":\"link\"},{\"text\":\"EKS Multiple AZ Node Pools\",\"url\":\"https://docs.aws.amazon.com/eks/latest/userguide/create-managed-node-group.html\",\"ref\":\"link\"},{\"text\":\"GKE Multiple AZ Node Pools\",\"url\":\"https://cloud.google.com/kubernetes-engine/docs/how-to/creating-a-regional-cluster\",\"ref\":\"link\"},{\"ids\":[\"PR.DS-4\",\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:40.029439"], ["id", 108]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "390bbf33-bc2c-514d-a878-e1d17282157f"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "390bbf33-bc2c-514d-a878-e1d17282157f"], ["created_at", "2020-10-07 21:58:40.042812"], ["updated_at", "2020-10-07 21:58:40.042812"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (2.1ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 109]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 109], ["created_at", "2020-10-07 21:58:40.061419"], ["updated_at", "2020-10-07 21:58:40.061419"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (1.8ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-122"], ["title", "Local disk PersistentVolumes should not mount sensitive host paths"], ["description", "While pods can be configured to mount a directory of the underlying worker node's filesystem to \"escape\" from the container, another similar pathway is by manually creating a \"Local/HostPath\" persistent volume and mounting it into the pod.  PodSecurityPolicy has native controls for the former approach, but it cannot prevent the latter.  The approach requires RBAC permissions to either create or use a custom storageclass, manually create or use a custom persistent volume, and permissions to create pods, so it is less likely to be available to non-privileged users."], ["platform", "k8s"], ["impact", 2], ["validation", "\nRun `kubectl get pv -o json | jq -r '.items[] | select(.spec.hostPath) | \"(.metadata.name): (.spec.hostPath.path)\"'` and `kubectl get pv -o json | jq -r '.items[] | select(.spec.local) | \"(.metadata.name): (.spec.local.path)\"'` and verify that no entries are listed."], ["remediation", "\nEnsure that permissions for creating custom storage classes are only granted to cluster admins, and review all storage classes and currently bound persistent volumes do not permit mounting sensitive paths on the underlying nodes in pod specifications.  Consider enforcing with a dynamic admission controller such as OPA/Gatekeeper."], ["refs", "[{\"text\":\"Kubernetes Local Persistent Volumes\",\"url\":\"https://kubernetes.io/docs/concepts/storage/volumes/#local\",\"ref\":\"link\"},{\"text\":\"OPA/Gatekeeper\",\"url\":\"https://github.com/open-policy-agent/gatekeeper\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.PT-3\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:40.068957"], ["id", 109]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "c578b676-324d-51fe-ac5c-2af5a73044d6"], ["LIMIT", 1]]
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.8ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "c578b676-324d-51fe-ac5c-2af5a73044d6"], ["created_at", "2020-10-07 21:58:40.087386"], ["updated_at", "2020-10-07 21:58:40.087386"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 110]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (1.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 110], ["created_at", "2020-10-07 21:58:40.108671"], ["updated_at", "2020-10-07 21:58:40.108671"]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-123"], ["title", "Only approved Mutating/ValidatingWebHookConfigurations in use"], ["description", "Mutating and Validating Webhooks (Webhooks) are powerful extensions to the API server request flow, and they are typically used for adding functionality to resources before they are persisted and for enforcing security policy by way of dynamic admission controllers.  Because they defer authorization to an arbitrary location and get a full copy of the request, they can potentially see sensitive information.  They also can introduce latency in the API requiest flow as the API server needs to get a response or wait for a timeout before allowing the request to proceed.  Therefore, their usage should be limited to the smallest number necessary."], ["platform", "k8s"], ["impact", 9], ["validation", "\nRun `kubectl get mutatingwebhookconfiguration -A -oyaml` and `kubectl get validatingwebhookconfiguration -A -oyaml` and ensure the listed entries are desired."], ["remediation", "\nReview the current configuration and ensure only the desired and authorized Webhooks are installed and that they are only watching the specific resourcesneeded."], ["refs", "[{\"text\":\"Dynamic Admission Control\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-4\",\"PR.IP-1\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:40.120654"], ["id", 110]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.3ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "16bf3c73-d5c7-5f71-abc2-e440f81c761b"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.3ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "16bf3c73-d5c7-5f71-abc2-e440f81c761b"], ["created_at", "2020-10-07 21:58:40.133037"], ["updated_at", "2020-10-07 21:58:40.133037"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 111]]
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.6ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 111], ["created_at", "2020-10-07 21:58:40.145089"], ["updated_at", "2020-10-07 21:58:40.145089"]]
  [1m[35m (3.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (1.0ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-124"], ["title", "PersistentVolumes should use cross-zone/Regional StorageClasses"], ["description", "Where possible, deployments and statefulsets that mount persistent volumes should be using storageclasses that support being mounted in multiple zones.  By default, cloud provider network attached storage disks are only available in a single zone.  Should a zone experience a failure or outage, that data cannot be remounted by a pod until a healthy node in that zone returns unless that disk is configured as a type that should be replicated automatically."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get storageclass -o json | jq -r '.items[]'` and review the storage classes available inside the cluster and their settings to see if regional support (vs single zone) is configured.  Then run `kubectl get deployments -A -o json | jq -r '.items[] | .spec.template.spec.volumes'` and `kubectl get sts -A -o json | jq -r '.items[] | .spec.template.spec.volumes'` to see which types of storageclass for persistent volumes are in use."], ["remediation", "\nIf supported, configure the storageclass to support multiple zones and ensure that all critical deployments and statefulsets are configured to use them."], ["refs", "[{\"text\":\"Kubernetes Persistent Volumes\",\"url\":\"https://kubernetes.io/docs/concepts/storage/volumes/\",\"ref\":\"link\"},{\"text\":\"Kubernetes Storageclasses\",\"url\":\"https://kubernetes.io/docs/concepts/storage/storage-classes/\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:40.162217"], ["id", 111]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "d62c8685-fcf8-5cec-941a-0c07c7db2eb6"], ["LIMIT", 1]]
  [1m[35m (1.0ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (1.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "d62c8685-fcf8-5cec-941a-0c07c7db2eb6"], ["created_at", "2020-10-07 21:58:40.175462"], ["updated_at", "2020-10-07 21:58:40.175462"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 112]]
  [1m[36mTag Load (0.5ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 112], ["created_at", "2020-10-07 21:58:40.195663"], ["updated_at", "2020-10-07 21:58:40.195663"]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-125"], ["title", "CronJobs/Jobs should be healthy"], ["description", "Jobs and CronJobs can often become unhealthy over time and may go unnoticed unless manually reviewed.  A common example is that of the VMWare Valero backup job to backup the contents of etcd to an external location like a cloud storage bucket.  Without that backup running successfully at a regular interval, the ability to restore the cluster to a recent state in a failure situation is compromised."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get job -A -ojson | jq -r '.items[] | select(.status.conditions) | select(.status.conditions[].type==\"Failed\" and .status.conditions[].status==\"True\") | \"(.metadata.namespace)/(.metadata.name) failed: (.status.conditions[].message)\"'` and `kubectl get cronjob -A -ojson | jq -r '.items[] | select(.status.conditions) | select(.status.conditions[].type==\"Failed\" and .status.conditions[].status==\"True\") | \"(.metadata.namespace)/(.metadata.name) failed: (.status.conditions[].message)\"'` and ensure no entries are listed."], ["remediation", "\nManually examine all CronJobs and Jobs resources for a successful execution history and resolve any issues identified.  If the Job is no longer needed, remove it."], ["refs", "[{\"text\":\"Kubernetes Jobs\",\"url\":\"https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/\",\"ref\":\"link\"},{\"ids\":[\"PR.PT-5\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:40.203858"], ["id", 112]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.5ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "0991c5c8-2e42-5237-a66b-c0b7ad84317d"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "0991c5c8-2e42-5237-a66b-c0b7ad84317d"], ["created_at", "2020-10-07 21:58:40.220070"], ["updated_at", "2020-10-07 21:58:40.220070"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.6ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 113]]
  [1m[36mTag Load (0.9ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 113], ["created_at", "2020-10-07 21:58:40.238908"], ["updated_at", "2020-10-07 21:58:40.238908"]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-126"], ["title", "Nodes should have only one valid Certificate Signing Request"], ["description", "Some Kubernetes clusters initially provision their nodes using \"bootstrap\" credentials that are just used to create and issue a certificate signing request via the Kubernetes API for a certificate keypair to be used by that node's kubelet process.  This should be a one-time event, but it may be possible for an attacker that has compromised a worker node to generate a second keypair and impersonate the kubelet.  This process would leave traces by way of the API server having more than one valid CSR entry for that node."], ["platform", "k8s"], ["impact", 3], ["validation", "\nThe output of `kubectl get nodes --no-headers | wc -l` and `kubectl get csr -A -o json | jq -r '.items[] | select(.spec.groups) | select(.spec.groups[] | contains(\"system:nodes\")) | .spec.username' | sort -u | wc -l` should be identical, signaling that only one per node has been created."], ["remediation", "\nPeriodically inspect the certificate signing requests used by bootstrap credentials to ensure that only one has been created.  If more than one is present, validate the details of each one to see if it was potentially created by a malicious user."], ["refs", "[{\"text\":\"Kubernetes Certificate Signing Requests\",\"url\":\"https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/#create-a-certificate-signing-request\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-1\",\"PR.AC-6\",\"PR.PT-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:40.248731"], ["id", 113]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.4ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "da93b32f-bb47-51a9-b6ac-4ce2aa5936c5"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "da93b32f-bb47-51a9-b6ac-4ce2aa5936c5"], ["created_at", "2020-10-07 21:58:40.260794"], ["updated_at", "2020-10-07 21:58:40.260794"]]
  [1m[35m (0.6ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 114]]
  [1m[36mTag Load (0.2ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.4ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 114], ["created_at", "2020-10-07 21:58:40.274520"], ["updated_at", "2020-10-07 21:58:40.274520"]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.3ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.5ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-127"], ["title", "RBAC Roles/ClusterRoles should not grant permissions to system:anonymous"], ["description", "The built-in group named `system:anonymous` includes any user, group, or service account without a valid credential to the API server.  In earlier versions of Kubernetes, this \"meta\" group had a small number of permissions related to API discovery, but it is no longer intended for direct use.  This group should not be used to grant permissions to cluster subjects in nearly any legitimate situation, but it can occur by mistake and lead to unnecessary pathways to data leakage and privilege escalation."], ["platform", "k8s"], ["impact", 5], ["validation", "\nRun `kubectl get clusterrolebinding -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:anonymous\" and .kind==\"Group\") | $crb.roleRef.name'` and `kubectl get rolebinding -A -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:anonymous\" and .kind==\"Group\") | $crb.roleRef.name'` and validate that no entries are listed that would indicate non-standard permissions were granted."], ["remediation", "\nReview the permissions on the `system:anonymous` group and ensure that it has no granted permissions.  Remove or modify any ClusterRoleBinding that grants additional permissions, and grant permissions directly to authenticated users, groups, or service accounts instead."], ["refs", "[{\"text\":\"Kubernetes API Discovery Roles\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#discovery-roles\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-4\",\"PR.AC-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:40.285540"], ["id", 114]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.2ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "7314bdf0-27f6-5102-a381-3bce416deb98"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "7314bdf0-27f6-5102-a381-3bce416deb98"], ["created_at", "2020-10-07 21:58:40.294086"], ["updated_at", "2020-10-07 21:58:40.294086"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 115]]
  [1m[36mTag Load (1.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.5ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 115], ["created_at", "2020-10-07 21:58:40.308461"], ["updated_at", "2020-10-07 21:58:40.308461"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.6ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-128"], ["title", "RBAC Permissions for system:authenticated should not be elevated"], ["description", "The built-in group named `system:authenticated` includes any user, group, or service account with a valid credential to the API server.  This \"meta\" group is useful for providing a baseline set of permissions that all cluster users, groups, and service accounts need for API discovery purposes.  This group should not be used to grant additional permissions to cluster subjects beyond the defaults, but it can occur by mistake and lead to unnecessary pathways to data leakage and privilege escalation."], ["platform", "k8s"], ["impact", 8], ["validation", "\nRun `kubectl get clusterrolebinding -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:authenticated\" and .kind==\"Group\") | $crb.roleRef.name' | egrep -v \"system:basic-user|system:discovery|system:public-info-viewer\"` and `kubectl get rolebinding -A -o json | jq -r '.items[] | . as $crb | select(.subjects) | .subjects[] | select(.name==\"system:authenticated\" and .kind==\"Group\") | $crb.roleRef.name' | egrep -v \"system:basic-user|system:discovery|system:public-info-viewer\"` to ensure no additional ClusterRoles or Roles have been granted to `system:authenticated`.  You can also run `kubectl auth can-i --list --as=system:authenticated` to see the current list of permissions."], ["remediation", "\nReview the permissions on the `system:authenticated` group and ensure that it is only bound to the baseline ClusterRoles: `system:basic-user`, `system:discovery`, and `system:public-info-viewer`.  Remove or modify any ClusterRoleBinding that grants additional permissions beyond these, and grant permissions directly to users, groups, or service accounts instead."], ["refs", "[{\"text\":\"Kubernetes API Discovery Roles\",\"url\":\"https://kubernetes.io/docs/reference/access-authn-authz/rbac/#discovery-roles\",\"ref\":\"link\"},{\"ids\":[\"PR.IP-1\",\"PR.AC-4\",\"PR.AC-1\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:40.321729"], ["id", 115]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mControl Load (0.9ms)[0m  [1m[34mSELECT "controls".* FROM "controls" WHERE "controls"."guid" = $1 LIMIT $2[0m  [["guid", "fa458515-7fca-52fb-b080-bec839be4779"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Create (0.4ms)[0m  [1m[32mINSERT INTO "controls" ("guid", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"[0m  [["guid", "fa458515-7fca-52fb-b080-bec839be4779"], ["created_at", "2020-10-07 21:58:40.354512"], ["updated_at", "2020-10-07 21:58:40.354512"]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTag Load (0.3ms)[0m  [1m[34mSELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."control_id" = $1[0m  [["control_id", 116]]
  [1m[36mTag Load (0.4ms)[0m  [1m[34mSELECT "tags".* FROM "tags" WHERE "tags"."name" = $1 LIMIT $2[0m  [["name", "dbc"], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mTagging Create (0.9ms)[0m  [1m[32mINSERT INTO "taggings" ("tag_id", "control_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["tag_id", 1], ["control_id", 116], ["created_at", "2020-10-07 21:58:40.370196"], ["updated_at", "2020-10-07 21:58:40.370196"]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mControl Update (0.8ms)[0m  [1m[33mUPDATE "controls" SET "name" = $1, "title" = $2, "description" = $3, "platform" = $4, "impact" = $5, "validation" = $6, "remediation" = $7, "refs" = $8, "updated_at" = $9 WHERE "controls"."id" = $10[0m  [["name", "dbc-129"], ["title", "Tiller (Helm v2) should not be deployed"], ["description", "Helm version 1.x and 2.x rely on an in-cluster deployment named `Tiller` to handle lifecycle management of Kubernetes application bundles called `charts`.  The `Tiller` deployment is commonly granted elevated privileges to be able to carry out creation/deletion of resources contained inside `charts`, and it exposes a gRPC port on TCP/44134 without authentication or authorization, by default.  This combination was common, and it afforded a simple and direct path to escalation to cluster-admin from any pod in the cluster.  Now that Helm v3 no longer relies on an in-cluster component, `Tiller` is a signal that the cluster administrators have not upgraded to the more secure version."], ["platform", "k8s"], ["impact", 10], ["validation", "\nRun `kubectl get pods --all-namespaces -o name | grep tiller` and validate that no pods starting with the name `tiller-deploy-****` exist."], ["remediation", "\nRefer to https://helm.sh/docs/topics/v2_v3_migration/ for guidance on migrating away from `Tiller`.  For new cluster deployments, use Helm v3 and above going forward."], ["refs", "[{\"text\":\"Helm\",\"url\":\"https://helm.sh\",\"ref\":\"link\"},{\"text\":\"Tiller v2\",\"url\":\"https://helm.sh/docs/faq/#removal-of-tiller\",\"ref\":\"link\"},{\"text\":\"Helm Migration from v2 to v3\",\"url\":\"https://helm.sh/docs/topics/v2_v3_migration/\",\"ref\":\"link\"},{\"text\":\"Misusing Tiller\",\"url\":\"https://engineering.bitnami.com/articles/helm-security.html\",\"ref\":\"link\"},{\"ids\":[\"PR.AC-3\",\"PR.AC-5\",\"PR.DS-2\",\"PR.IP-1\",\"PR.IP-5\"],\"ref\":\"csf\"}]"], ["updated_at", "2020-10-07 21:58:40.384275"], ["id", 116]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
